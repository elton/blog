<?xml version="1.0"?>
<rss version="2.0">
  <channel>
    <title>Elton&#39;s Blog</title>
    <link>http://blog.prosight.me</link>
    <pubDate>2013-03-31 08:08:31 +0800</pubDate>
    <item>
      <title>解决ubuntu server添加新用户后无法使用tab自动完成命令功能</title>
      <link>http://blog.prosight.me/blogs/1167</link>
      <pubDate>2013-03-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;因为ubuntu server默认使用的是Bourne shell而不是Bash shell，所以导致当使用&lt;/p&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ useradd username
&lt;/pre&gt;
的时候，没有命令自动完成功能。&lt;/p&gt;

&lt;p&gt;使用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ chsh -s /bin/bash username
&lt;/pre&gt;
可以改变某个用户的bash&lt;/p&gt;

&lt;p&gt;如果想改变默认shell，需要修改
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo vim /etc/defaults/used
&lt;/pre&gt;
修改其中的SHELL变量为：
$ SHELL=/bin/bash&lt;/p&gt;
</description>
    </item>
    <item>
      <title>修改MySQL字段类型</title>
      <link>http://blog.prosight.me/blogs/1162</link>
      <pubDate>2013-03-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果要修改MySQL字段类型，可是使用下面的方式：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
alter table &lt;表名&gt; change &lt;字段名&gt; &lt;字段名&gt; &lt;新的类型&gt;;

如：
alter table people change areaId areaId varchar(255);
&lt;/pre&gt;

&lt;p&gt;change用法：
CHANGE old_col_name new_col_name column_definition
可以用来更改字段名或者字段类型&lt;/p&gt;

&lt;p&gt;详见：http://dev.mysql.com/doc/refman/5.6/en/alter-table.html&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Ubuntu使用rsync</title>
      <link>http://blog.prosight.me/blogs/1159</link>
      <pubDate>2013-03-03 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;ubuntu默认没有启动rsync
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo vim /etc/default/rsync&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#修改下面，使rsync可用
RSYNC_ENABLE=true
&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;修改rsync.conf配置
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$sudo cp /usr/share/doc/rsync/examples/rsyncd.conf /etc&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;#参考配置文件修改如下：&lt;/p&gt;

&lt;h1&gt;sample rsyncd.conf configuration file&lt;/h1&gt;

&lt;h1&gt;GLOBAL OPTIONS&lt;/h1&gt;

&lt;p&gt;motd file=/etc/motd
log file=/var/log/rsyncd&lt;/p&gt;

&lt;h1&gt;for pid file, do not use /var/run/rsync.pid if&lt;/h1&gt;

&lt;h1&gt;you are going to run rsync out of the init.d script.&lt;/h1&gt;

&lt;h1&gt;The init.d script does its own pid file handling,&lt;/h1&gt;

&lt;h1&gt;so omit the &amp;ldquo;pid file&amp;rdquo; line completely in that case.&lt;/h1&gt;

&lt;p&gt;pid file=/var/run/rsyncd.pid
syslog facility=daemon
#socket options=&lt;/p&gt;

&lt;h1&gt;MODULE OPTIONS&lt;/h1&gt;

&lt;h1&gt;模块名称&lt;/h1&gt;

&lt;p&gt;[rsync]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;comment = public archive
path = /path/to/rsync
use chroot = yes
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;max connections=10&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;lock file = /var/lock/rsyncd
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;the default for read only is yes&amp;hellip;&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;read only = yes
list = yes
uid = nobody
gid = nogroup
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;exclude =&lt;/h1&gt;

&lt;h1&gt;exclude from =&lt;/h1&gt;

&lt;h1&gt;include =&lt;/h1&gt;

&lt;h1&gt;include from =&lt;/h1&gt;

&lt;p&gt;#该选项指定由空格或逗号分隔的用户名列表，只有这些用户才允许连接该模块。这里的用户和系统用户没有任何关系。如果&amp;rdquo;auth users&amp;rdquo;被设置，那么客户端发出对该模块的连接请求以后会被rsync请求challenged进行验证身份这里使用的 challenge/response认证协议。用户的名和密码以明文方式存放在&amp;rdquo;secrets file&amp;rdquo;选项指定的文件中。默认情况下无需密码就可以连接模块(也就是匿名方式)
    auth users = backup
    secrets file = /etc/rsyncd.pass
    strict modes = yes&lt;/p&gt;

&lt;h1&gt;hosts allow =&lt;/h1&gt;

&lt;h1&gt;hosts deny =&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;ignore errors = no
ignore nonreadable = yes
transfer logging = no
&lt;/code&gt;&lt;/pre&gt;

&lt;h1&gt;log format = %t: host %h (%a) %o %f (%l bytes). Total %b bytes.&lt;/h1&gt;

&lt;pre&gt;&lt;code&gt;timeout = 600
refuse options = checksum dry-run
dont compress = *.gz *.tgz *.zip *.z *.rpm *.deb *.iso *.bz2 *.tbz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;创建一个密码文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$sudo vi /etc/rsyncd.pass
backup:123456
$sudo chmod 0600 /etc/rsyncd.pass
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动服务器
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo /etc/init.d/rsync start
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置客户端
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
rsync -vzrtopg &amp;ndash;progress &amp;ndash;delete backup@10.0.0.12::rsync /backup/
&lt;/pre&gt;
backup就是/etc/rsyncd.pass设置的用户名，rsync是/etc/rsync.conf中的模块名称
然后输入在syncd.pass中的密码，就完成了一次同步。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;设定定时任务
如果想每隔一段时间自动同步两个目录，那么可以这么做
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$sudo vi /etc/rsync.pwd
#输入/etc/rsyncd.pass中设置的密码
$crontab -e
*/5 * * * * rsync &amp;ndash;password-file=/etc/rsync.pwd -vzrtopg &amp;ndash;progress &amp;ndash;delete backup@10.0.0.12::rsync /backup/&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;$/etc/init.d/cron restart
&lt;/pre&gt;
这样就每隔5分钟就自动同步文件一次了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Nginx 在POST提交数据时，报 HTTP411 Content-Length required 错误</title>
      <link>http://blog.prosight.me/blogs/1154</link>
      <pubDate>2013-03-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在使用Nginx 1.3.9以下版本，都存在当用户POST一个带有文件的请求的时候，出现HTTP 411错误。&lt;/p&gt;

&lt;p&gt;这个是Nginx的问题，需要打一个补丁。https://github.com/agentzh/chunkin-nginx-module&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#下载chunkin模块
git clone https://github.com/agentzh/chunkin-nginx-module.git

#编译nginx,使用chunkin模块
wget http://nginx.org/download/nginx-1.2.7.tar.gz
tar xvzf nginx-1.2.7.tar.gz
cd nginx-1.2.7
./configure --prefix=/usr/local/nginx --user=www --group=www --with-http_ssl_module --with-http_gzip_static_module --with-google_perftools_module --with-http_realip_module --add-module=../chunkin-nginx-module 

make -j8
make install
&lt;/pre&gt;

&lt;p&gt;然后在nginx.conf中添加
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
chunkin on;&lt;/p&gt;

&lt;p&gt;error_page 411 = @my_411_error;
  location @my_411_error {
      chunkin_resume;
  }
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;之后重启nginx就可以了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.</title>
      <link>http://blog.prosight.me/blogs/1150</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在建立从库的时候，如果是InndoDB的数据库，需要停掉主库，然后拷贝data目录到从库覆盖从库的data。&lt;/p&gt;

&lt;p&gt;然后使用&lt;a href=&#34;http://dev.mysql.com/doc/refman/5.6/en/change-master-to.html&#34; title=&#34;change master to&#34; target=&#34;_blank&#34;&gt;CHANGE MASTER TO&lt;/a&gt;命令建立主从关联，再使用start slave启动从库。&lt;/p&gt;

&lt;p&gt;但是，这样会发现出现
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Fatal error: The slave I/O thread stops because master and slave have equal MySQL server UUIDs; these UUIDs must be different for replication to work.
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;导致同步I/O出错。原因在于，拷贝整个data目录，把auto.cnf文件也拷贝过来了，里面记录了数据库的uuid，每个库的uuid应该是不一样的。&lt;/p&gt;

&lt;p&gt;解决办法，重新更改一下从库的server-id，然后重启服务，问题就解决了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>自动清理MySQL binlog日志与手动删除的设置</title>
      <link>http://blog.prosight.me/blogs/1152</link>
      <pubDate>2013-02-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在一个繁忙的master db server上，MySQL binlog日志文件增长速度很快，如果不定时清除，硬盘空间很快就会被充满。&lt;/p&gt;

&lt;p&gt;设置自动清理MySQL binlog日志，配置my.cnf：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
expire_logs_days = 10
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在运行时修改：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
show binary logs;&lt;br /&gt;
show variables like &amp;lsquo;expire_logs_days&amp;rsquo;;
#默认是0，表示永远不过期
set global expire_logs_days = 10;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;手动删除10天前的MySQL binlog日志：
1. 使用show slave status\G查看从最新同步的binlog日志
2. 使用purge binary logs to &amp;lsquo;mysql-bin.000****&amp;lt;日志名称&amp;gt;&amp;lsquo;删除目前正在同步的日志以外的所有日志。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用淘宝提供的Rubygems镜像</title>
      <link>http://blog.prosight.me/blogs/1148</link>
      <pubDate>2013-02-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;由于国内网络原因，导致 rubygems.org 存放在 Amazon S3 上面的资源文件间歇性连接失败。所以你会与遇到 gem install rack 或 bundle install 的时候半天没有响应。&lt;/p&gt;

&lt;p&gt;淘宝的源官方确保每15分钟更新一次，保证跟源一致，使用淘宝的源会快很多。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ gem sources --remove http://rubygems.org/
$ gem sources -a http://ruby.taobao.org/
$ gem sources -l
*** CURRENT SOURCES ***

http://ruby.taobao.org
# 请确保只有 ruby.taobao.org
$ gem install rails
&lt;/pre&gt;

&lt;p&gt;淘宝源的页面：http://ruby.taobao.org&lt;/p&gt;
</description>
    </item>
    <item>
      <title>maven向本土仓库导入jar包（处理官网没有的jar包）</title>
      <link>http://blog.prosight.me/blogs/1133</link>
      <pubDate>2013-02-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;对于官网没有的jar包，maven向本地仓库导入jar包用如下命令
&lt;pre class=&#34;prettyprint linenums&#34;&gt;mvn install:install-file
-DgroupId=包名
-DartifactId=项目名
-Dversion=版本号
-Dpackaging=jar
-Dfile=jar文件所在路径&lt;/pre&gt;
以pinyin4j-2.5.0为例：&lt;/p&gt;

&lt;p&gt;1、将pinyin4j-2.5.0.jar文件放在“D:\JAR_LIB”目录下（该目录任意）&lt;/p&gt;

&lt;p&gt;2、执行命令：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;mvn install:install-file -Dfile=D:\JAR_LIB\pinyin4j-2.5.0.jar -DgroupId=net.sourceforge.pinyin4j -DartifactId=pinyin4j -Dversion=2.5.0 -Dpackaging=jar  -DgeneratePom=true -DcreateChecksum=true&lt;/pre&gt;
这样maven向本地仓库导入 pinyin4j-2.5.0.jar 包就成功了。&lt;/p&gt;

&lt;p&gt;3.pom.xml文件配置：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;dependency&gt;
      &lt;groupId&gt;net.sourceforge.pinyin4j&lt;/groupId&gt;
      &lt;artifactId&gt;pinyin4j&lt;/artifactId&gt;
      &lt;version&gt;2.5.0&lt;/version&gt;
&lt;/dependency&gt;
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Ubuntu Server设置NFS文件共享</title>
      <link>http://blog.prosight.me/blogs/1139</link>
      <pubDate>2013-02-23 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设置iptables，打开NFS对应的端口
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-A INPUT -s 10.0.0.0/24 -p tcp -m state &amp;ndash;state NEW -m tcp &amp;ndash;dport 2049 -j ACCEPT
-A INPUT -s 10.0.0.0/24 -p udp -m state &amp;ndash;state NEW -m udp &amp;ndash;dport 2049 -j ACCEPT
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装NFS server
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo apt-get install nfs-kernel-server
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;建立共享目录
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
mkdir -p /share
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置NFS
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo vim /etc/exports&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;/share  10.0.0.0/24(rw,all_squash,anonuid=1000,anongid=1000,nohide,insecure,no_subtree_check,async)
&lt;/pre&gt;
如果你想指定所有访问这个共享目录操作文件都使用指定的uid和gid，把所有访问都转换成这个用户的操作，就可以按照上面设置。 all_squash，就是转换用户身份，anonuid,anongid指定的就是用户的uid和gid。
想查看某一个用户的uid和gid可以使用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
id username
&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;启动NFS
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo /etc/init.d/nfs-kernel-server start
&lt;/pre&gt;
检查一下nfs的权限配置情况
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
tail /var/lib/nfs/etab
/share  10.0.0.0/24(rw,async,wdelay,nohide,nocrossmnt,insecure,root_squash,all_squash,no_subtree_check,secure_locks,acl,anonuid=100,anongid=100)
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置客户端
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo mount -t nfs 10.0.0.74:/share share
&lt;/pre&gt;
查看挂载情况：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
df -h
10.0.0.74:/share   92G  676M   87G   1% /share
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;之后就可以像本地硬盘一样访问nfs了&lt;/p&gt;
</description>
    </item>
    <item>
      <title>IR_Black Theme for Terminal for OSX</title>
      <link>http://blog.prosight.me/blogs/1129</link>
      <pubDate>2013-02-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;发现了一个比较好的Theme，用在terminal中挺舒服的。
&lt;img alt=&#34;&#34; src=&#34;http://assets.toddwerth.com/blog_extras/ir_black_terminal/irb_term_example_colors.png&#34; title=&#34;IR_Black&#34; class=&#34;alignnone&#34; width=&#34;571&#34; height=&#34;461&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在&lt;a href=&#34;http://blog.toddwerth.com/entry_files/13/IR_Black.terminal.zip&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;下载
解压后双击就可以安装了，可以选择IR_Black为默认Theme&lt;/p&gt;

&lt;p&gt;如果你发现你的界面没有彩色显示，可以设置环境变量
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
export CLICOLOR=1
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>MySQL InnoDB 内存占用公式</title>
      <link>http://blog.prosight.me/blogs/1127</link>
      <pubDate>2013-02-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;innodb_buffer_pool_size
+ key_buffer_size
+ max_connections * ( sort_buffer_size + read_buffer_size + binlog_cache_size )
+ max_connections * 2MB&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Mac下正确配置JAVA_HOME</title>
      <link>http://blog.prosight.me/blogs/1124</link>
      <pubDate>2013-02-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在Mac下，如果想正确配置JAVA_HOME，每次更新JDK后都能正确链接到最新版本的话，需要设置正确的环境变量。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
export JAVA_HOME=`/usr/libexec/java_home`
&lt;/pre&gt;

&lt;p&gt;这样，以后每次安装JDK的dmg包后，就自动指向到最新的jdk了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>CentOS修改用户最大进程数</title>
      <link>http://blog.prosight.me/blogs/1118</link>
      <pubDate>2013-01-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一般在/etc/security/limits.conf 中修改最大打开文件数和进程数，如：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;soft    noproc  10240&lt;/li&gt;
&lt;li&gt;hard    noproc  10240&lt;/li&gt;
&lt;li&gt;soft    nofile  10240&lt;/li&gt;
&lt;li&gt;hard    nofile  10240&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;但是在CentOS 6.3下，noproc的设置无效。需要修改/etc/security/limits.d/90-nproc.conf, 把noproc的设置放在这个文件里，重启服务器后，就生效了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>CentOS配置时间同步NTP</title>
      <link>http://blog.prosight.me/blogs/1116</link>
      <pubDate>2013-01-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;为什么要使用ntpd而不是ntpdate？&lt;/p&gt;

&lt;p&gt;原因很简单，ntpd是步进式的逐渐调整时间，而ntpdate是断点更新，比如现在服务器时间是9.18分，而标准时间是9.28分，ntpd会在一段时间内逐渐的把时间校准到与标准时间相同，而ntpdate会立刻把时间调整到9.28分，如果你往数据库内写入内容或在其他对时间有严格要求的生产环境下，产生的后果会是很严重的。（注：当本地时间与标准时间相差30分钟以上是ntpd会停止工作）
&lt;h2&gt;&lt;a id=&#34;ntp通信协议原理&#34; name=&#34;ntp通信协议原理&#34;&gt;&lt;/a&gt;NTP通信协议原理&lt;/h2&gt;
&lt;div&gt;&lt;/p&gt;

&lt;p&gt;1.首先主机启动NTP。&lt;/p&gt;

&lt;p&gt;2.客户端会向NTP服务器发送调整时间的message。&lt;/p&gt;

&lt;p&gt;3.然后NTP server会送出当前的标准时间给client&lt;/p&gt;

&lt;p&gt;4.client接受来自server的时间后，会根据这个信息来调整自己的时间。这样就实现了网络对时。&lt;/p&gt;

&lt;p&gt;NTP这个deamon采用了123端口。（UDP）&lt;/p&gt;

&lt;p&gt;“当我们要利用Tim server来进行实践的同步更新时，就需要使用NTP软件提供的ntpdate来连接端口123”&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
&lt;h2&gt;&lt;a id=&#34;与时间相关的一些命令和配置文件&#34; name=&#34;与时间相关的一些命令和配置文件&#34;&gt;&lt;/a&gt;与时间相关的一些命令和配置文件&lt;/h2&gt;
&lt;div&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;1./etc/ntp.conf&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;linux各版本虽然目录不同，但文件名相同。可以用which ntp.conf 或者locate ntp.conf来查找。这是NTP唯一的一个设置文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2./usr/share/zoneinfo/&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个里面规定了这个主要时区的时间设置文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3./etc/sysconfig/clock&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个文件是linux的主要时区设置文件，每次开机后linux会自动读取这个文件来设置系统所默认的显示时间，可以看看它里面到底设置了什么：
&lt;pre&gt;cat /etc/sysconfig/clock&lt;/p&gt;

&lt;h1&gt;The ZONE parameter is only evaluated by system-config-date.&lt;/h1&gt;

&lt;h1&gt;The timezone of the system is defined by the contents of /etc/localtime.&lt;/h1&gt;

&lt;p&gt;ZONE=&amp;ldquo;Asia/Shanghai&amp;rdquo;
UTC=true
ARC=false&lt;/pre&gt;
&lt;strong&gt;4./etc/localtime&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;本地端时间配置文件。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5./bin/date&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个是时间的修改命令，除了输出时间，还可以修改时间。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6./sbin/hwclock&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;因为linux系统上面BIOS时间与linux系统时间是分开的，所以使用date这个指令调整了时间之后，还需要使用hwclock才能将修改过的时间写入BIOS中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;7./usr/sbin/ntpd&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是NTP的daemon文件，需要启动它才能提供NTP服务，这个命令会读取/etc/ntp.conf里面的设置。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;8./usr/sbin/ntpdate&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这是client用来连接NTP Server的主要执行文件，如果您不想启用NTP，只想启用NTP Client功能的话，可以只应用此命令。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;9，/usr/sbin/ntptrace&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;可以用来追踪某台时间服务器的时间对应关系。&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
&lt;h2&gt;&lt;a id=&#34;安装与配置&#34; name=&#34;安装与配置&#34;&gt;&lt;/a&gt;安装与配置&lt;/h2&gt;
&lt;div&gt;&lt;/p&gt;

&lt;p&gt;1、设置时区
&lt;pre&gt;cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/pre&gt;
2、安装ntpd服务
&lt;pre&gt;yum -y install ntp&lt;/pre&gt;
3、配置ntpd&lt;/p&gt;

&lt;p&gt;vi /etc/ntp.conf
&lt;pre&gt;&lt;br /&gt;
restrict default kod nomodify notrap nopeer noquery   #
restrict -6 default kod nomodify notrap nopeer noquery  #针对ipv6设置&lt;/p&gt;

&lt;h1&gt;允许本地所有操作&lt;/h1&gt;

&lt;p&gt;restrict 127.0.0.1
restrict -6 ::1&lt;/p&gt;

&lt;h1&gt;允许的局域网络段或单独ip&lt;/h1&gt;

&lt;p&gt;restrict 10.0.0.0 mask 255.0.0.0 nomodify motrap
restrict 192.168.0.0 mask 255.255.255.0 nomodify motrap
restrict 192.168.1.123 mask 255.255.255.255 nomodify motrap&lt;/p&gt;

&lt;h1&gt;使用上层的internet ntp服务器&lt;/h1&gt;

&lt;p&gt;restrict cn.pool.ntp.org
restrict 1.cn.poo.ntp.org
restrict 0.asia.pool.ntp.org
restrict 3.asia.pool.ntp.org&lt;/p&gt;

&lt;p&gt;server cn.pool.ntp.org prefer
server 1.cn.poo.ntp.org
server 0.asia.pool.ntp.org
server 3.asia.pool.ntp.org&lt;/p&gt;

&lt;h1&gt;如果无法与上层ntp server通信以本地时间为标准时间&lt;/h1&gt;

&lt;p&gt;server   127.127.1.0    # local clock
fudge    127.127.1.0 stratum 10&lt;/p&gt;

&lt;h1&gt;计算本ntp server 与上层ntpserver的频率误差&lt;/h1&gt;

&lt;p&gt;driftfile /var/lib/ntp/drift&lt;/p&gt;

&lt;h1&gt;Key file containing the keys and key identifiers used when operating&lt;/h1&gt;

&lt;h1&gt;with symmetric key cryptography.&lt;/h1&gt;

&lt;p&gt;keys /etc/ntp/keys
#日志文件
logfile /var/log/ntp.log&lt;/pre&gt;
修改/etc/sysconfig/ntpd:
&lt;pre&gt;# Drop root to id &amp;lsquo;ntp:ntp&amp;rsquo; by default.
OPTIONS=&amp;ldquo;-u ntp:ntp -p /var/run/ntpd.pid&amp;rdquo;&lt;/p&gt;

&lt;h1&gt;Set to &amp;lsquo;yes&amp;rsquo; to sync hw clock after successful ntpdate&lt;/h1&gt;

&lt;p&gt;SYNC_HWCLOCK=yes #make no into yes; BIOS的时间也会跟着修改&lt;/p&gt;

&lt;h1&gt;Additional options for ntpdate&lt;/h1&gt;

&lt;p&gt;NTPDATE_OPTIONS=&amp;ldquo;&amp;rdquo;&lt;/pre&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;a id=&#34;验证与状态检查&#34; name=&#34;验证与状态检查&#34;&gt;&lt;/a&gt;验证与状态检查&lt;/h2&gt;
&lt;div&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;运行ntp&lt;/strong&gt;
&lt;pre&gt;service ntpd start/stop/restart&lt;/pre&gt;
&lt;strong&gt;查看ntp的端口&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;应该看到123端口
&lt;pre&gt;netstat -unlnp&lt;/pre&gt;
&lt;strong&gt;查看ntp服务器有无和上层连通&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;ntpstat&lt;/h1&gt;

&lt;p&gt;&lt;pre&gt;synchronised to NTP server () at stratum 2
time correct to within 74 ms
polling server every 128 s&lt;/pre&gt;
注意：此命令出现上述synchronised结果比较慢，我的用了大概5分钟。&lt;/p&gt;

&lt;p&gt;如果想开机自启动ntpd
$ sudo chkconfig &amp;ndash;level 35 ntpd on&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看ntp服务器与上层间的联系&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;ntptrace -n 127.0.0.1&lt;/h1&gt;

&lt;p&gt;&lt;pre&gt;127.0.0.1: stratum 3, offset -0.001095, synch distance 0.532610
116.193.83.174: timed out, nothing received&lt;/pre&gt;
&lt;strong&gt;查看ntp服务器与上层ntp服务器的状态&lt;/strong&gt;&lt;/p&gt;

&lt;h1&gt;ntpq -p&lt;/h1&gt;

&lt;p&gt;其中:
&lt;pre&gt;remote - 本机和上层ntp的ip或主机名，“+”表示优先，“*”表示次优先
refid - 参考上一层ntp主机地址
st - stratum阶层
when - 多少秒前曾经同步过时间
poll - 下次更新在多少秒后
reach - 已经向上层ntp服务器要求更新的次数
delay - 网络延迟
offset - 时间补偿
jitter - 系统时间与bios时间差&lt;/pre&gt;
如果所有远程服务器的jitter值是4000并且delay和reach的值是0，那么说明时间同步是有问题的&lt;/p&gt;

&lt;p&gt;可能的原因是防火墙阻断了与server之间的通讯，即123端口是否正常开放；&lt;/p&gt;

&lt;p&gt;此外每次重启NTP服务器之后大约要3－5分钟客户端才能与server建立正常的通讯连接，否则你在客户端执行“ntpdate 服务器ip”的时候将返回：
&lt;pre&gt;27 Jun 10:20:17 ntpdate[21920]: no server suitable for synchronization found&lt;/pre&gt;
&lt;/div&gt;
&lt;h2&gt;&lt;a id=&#34;启动ntpd&#34; name=&#34;启动ntpd&#34;&gt;&lt;/a&gt;启动NTPD&lt;/h2&gt;
&lt;div&gt;&lt;/p&gt;

&lt;p&gt;我采用了一个很笨的办法来手动启动ntpd，而不是把ntpd加入服务，写一个简单的脚本&lt;/p&gt;

&lt;p&gt;vi ntpstart.sh
&lt;pre&gt;ntpdate cn.pool.ntp.org
ntpdate cn.pool.ntp.org
service ntpd start&lt;/pre&gt;
然后加入/etc/rc.local
&lt;pre&gt;/shpath/ntpstart.sh&lt;/pre&gt;
这是因为我有一台服务器启动后的时间总是与标准时间差别很大，每次启动后ntpd要花很多时间才能把时间校准，所以我是先在系统启动后ntpdate更新两次，然后再启动ntpd服务，在freebsd里好像有修改配置文件，让时间服务器在系统启动之前启动的，centos还没仔细琢磨&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;&lt;/p&gt;

&lt;h2&gt;客户端配置&lt;/h2&gt;

&lt;div&gt;

方法1.使用ntpdate与上面配置的时间服务器定时同步，不推荐此方法

方法2.安装ntpd，指定时间server为上面配置的服务器地址，推荐

更详细的介绍参见台湾 鸟哥的Linux私房菜

&lt;a title=&#34;http://linux.vbird.org/linux_server/0440ntp.php&#34; href=&#34;http://linux.vbird.org/linux_server/0440ntp.php&#34; rel=&#34;nofollow&#34; target=&#34;_blank&#34;&gt;http://linux.vbird.org/linux_server/0440ntp.php&lt;/a&gt;

&lt;/div&gt;
## 附录
&lt;div&gt;

中国国家授时中心(陕西西安) 210.72.145.44

上海： 61.129.66.79 (t2.hshh.org) 61.129.42.44 (ntp.fudan.edu.cn) 202.120.2.101 (ntp.sjtu.edu.cn)

浙江 218.75.4.130 (t1.hshh.org)

内蒙古 218.21.130.42 (t1.hshh.org)

香港: 137.189.11.66 (clock.cuhk.edu.hk ) 137.189.11.128 (ntp.cuhk.edu.hk )

台湾: 220.130.158.52(time.stdtime.gov.tw) 220.130.158.72(Clock.stdtime.gov.tw)

220.130.158.51(tick.stdtime.gov.tw) 220.130.158.54(watch.stdtime.gov.tw)

asia.pool.ntp.org， 更多亚洲服务器请参考 &lt;a title=&#34;http://www.pool.ntp.org/zone/asia&#34; href=&#34;http://www.pool.ntp.org/zone/asia&#34; rel=&#34;nofollow&#34; target=&#34;_blank&#34;&gt;http://www.pool.ntp.org/zone/asia&lt;/a&gt;

cn.pool.ntp.org, 更多中国服务器请参考 &lt;a title=&#34;http://www.pool.ntp.org/zone/cn&#34; href=&#34;http://www.pool.ntp.org/zone/cn&#34; rel=&#34;nofollow&#34; target=&#34;_blank&#34;&gt;http://www.pool.ntp.org/zone/cn&lt;/a&gt;

tw.pool.ntp.org, 更多中国台湾服务器请参考 &lt;a title=&#34;http://www.pool.ntp.org/zone/tw&#34; href=&#34;http://www.pool.ntp.org/zone/tw&#34; rel=&#34;nofollow&#34; target=&#34;_blank&#34;&gt;http://www.pool.ntp.org/zone/tw&lt;/a&gt;

hk.pool.ntp.org, 更多中国香港服务器请参考 &lt;a title=&#34;http://www.pool.ntp.org/zone/hk&#34; href=&#34;http://www.pool.ntp.org/zone/hk&#34; rel=&#34;nofollow&#34; target=&#34;_blank&#34;&gt;http://www.pool.ntp.org/zone/hk&lt;/a&gt;

&lt;/div&gt;
</description>
    </item>
    <item>
      <title>CentOS使用minimal安装后，无法使用SCP</title>
      <link>http://blog.prosight.me/blogs/1106</link>
      <pubDate>2013-01-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;当使用minimal方式装完CentOS 6.3后，发现无法使用scp，默认情况下minimal很多软件都没有安装，导致使用的时候报错。错误如下：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ scp test root@192.168.56.20:~
root@192.168.56.20′s password:
bash: scp: command not found
lost connection
$
&lt;/pre&gt;

&lt;p&gt;出现这个错误，是因为少安装了openssh-clients这个包，安装后就恢复正常了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Java Crypto在Linux下性能低下问题的解决方案</title>
      <link>http://blog.prosight.me/blogs/1114</link>
      <pubDate>2013-01-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在Linux下，如果你使用 java.security 包中的方法（比如SecureKeyFactory.generateSecret()），会发现它出奇的慢，有时候甚至是半僵死在那里。&lt;/p&gt;

&lt;p&gt;有两个方法解决这个问题&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;编辑${java.home}/jre/lib/security/java.security，找到securerandom.source，把它的值改成(默认值file:/dev/urandom，效果很差）
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
securerandom.source=file:/dev/./urandom
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装rng-tools
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[root@linux ~]# yum install rng-tools
[root@linux ~]# echo &amp;lsquo;EXTRAOPTIONS=&amp;ldquo;-i -o /dev/random -r /dev/urandom -t 10 -W 2048&amp;rdquo;&amp;rsquo; &amp;gt; /etc/sysconfig/rngd
[root@linux ~]# chkconfig rngd on
[root@linux ~]# service rngd restart
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考：http://development.adaptris.com/~lchan/blog/&lt;sup&gt;2012&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;/15/slow-java-crypto-performance-on-linux/&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在Ubuntu上安装Oracle JDK</title>
      <link>http://blog.prosight.me/blogs/1104</link>
      <pubDate>2013-01-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果不想使用Ubuntu提供的OpenJDK，想使用Oracle的版本。可以进行如下操作&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;解压下载的jdk压缩包
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
tar xvzf jdk-7u10-linux-x64.tar.gz
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;移动到系统lib目录
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo mv ./jdk1.7.0_10 /usr/lib/jvm/jdk1.7.0
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;更新系统
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo update-alternatives &amp;ndash;install &amp;ldquo;/usr/bin/java&amp;rdquo; &amp;ldquo;java&amp;rdquo; &amp;ldquo;/usr/lib/jvm/jdk1.7.0/bin/java&amp;rdquo; 1
sudo update-alternatives &amp;ndash;install &amp;ldquo;/usr/bin/javac&amp;rdquo; &amp;ldquo;javac&amp;rdquo; &amp;ldquo;/usr/lib/jvm/jdk1.7.0/bin/javac&amp;rdquo; 1
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置系统
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo update-alternatives &amp;ndash;config java
There are 2 choices for the alternative java (providing /usr/bin/java).&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2&gt;Selection    Path                                            Priority   Status&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;0            /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java   1071      auto mode
1            /usr/lib/jvm/java-7-openjdk-amd64/jre/bin/java   1071      manual mode
2            /usr/lib/jvm/jdk1.7.0/bin/java                   1         manual mode
Press enter to keep the current choice[*], or type selection number: 2
&lt;/pre&gt;
选择刚刚配置的jdk。
类似再操作
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo update-alternatives &amp;ndash;config javac
&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;之后，就可以使用java -version检测一下是否安装正确了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>git设置远程Repository</title>
      <link>http://blog.prosight.me/blogs/1102</link>
      <pubDate>2013-01-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Step 1:设置用户和组
设置需要使用远程Repository的用户和组，比如需要John, Andrew和Robert三个开发者需要使用远程git Repository&lt;/p&gt;

&lt;p&gt;在服务器端设置：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo groupadd developers
$ sudo useradd -G developers -d /home/john -m -s /bin/bash john
$ sudo useradd -G developers -d /home/andrew -m -s /bin/bash andrew
$ sudo useradd -G developers -d /home/robert -m -s /bin/bash robert
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;设置他们的密码
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo passwd john
$ sudo passwd andrew
$ sudo passwd robert
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Step 2:设置无密码ssh登录
因为git要使用ssh方式登录服务器读取数据，为方便操作，所以要设置一下无密码操作的ssh，具体设置参见&lt;a href=&#34;http://blog.prosight.me/index.php/2013/01/1097&#34; title=&#34;http://blog.prosight.me/index.php/2013/01/1097&#34;&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Step 3:设置远程git Repository
假设服务器端的仓库放置在管理员的用户目录中，具体操作如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cd ~
$ mkdir -p repositories/project.git
$ cd repositories/project.git
$ git init &amp;ndash;bare &amp;ndash;shared=group&lt;/p&gt;

&lt;h1&gt;Initialized empty shared Git repository in repositories/project.git/&lt;/h1&gt;

&lt;p&gt;$ ls&lt;/p&gt;

&lt;h1&gt;branches  config  description  HEAD  hooks  info  objects  refs&lt;/h1&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;更改目录权限，配置给developers这个组
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo chgrp -R developers .
$ ls -l&lt;/p&gt;

&lt;h1&gt;drwxrwsr-x 2 manager developers 4096 2011-01-19 13:38 branches&lt;/h1&gt;

&lt;h1&gt;-rw-rw-r&amp;ndash; 1 manager developers  126 2011-01-19 13:38 config&lt;/h1&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Step 4:访问远程仓库
为了方便开发人员的操作，把远程仓库给每个开发人员自己用户目录中建立一个软连接
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo ln -s /home/manager/repositories/project.git/ /home/john/
$ sudo ln -s /home/manager/repositories/project.git/ /home/andrew/
$ sudo ln -s /home/manager/repositories/project.git/ /home/robert/
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在开发人员John的电脑上
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ mkdir -p ~/work/project/
$ cd ~/work/project/
$ git clone john@git.yourcompany.com:project.git .&lt;/p&gt;

&lt;h1&gt;Initialized empty Git repository in ~/work/project/.git/&lt;/h1&gt;

&lt;p&gt;&lt;/pre&gt;
这样就初始化了一个空的仓库，下面填些内容做个测试
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ echo &amp;ldquo;Hello&amp;rdquo; &amp;gt; readme.txt
$ git add readme.txt
$ git commit -m &amp;ldquo;Adding a readme file&amp;rdquo;
$ git push origin master&lt;/p&gt;

&lt;h1&gt;Commit messages &amp;hellip;&lt;/h1&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;之后在其他开发人员的电脑上，取下这个远程仓库到本地
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git clone git.yourcompany.com:project.git
&lt;/pre&gt;
在他的电脑上就可以看到之前John建立的readme文件了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>设置ssh无密钥登录</title>
      <link>http://blog.prosight.me/blogs/1097</link>
      <pubDate>2013-01-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在linux系统中,ssh是远程登录的默认工具,因为该工具的协议使用了RSA/DSA的加密算法.该工具做linux系统的远程管理是非常安全的。telnet,因为其不安全性,在linux系统中被搁置使用了。&lt;/p&gt;

&lt;p&gt;ssh有一套很有用的工具,其中的ssh-keygen可以用来生成private和public密钥.将生成的public密钥拷贝到远程机器后,可以使ssh到另外一台机器的登陆不用密码.具体方法如下.&lt;/p&gt;

&lt;p&gt;1) 在本地机器中的~/.ssh/目录下执行下命令:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ssh-keygen -t rsa -C &amp;ldquo;your@email.com&amp;rdquo;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;将生成两个文件,id_dsa和id_dsa.pub.&lt;/p&gt;

&lt;p&gt;2) 将id_dsa.pub拷贝到远程机器,并且将id_dsa.pub的内容添加到~/.ssh/authorized_keys中.
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cat id_dsa.pub &amp;gt;&amp;gt;authorized_keys
&lt;/pre&gt;
注意:目录.ssh和文件authorized_keys的权限必须是600.&lt;/p&gt;

&lt;p&gt;完成这些工作后,用户从本地机器到远程机器的登录就不用密码了.&lt;/p&gt;

&lt;p&gt;3) 关闭密码登录（可选）
如果不想再使用密码登录，可以在/etc/ssh/sshd_config中关闭
把文件中的#PasswordAuthentication yes 的#去掉，并将&amp;rdquo;yes&amp;rdquo;改成&amp;rdquo;no&amp;rdquo;
系统默认使用基于密码的验证方式，现改为基于密钥的验证方式，从而提高了系统的安全性&lt;/p&gt;

&lt;p&gt;UPDATE: 13-01-15
注意：如果是CentOS 6.3系统，默认会把用户的目录进行加密，所以放在/home/user下的文件都是加密的，如果直接使用这种方式登录，会提示一下错误：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Permission denied (publickey,gssapi-keyex,gssapi-with-mic).
&lt;/pre&gt;

&lt;p&gt;解决方法：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
restorecon -R ~/.ssh
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;另外，如果你在Centos中建立了非root用户，则这个用户的.ssh目录的权限应该是700，authorized_keys文件的权限应该是644，可以用chmod去编辑对应的权限。&lt;/p&gt;

&lt;p&gt;创建用户可以使用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
useradd username
groupadd devs
usermod -G devs username
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ubuntu server下使用Google Performance Tools优化MySQL性能</title>
      <link>http://blog.prosight.me/blogs/1090</link>
      <pubDate>2013-01-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;step 1. 因为是64位的系统，所以先要安装libunwind,32位系统可以忽略此步
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://download.savannah.gnu.org/releases/libunwind/libunwind-1.1.tar.gz&#34;&gt;http://download.savannah.gnu.org/releases/libunwind/libunwind-1.1.tar.gz&lt;/a&gt;
tar xvzf libunwind-1.1.tar.gz
cd libunwind-1.1/
CFLAGS=-fPIC ./configure &amp;ndash;enable-shared
make CFLAGS=-fPIC
sudo make CFLAGS=-fPIC install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;step 2.安装Google Performance Tools
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://gperftools.googlecode.com/files/gperftools-2.0.tar.gz&#34;&gt;http://gperftools.googlecode.com/files/gperftools-2.0.tar.gz&lt;/a&gt;
tar xvzf gperftools-2.0.tar.gz
cd gperftools-2.0/
./configure &amp;ndash;prefix=/usr/local/gperftools
#如果是centos，需要./configure &amp;ndash;enable-shared &amp;ndash;enable-frame-pointers，不能指定目录
make -j8
sudo make install
sudo -i
echo &amp;ldquo;/usr/local/gperftools/lib&amp;rdquo; &amp;gt; /etc/ld.so.conf.d/usr_local_gperftools_lib.conf
&amp;ndash; 对应Centos，echo &amp;ldquo;/usr/local/lib&amp;rdquo; &amp;gt; /etc/ld.so.conf.d/usr_local_lib.conf
/sbin/ldconfig
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;step 3. 安装MySQL
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
tar xvzf mysql-5.5.29.tar.gz
sudo groupadd mysql
sudo useradd -r -g mysql mysql
cd mysql-5.5.29/
cmake .
make
sudo make install
cd /usr/local/mysql
sudo chown -R mysql .
sudo chgrp -R mysql .
sudo scripts/mysql_install_db &amp;ndash;user=mysql
sudo chown -R root .
sudo chown -R mysql data
sudo cp support-files/my-medium.cnf /etc/my.cnf
sudo bin/mysqld_safe &amp;ndash;user=mysql &amp;amp;
sudo cp support-files/mysql.server /etc/init.d/mysql.server
&lt;/pre&gt;
以后就可以使用/etc/init.d/mysql.server start来启动MySQL&lt;/p&gt;

&lt;p&gt;step 4. 配置Google Performance Tools
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo vim /usr/local/mysql/bin/mysqld_safe
&lt;/pre&gt;
在# executing mysqld_safe的下一行，加上：
export LD_PRELOAD=/usr/local/gperftools/lib/libtcmalloc.so
重启MySQL后，输入下面命令来检测是否配置成功
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo lsof -n | grep tcmalloc
mysqld    13152 13171      mysql  mem       REG                8,7  2431969   29363754 /usr/local/gperftools/lib/libtcmalloc.so.4.1.0
&lt;/pre&gt;
如果看到上述的一行，就证明配置成功了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>golang.org无法访问的解决方案</title>
      <link>http://blog.prosight.me/blogs/1088</link>
      <pubDate>2012-12-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果你的golang.org无法访问，可以在你的host中添加这个
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
173.194.71.141  golang.org
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用gorun来用Go撰写脚本</title>
      <link>http://blog.prosight.me/blogs/1085</link>
      <pubDate>2012-12-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Go也可以用来写脚本，类似shell&lt;/p&gt;

&lt;p&gt;使用go get安装
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
go get launchpad.net/gorun
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如果提示
package launchpad.net/gorun: exec: &amp;ldquo;bzr&amp;rdquo;: executable file not found in $PATH
说明你缺少bazaar版本控制工具，launchpad都是用bazaar的。&lt;/p&gt;

&lt;p&gt;如果你是mac，需要执行下面的命令(需要事先安装brew）
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
brew install bazaar
&lt;/pre&gt;
如果是ubuntu，需要执行下面命令：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo apt-get install bzr
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Ubuntu Server清理无用内核</title>
      <link>http://blog.prosight.me/blogs/1073</link>
      <pubDate>2012-12-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;随着系统的升级，无用内核也慢慢累积得越来越多，所以要定时清理，下面是清理的过程。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
dpkg --get-selections|grep linux

libselinux1:amd64               install
linux-firmware                  install
linux-generic                   install
linux-headers-3.5.0-17              install
linux-headers-3.5.0-19-generic          install
linux-headers-3.5.0-17              install
linux-headers-3.5.0-19-generic          install
linux-headers-3.5.0-21              install
linux-headers-3.5.0-21-generic          install
linux-headers-generic               install
linux-image-3.5.0-17-generic            install
linux-image-3.5.0-19-generic            install
linux-image-3.5.0-21-generic            install
linux-image-extra-3.5.0-17-generic      install
linux-image-extra-3.5.0-19-generic      install
linux-image-extra-3.5.0-21-generic      install
linux-image-generic             install
linux-libc-dev:amd64                install
util-linux                  install
&lt;/pre&gt;

&lt;p&gt;需要分别清楚header和image，可以直接用apt-get remove来清除。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo apt-get remove linux-headers-3.5.0-17
sudo apt-get remove linux-headers-3.5.0-17-generic
sudo apt-get remove linux-headers-3.5.0-19
sudo apt-get remove linux-headers-3.5.0-19-generic
sudo apt-get remove linux-image-3.5.0-17-generic
sudo apt-get remove linux-image-3.5.0-19-generic
&lt;/pre&gt;

&lt;p&gt;之后再执行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
dpkg &amp;ndash;get-selections|grep linux&lt;/p&gt;

&lt;p&gt;libselinux1:amd64               install
linux-firmware                  install
linux-generic                   install
linux-headers-3.5.0-21              install
linux-headers-3.5.0-21-generic          install
linux-headers-generic               install
linux-image-3.5.0-17-generic            deinstall
linux-image-3.5.0-19-generic            deinstall
linux-image-3.5.0-21-generic            install
linux-image-extra-3.5.0-17-generic      deinstall
linux-image-extra-3.5.0-19-generic      deinstall
linux-image-extra-3.5.0-21-generic      install
linux-image-generic             install
linux-libc-dev:amd64                install
util-linux                  install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;清理完毕&lt;/p&gt;
</description>
    </item>
    <item>
      <title>用sublime搭建基于GoSublime+gocode的下载SublimeGO开发环境</title>
      <link>http://blog.prosight.me/blogs/1077</link>
      <pubDate>2012-12-25 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;下载&lt;a href=&#34;http://www.sublimetext.com/&#34; target=&#34;_blank&#34;&gt;Sublime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;打开之后安装 Package Control：Ctrl+ 打开命令行，执行如下代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
import urllib2,os; pf=&amp;lsquo;Package Control.sublime-package&amp;rsquo;; ipp=sublime.installed_packages_path(); os.makedirs(ipp) if not os.path.exists(ipp) else None; urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler())); open(os.path.join(ipp,pf),&amp;lsquo;wb&amp;rsquo;).write(urllib2.urlopen(&amp;lsquo;http://sublime.wbond.net/&amp;lsquo;+pf.replace(&amp;rsquo; &amp;lsquo;,&amp;rsquo;%20&amp;rsquo;)).read()); print &amp;lsquo;Please restart Sublime Text to finish installation&amp;rsquo;
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3.接下来安装gocode&lt;del datetime=&#34;2012-12-26T05:55:52+00:00&#34;&gt;和MarGo&lt;/del&gt;。 打开终端运行如下代码（需要git）
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
go get github.com/nsf/gocode
&lt;/pre&gt;
&lt;del datetime=&#34;2012-12-26T05:55:52+00:00&#34;&gt;go get github.com/DisposaBoy/MarGo&lt;/del&gt;&lt;/p&gt;

&lt;p&gt;MarGo已经是GoSublime的一部分了，所以不用装了。
gocode的作用是实现Go代码的自动补全。
&lt;img alt=&#34;&#34; src=&#34;https://a248.e.akamai.net/camo.github.com/3b2eb4c4dc72b975032f536a93260dfe7353c23f/687474703a2f2f6e6f736d696c65666163652e72752f696d616765732f676f636f64652d73637265656e73686f742e706e67&#34; title=&#34;gocode&#34; class=&#34;alignnone&#34; width=&#34;724&#34; height=&#34;341&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装完之后就可以安装Sublime的插件了。需安装GoSublime、SidebarEnhancements和Go Build，安装插件之后记得重启Sublime生效，Ctrl+Shift+p打开Package Controll 输入pcip（即“Package Control: Install Package”的缩写）。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>checklist for setting up the connections between two scenes</title>
      <link>http://blog.prosight.me/blogs/1071</link>
      <pubDate>2012-12-06 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
    &lt;li&gt;Create a segue from a button or other control on the source scene to the destination scene. (If you’re presenting the new screen modally, then often the destination will be a Navigation Controller.)&lt;/li&gt;
    &lt;li&gt;Give the segue a unique Identifier. (It only has to be unique in the source scene; different scenes can use the same identifier.)&lt;/li&gt;
    &lt;li&gt;Create a delegate protocol for the destination scene.&lt;/li&gt;
    &lt;li&gt;Call the delegate methods from the Cancel and Done buttons, and at any other point your destination scene needs to communicate with the source scene.&lt;/li&gt;
    &lt;li&gt;Make the source scene implement the delegate protocol. It should dismiss the destination view controller when Cancel or Done is pressed.&lt;/li&gt;
    &lt;li&gt;Implement prepareForSegue in the source view controller and do destination.delegate = self;.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>Erlang中启用Kernel Poll</title>
      <link>http://blog.prosight.me/blogs/1068</link>
      <pubDate>2012-12-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;默认情况下
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ erl
Erlang R15B03 (erts-5.9.3) [source] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:false]&lt;/p&gt;

&lt;p&gt;my erlang
Eshell V5.9.3  (abort with ^G)
1&amp;gt;
&lt;/pre&gt;
如果要启用Kernel Poll，需要加上+K true参数
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ erl +K true
Erlang R15B03 (erts-5.9.3) [source] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:true]&lt;/p&gt;

&lt;p&gt;my erlang
Eshell V5.9.3  (abort with ^G)
1&amp;gt;
&lt;/pre&gt;
启用Kernel Poll的好处在于当有很多连接时，可以极大的降低CPU的占用率。对内存和响应延迟没有作用。
&lt;table border=&#34;1&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Num users&lt;/td&gt;
&lt;td colspan=&#34;2&#34; align=&#34;center&#34;&gt;1500&lt;/td&gt;
&lt;td colspan=&#34;2&#34; align=&#34;center&#34;&gt;3000&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Kernel Poll&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;no&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;yes&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Latency (ms)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;16&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;28&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;28&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CPU (%)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;15&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;2&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;30&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Memory RES (MB)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;84&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;84&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;150&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;150&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Memory VIRT (MB)&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;94&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;94&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;160&lt;/td&gt;
&lt;td align=&#34;right&#34;&gt;160&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何在Erlang的List中移除element?</title>
      <link>http://blog.prosight.me/blogs/1062</link>
      <pubDate>2012-11-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Erlang的BIF似乎没有对应的函数，不过可以很方便的达到这一目的。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用“&amp;ndash;”操作符
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
1&amp;gt; List1 = [1,3,2].
[1,3,2]
2&amp;gt; List2 = [3,5].
[3,5]
3&amp;gt; List3 = List1 &amp;ndash; List2.
[1,2]
4&amp;gt; List4 = [1,3,2,3].
[1,3,2,3]
5&amp;gt; List4 &amp;ndash; List2.
[1,2,3]
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;自定义函数
删除List中的第N项
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
del&lt;em&gt;nth_from_list(List, N) -&amp;gt;
{L1, [&lt;/em&gt;|L2]} = lists:split(N-1, List),
L1 ++ L2.
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;从List删除所有指定的项
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
del_all_occurences(List, Elem) -&amp;gt;
  [E || E &amp;lt;- List, E =/= Elem].
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ChicagoBoss里直接在Controller里面使用中文</title>
      <link>http://blog.prosight.me/blogs/1056</link>
      <pubDate>2012-11-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果直接在controller里面使用中文，像下面这样：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-module(snooker_main_controller, [Req]).
-compile(export_all).&lt;/p&gt;

&lt;p&gt;index(&amp;lsquo;GET&amp;rsquo;, []) -&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ok, [{greeting, &amp;quot;中文测试！&amp;quot;}]}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;会报类似下面的错误
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
http process &lt;0.5215.0&gt; has died with reason: {badarg,
                                               [{erlang,list_to_binary,
                                                 [[&amp;lt;&amp;lt;&amp;rdquo;&amp;lt;!DOCTYPE html&amp;gt;\n&lt;html lang=\&#34;en\&#34;&gt;\n&lt;head&gt;\n&lt;meta http-equiv=\&#34;Content-Type\&#34; content=\&#34;text/html; charset=utf-8\&#34; /&gt;\n&lt;title&gt;&amp;rdquo;&amp;gt;&amp;gt;,
                                                   &amp;lt;&lt;230,150,175,232,175,186,
                                                     229,174,162,32,45,32,228,
                                                     184,128,232,181,183,230,
                                                     150,175,232,175,186,229,
                                                     174,162&gt;&amp;gt;,
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;原因在于erlang的源文件都是只支持latin字符集的，只要是*erl的文件，都是这样，所以出现unicode字符的话，都会类似的错误。所有的unicode字符都应该由变量传递或者进行encode&lt;/p&gt;

&lt;p&gt;解决方法：
修改controller源文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-module(snooker_main_controller, [Req]).
-compile(export_all).&lt;/p&gt;

&lt;p&gt;index(&amp;lsquo;GET&amp;rsquo;, []) -&amp;gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{ok, [{greeting, unicode:characters_to_binary(&amp;quot;中文测试！&amp;quot;, utf8, utf8)}]}.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这样就可以了。&lt;/p&gt;

&lt;p&gt;unicode:characters_to_binary的用法：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
characters_to_binary(Data, InEncoding, OutEncoding) -&amp;gt; Result&lt;/p&gt;

&lt;p&gt;Types:&lt;/p&gt;

&lt;p&gt;Data = latin1_chardata() | chardata() | external_chardata()
InEncoding = OutEncoding = encoding()
Result = binary()
       | {error, binary(), RestData}
       | {incomplete, binary(), binary()}
RestData = latin1_chardata() | chardata() | external_chardata()
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在Ubuntu Oneiric下从源代码安装 Erlang R15B</title>
      <link>http://blog.prosight.me/blogs/1054</link>
      <pubDate>2012-11-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;下载解压Erlang源码:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://www.erlang.org/download/otp_src_R15B.tar.gz&#34;&gt;http://www.erlang.org/download/otp_src_R15B.tar.gz&lt;/a&gt;
tar xfvz otp_src_R15B.tar.gz
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;安装编译工具
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo apt-get install build-essential git-core libwxgtk2.8-dev libgl1-mesa-dev libglu1-mesa-dev libpng3 wx-common default-jre default-jdk fop
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;安装erlang需要的依赖包
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo apt-get build-dep erlang
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;编译和安装erlang
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
./configure
make
make docs
sudo make install
sudo make install-docs
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Erlang没有循环，怎么打三角形</title>
      <link>http://blog.prosight.me/blogs/1044</link>
      <pubDate>2012-11-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;大家都习惯用for循环打三角形，而Erlang恰恰没有for循环，看看如何使用Erlang打印三角呢？&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
43&gt; [begin L=lists:duplicate(2*X-1,&#34;*&#34;),S=lists:duplicate(11-X,&#34; &#34;),io:format(S++L++&#34;~n&#34;) end|| X&lt;-lists:reverse(lists:seq(1,11))].
*********************
 *******************
  *****************
   ***************
    *************
     ***********
      *********
       *******
        *****
         ***
          *
[ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok]
44&gt; [begin L=lists:duplicate(2*X-1,&#34;*&#34;),S=lists:duplicate(11-X,&#34; &#34;),io:format(S++L++&#34;~n&#34;) end|| X&lt;-lists:seq(1,11)].
          *
         ***
        *****
       *******
      *********
     ***********
    *************
   ***************
  *****************
 *******************
*********************
[ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok]
&lt;/pre&gt;

&lt;p&gt;是不是更简单呢？&lt;/p&gt;

&lt;p&gt;如果是简单的计数循环，更简单，例如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
52&amp;gt; [io:format(&amp;ldquo;abc&amp;rdquo;) || _&amp;lt;-lists:seq(1,10)].
abcabcabcabcabcabcabcabcabcabc[ok,ok,ok,ok,ok,ok,ok,ok,ok,ok]
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Erlang &amp; Unicode</title>
      <link>http://blog.prosight.me/blogs/1050</link>
      <pubDate>2012-11-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Erlang的string实际上就是整数项组成的list,注意string的编解码使用是使用ISO-latin-1字符集,即:每8字节当成一个整体进行解读;这个字符集是Unicode的子集.Erlang list编解码很容易扩展到整个unicode编码:由于编码是整数和字符的对应关系,只要list中的整函数是有效的Unicode codepoint就可以找到对应的字符;&lt;/p&gt;

&lt;p&gt;二进制数据处理起来就麻烦一些了,二进制数据是紧凑排列的:一个字节代表一个字符,而不是两个字(word)一个字符,这里如果存在疑问可以查看erlang官方文档中关于内存消耗的列表:http://www.erlang.org/doc/efficiency_guide/advanced.html .平时我们使用的erlang:list_to_binary,常规的Erlang string(ISO-latin编码的string)可以逐字节逐字符顺利转成binary.但是超出ISO-latin编码范围就会出错了,看下面的例子:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
1&amp;gt; L=[10,12,23,45].
[10,12,23,45]
2&amp;gt; list_to_binary(L).
&amp;lt;&lt;10,12,23,45&gt;&amp;gt;
3&amp;gt; L2= &amp;ldquo;中国&amp;rdquo;.&lt;br /&gt;
[20013,22269]
4&amp;gt; list_to_binary(L2).
** exception error: bad argument
     in function  list_to_binary/1
        called as list_to_binary([20013,22269])
5&amp;gt; unicode:characters_to_list(L2).
[20013,22269]
6&amp;gt; unicode:characters_to_binary(L2). %%注意&amp;rdquo;中国&amp;rdquo;用二进制占用了6个字节
&amp;lt;&lt;228,184,173,229,155,189&gt;&amp;gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;UTF-8是Erlang二进制处理的标准编码形式,一旦出现需要处理Unicode二进制数据的场景,默认就会选择UTF8编码.比特语法支持使用其它的编解码方式,但是erlang类库中处理二进制都是使用UTF-8编码.字符串可以接受Unicode字符,但是Erlang的语言元素编写还是限制在ISO-latin-1的范围内.Erlang编译过程依然是使用ISO-latin-1编码,这样的影响是什么呢?代码中出现的Unicode字符会有部分无法在ISO-latin-1找到对应的字符,那怎么办呢?没关系,找不到对应的字符就按照整形数去处理就好了.&lt;/p&gt;

&lt;p&gt;Erlang Shell对unicode的支持要强一些,但是也并不完善,下面我们通过一系列实验来看上面的问题,在test模块里面我们准备两条测试数据:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
data()-&amp;gt;
   &amp;ldquo;hello 中国 ren&amp;rdquo;.
data2()-&amp;gt;
   &amp;lt;&amp;lt;&amp;ldquo;hello 中国 ren&amp;rdquo;&amp;gt;&amp;gt;.
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;启动Erlang Shell,我们对比一下数据之间的差异:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
1&amp;gt; &amp;ldquo;hello 中国 ren&amp;rdquo;.  %%在shell中输入包含中文的string,可以看到它就是一个List,注意中文字符对应的数值
[104,101,108,108,111,32,20013,22269,32,114,101,110]
2&amp;gt; test:data().        %%注意下面的数据,中文部分数值已经被切割成两组数据
[104,101,108,108,111,32,228,184,173,229,155,189,32,114,101,
110]&lt;br /&gt;
3&amp;gt; &amp;lt;&amp;lt;&amp;ldquo;hello 中国 ren&amp;rdquo;&amp;gt;&amp;gt;.  %%而这样的数据在shell中直接出错了 (注意:windows下可能是正常的)
** exception error: bad argument
4&amp;gt; test:data2().   %%看看这里二进制的输出,数值上是和v(2)的数值上是一致的
&amp;lt;&lt;104,101,108,108,111,32,228,184,173,229,155,189,32,114,
  101,110&gt;&amp;gt;
5&amp;gt; unicode:characters_to_binary(v(1)).  %%把v(1)的结果转成二进制,为什么不用list_to_binary?往下看
&amp;lt;&lt;104,101,108,108,111,32,228,184,173,229,155,189,32,114,
  101,110&gt;&amp;gt;
6&amp;gt; io:format(&amp;rdquo;~ts~n&amp;rdquo;,[v(1)]). %%注意这里格式化的时候使用的修饰符是~ts
hello 中国 ren
ok
7&amp;gt; io:format(&amp;rdquo;~ts~n&amp;rdquo;,[v(2)]).  %%v(2)输出的内容并不是我们期望的&lt;br /&gt;
hello ä¸­å½ ren
ok
8&amp;gt; io:getopts().  %%是不是觉得少检查了点什么?是的 看看环境编码
[{expand_fun,#Fun&lt;group.0.33302583&gt;},
{echo,true},
{binary,false},
{encoding,unicode}]
9&amp;gt; list_to_binary(v(1)). %%看到了吧,这样会异常的
** exception error: bad argument
     in function  list_to_binary/1
        called as list_to_binary([104,101,108,108,111,32,20013,22269,32,114,101,110])
10&amp;gt; list_to_binary(v(2)).
&amp;lt;&lt;104,101,108,108,111,32,228,184,173,229,155,189,32,114,
  101,110&gt;&amp;gt;
14&amp;gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;进行到这里,下面这个问题就有答案了,我们在Shell中执行下面的语句:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
14&amp;gt;  re:run(&amp;ldquo;hello 中国 ren&amp;rdquo;, &amp;ldquo;[\x{4e00}-\x{9fff}]+&amp;ldquo;, [unicode]).
{match,[{6,6}]}
15&amp;gt;
然后我们把这条语句放在模块代码中执行:
re() -&amp;gt;
   re:run(&amp;ldquo;hello 中国 ren&amp;rdquo;, &amp;ldquo;[\x{4e00}-\x{9fff}]+&amp;ldquo;, [unicode]).
执行结果:
15&amp;gt; test:re().
nomatch
16&amp;gt;
&lt;/pre&gt;
答案就是:在模块文件进行编译的时候使用的是ISO-latin-1,其中的中文并不在其字符集中,所以转成了两组数字!被转成两组数字之后,也就无法被正则表达式命中了.而在Erlang Shell中,中文字符可以被正确编码,所以会被正则命中.而仔细关注一下正则表达式,其实就是大致上覆盖了中文字符在unicode字符集中对应的数值区间.&lt;/p&gt;

&lt;p&gt;对于这种情况只要让unicode避开编译阶段就可以了,比如把这类文本放在外部文本中,下面立涛给的这份代码样例中演示了从外部文件读取文本内容,并匹配中文. &lt;a href=&#34;https://gist.github.com/2768621&#34;&gt;https://gist.github.com/2768621&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;一个细节&amp;rdquo;~ts&amp;rdquo; 修饰符
The Erlang compiler will interpret the code as ISO-8859-1 encoded text, which limits you to Latin characters.&amp;ldquo;translation modifier&amp;rdquo; when working with Unicode texts. The modifier is &amp;ldquo;t&amp;rdquo;. When applied to the &amp;ldquo;s&amp;rdquo; control character in a formatting string, it accepts all Unicode codepoints and expect binaries to be in UTF-8.
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
1&amp;gt; io:format(&amp;rdquo;~ts&amp;rdquo;,[unicode:characters_to_binary([20013])]).
中ok
2&amp;gt; io:format(&amp;rdquo;~ts&amp;rdquo;,[unicode:characters_to_binary([20013,22269])]).
中国ok
3&amp;gt;  L=[229,136,157,231,186,167], io:format(&amp;rdquo;~ts&amp;rdquo;, [list_to_binary(L)]).&lt;br /&gt;
初级ok
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Ubuntu 12.10 中自定义DNS服务器设置 </title>
      <link>http://blog.prosight.me/blogs/1042</link>
      <pubDate>2012-11-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;大家都知道，要修改Linux系统的DNS服务器，只需要编辑/etc/resolv.conf文件即可。然而在Ubuntu Server 12.10里面，打开这个文件后，虽然可以看到配置信息，但是同时也看到了文件头里醒目的两行注释：&lt;/p&gt;

&lt;p&gt;#Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)&lt;/p&gt;

&lt;h1&gt;DO NOT EDIT THIS FILE BY HAND &amp;ndash; YOUR CHANGES WILL BE OVERWRITTEN&lt;/h1&gt;

&lt;p&gt;大意是这个文件是由resolvconf程序进行动态生成的，请不要手动修改，修改的信息将会被覆盖。这究竟是怎么回事呢？&lt;/p&gt;

&lt;p&gt;首先当然是不死心了，往里面添加了自己的DNS服务器地址后保存退出，发现能生效。看上去似乎没有什么问题了。&lt;/p&gt;

&lt;p&gt;然而，在重启后，我添加的信息果然没有了！被系统自动覆盖了。&lt;/p&gt;

&lt;p&gt;网上搜索了一下，发现了解决办法，原来只需要往resolvconf这个程序的目录里写入一个新配置文件就可以解决。让我们一起看看怎么样在Ubuntu 12.04 LTS Server版中配置自己的DNS服务器吧！&lt;/p&gt;

&lt;p&gt;首先我们需要创建一个文件/etc/resolvconf/resolv.conf.d/tail：&lt;/p&gt;

&lt;p&gt;#vim /etc/resolvconf/resolv.conf.d/tail
然后我们在这个文件里写入自己要添加的DNS服务器，格式与以前的/etc/resolv.conf文件一致：&lt;/p&gt;

&lt;p&gt;nameserver 8.8.8.8
nameserver 8.8.4.4
然后输入wq保存退出。接下来我们重启下resolvconf程序，让配置生效：&lt;/p&gt;

&lt;p&gt;#/etc/init.d/resolvconf restart
再去看看/etc/resolv.conf文件，自己添加的DNS服务器果然乖乖的写进去了！至此问题完美解决！&lt;/p&gt;

&lt;p&gt;资料参考：http://askubuntu.com/questions/130452/how-do-i-add-a-dns-server-via-resolv-conf-ubuntu-12-04&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用Erlang和Thrift，与Hbase通信</title>
      <link>http://blog.prosight.me/blogs/1025</link>
      <pubDate>2012-11-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;操作系统是Ubuntu Server 12.10&lt;/p&gt;

&lt;h3&gt;先安装Thrift&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo apt-get install libboost-dev libboost-test-dev \
 libboost-program-options-dev libevent-dev automake \
 libtool flex bison pkg-config g++ libssl-dev
&lt;/pre&gt;
如果你还要使用别的语言，也需要安装对应的包
&lt;ul&gt;
    &lt;li&gt;Ruby
&lt;ul&gt;
    &lt;li&gt;ruby-full ruby-dev librspec-ruby rake rubygems libdaemons-ruby libgemplugin-ruby mongrel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;Python
&lt;ul&gt;
    &lt;li&gt;python-dev python-twisted&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;Perl
&lt;ul&gt;
    &lt;li&gt;libbit-vector-perl&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;Php, install
&lt;ul&gt;
    &lt;li&gt;php5-dev php5-cli&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;C_glib
&lt;ul&gt;
    &lt;li&gt;libglib2.0-dev&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;Erlang
&lt;ul&gt;
    &lt;li&gt;erlang-base erlang-eunit erlang-dev&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;Csharp
&lt;ul&gt;
    &lt;li&gt;mono-gmcs libmono-dev libmono-system-web2.0-cil&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
    &lt;li&gt;Haskell
&lt;ul&gt;
    &lt;li&gt;ghc6 cabal-install libghc6-binary-dev libghc6-network-dev libghc6-http-dev&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd thrift
./bootstrap.sh 
./configure --with-boost=/usr/local 
make 
make install
&lt;/pre&gt;

&lt;h3&gt;安装Hbase&lt;/h3&gt;

&lt;p&gt;修改源码包中的conf/hbase-site.xml文件。替换成以下内容：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;?xml-stylesheet type=&#34;text/xsl&#34; href=&#34;configuration.xsl&#34;?&gt;
&lt;configuration&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.rootdir&lt;/name&gt;
    &lt;value&gt;file:///DIRECTORY/hbase&lt;/value&gt;
  &lt;/property&gt;
  &lt;property&gt;
    &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt;
    &lt;value&gt;/DIRECTORY/zookeeper&lt;/value&gt;
  &lt;/property&gt;
&lt;/configuration&gt;
&lt;/pre&gt;
替换上文中对应的目录位置

修改conf/hbase-env.sh
添加JAVA_HOME
export JAVA_HOME=/usr/local/jdk

启动Hbase
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ ./bin/start-hbase.sh
starting Master, logging to logs/hbase-user-master-example.org.out

$ ./bin/hbase shell
HBase Shell; enter &#39;help&lt;RETURN&gt;&#39; for list of supported commands.
Type &#34;exit&lt;RETURN&gt;&#34; to leave the HBase Shell
Version 0.94.2, r1395367, Sun Oct  7 19:11:01 UTC 2012

hbase(main):001:0&gt;

hbase(main):001:0&gt; create &#39;t1&#39;,&#39;cf&#39;
0 row(s) in 1.6600 seconds

hbase(main):002:0&gt; list
TABLE                                                                                               
t1                                                                                                  
1 row(s) in 0.0130 seconds
hbase(main):004:0&gt; put &#39;t1&#39;, &#39;row1&#39;, &#39;cf:a&#39;, &#39;value1&#39;
0 row(s) in 0.0330 seconds

hbase(main):005:0&gt; put &#39;t1&#39;, &#39;row2&#39;, &#39;cf:a&#39;, &#39;value2&#39;
0 row(s) in 0.0040 seconds

hbase(main):006:0&gt; put &#39;t1&#39;, &#39;row3&#39;, &#39;cf:a&#39;, &#39;value3&#39;
0 row(s) in 0.0040 seconds

hbase(main):007:0&gt; scan &#39;t1&#39;
ROW                        COLUMN+CELL                                                              
 row1                      column=cf:a, timestamp=1352453214504, value=value1                       
 row2                      column=cf:a, timestamp=1352453236805, value=value2                       
 row3                      column=cf:a, timestamp=1352453244172, value=value3                       
3 row(s) in 0.0320 seconds

hbase(main):008:0&gt; get &#39;t1&#39;, &#39;row1&#39;
COLUMN                     CELL                                                                     
 cf:a                      timestamp=1352453214504, value=value1                                    
1 row(s) in 0.0120 seconds

hbase(main):009:0&gt; disable &#39;t1&#39;
0 row(s) in 2.0510 seconds

hbase(main):011:0&gt; drop &#39;t1&#39;
0 row(s) in 1.0480 seconds

hbase(main):012:0&gt; exit
&lt;/pre&gt;

&lt;p&gt;如果上述测试脚本都能正常执行，就证明你Hbase安装成功了。
注意，如果你使用ubuntu，当执行命令的时候，提示
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ERROR: org.apache.hadoop.hbase.PleaseHoldException: org.apache.hadoop.hbase.PleaseHoldException: Master is initializing
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在logs/hbase-*-ubuntu.log中显示类似
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Failed setting up proxy interface org.apache.hadoop.hbase.ipc.HRegionInterface to localhost/127.0.0.1:55915 after attempts=1
Caused by: java.net.ConnectException: Connection refused
&lt;/pre&gt;
出现这种情形，请检查/etc/hosts文件，把
127.0.1.1   ubuntu
改成
127.0.0.1   ubuntu
之后重新启动Hbase就可以正常运行了。&lt;/p&gt;

&lt;h3&gt;通过Thrift操作Hbase&lt;/h3&gt;

&lt;p&gt;生产Thrift客户端
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
mkdir ~/thrift
cd ~/thrift
thrift &amp;ndash;gen erl [hbase-root]/src/main/resources/org/apache/hadoop/hbase/thrift/Hbase.thrift
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;启动两个客户端
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cd ~/hbase
$ ./bin/start-hbase.sh
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在另外一个客户端,启动Thrift Server
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cd ~/hbase
elton@ubuntu:~/hbase$ ./bin/hbase thrift start
&lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;/09 17:41:33 INFO util.VersionInfo: HBase 0.94.2
&amp;hellip;
&lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;/09 17:41:35 DEBUG thrift.ThriftServerRunner: Using binary protocol
&lt;sup&gt;12&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;/09 17:41:35 INFO thrift.ThriftServerRunner: starting TBoundedThreadPoolServer on /0.0.0.0:9090; min worker threads=16, max worker threads=1000, max queued requests=1000
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;之后就可以产生一个gen-erl，进入它，编译其中的Erlang源文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd gen-erl
erlc *.erl
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在gen-erl目录下，进入erlang shell。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ erl
Erlang R15B02 (erts-5.9.2) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]&lt;/p&gt;

&lt;p&gt;Eshell V5.9.2  (abort with ^G)
1&amp;gt; {ok, Client} = thrift_client_util:new(&amp;ldquo;127.0.0.1&amp;rdquo;, 9090, hbase_thrift, []).
{ok,{tclient,hbase_thrift,
        {protocol,thrift_binary_protocol,
            {binary_protocol,
                {transport,thrift_buffered_transport,
                    {buffered_transport,
                        {transport,thrift_socket_transport,
                            {data,#Port&lt;0.631&gt;,infinity}},
                        []}},
                true,true}},
        0}}&lt;/p&gt;

&lt;p&gt;2&amp;gt; thrift_client:call(Client, getTableNames, []).
tclient,hbase_thrift,
     {protocol,thrift_binary_protocol,
         {binary_protocol,
             {transport,thrift_buffered_transport,
                 {buffered_transport,
                     {transport,thrift_socket_transport,
                         {data,#Port&lt;0.631&gt;,infinity}},
                     []}},
             true,true}},
     0},
 {ok,[]}}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;具体的clinet API可以参见 &lt;a href=&#34;https://github.com/interline/erlang-thrift&#34; target=&#34;_blank&#34;&gt;https://github.com/interline/erlang-thrift&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>erlang多node通信失败</title>
      <link>http://blog.prosight.me/blogs/1018</link>
      <pubDate>2012-11-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在测试在本机部署多个node，实现多个node间的rpc调用和通信。&lt;/p&gt;

&lt;p&gt;假设服务器端的程序如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-module (kvs).
-export ([start/0,store/2,lookup/1]).&lt;/p&gt;

&lt;p&gt;start() -&amp;gt; register(kvs, spawn(fun() -&amp;gt; loop() end)).&lt;/p&gt;

&lt;p&gt;store(Key, Value) -&amp;gt; rpc({store, Key, Value}).&lt;/p&gt;

&lt;p&gt;lookup(Key) -&amp;gt; rpc({lookup, Key}).&lt;/p&gt;

&lt;p&gt;rpc(Q) -&amp;gt;
    kvs ! {self(), Q},
    receive
        {kvs, Reply} -&amp;gt;
            Reply
    end.&lt;/p&gt;

&lt;p&gt;loop() -&amp;gt;
    receive
        {From, {store, Key, Value}} -&amp;gt;
            put(Key, {ok, Value}),
            From ! {kvs, true},
            loop();
        {From, {lookup, Key}} -&amp;gt;
            From ! {kvs, get(Key)},
            loop()
    end.
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在终端中执行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ erl -sname gandalf
Erlang R15B02 (erts-5.9.2) [source] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:false]&lt;/p&gt;

&lt;p&gt;Eshell V5.9.2  (abort with ^G)
(gandalf@EltonMacBookPro)1&amp;gt; kvs:start().
true
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;启动另外一个终端，执行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ erl -sname bilbo
Erlang R15B02 (erts-5.9.2) [source] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:false]&lt;/p&gt;

&lt;p&gt;Eshell V5.9.2  (abort with ^G)
(bilbo@EltonMacBookPro)1&amp;gt; rpc:call(gandalf@EltonMacBookPro, kvs, store, [weather, fine]).
{badrpc,nodedown}
&lt;/pre&gt;
显示{badrpc,nodedown}。&lt;/p&gt;

&lt;p&gt;测试
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
(bilbo@EltonMacBookPro)3&amp;gt; net_adm:ping(gandalf@EltonMacBookPro).
pang
&lt;/pre&gt;
显示pang，表示不通，通的话应该是pong&lt;/p&gt;

&lt;p&gt;直接在shell中ping主机名，发现
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ ping EltonMacBookPro
PING eltonmacbookpro.home (180.168.41.175): 56 data bytes
64 bytes from 180.168.41.175: icmp_seq=0 ttl=248 time=14.337 ms
64 bytes from 180.168.41.175: icmp_seq=1 ttl=248 time=16.196 ms
64 bytes from 180.168.41.175: icmp_seq=2 ttl=248 time=12.764 ms
&lt;/pre&gt;
不是本地地址，是公网地址。 所以在/etc/hosts中指定一下主机名对应的ip 127.0.0.1。&lt;/p&gt;

&lt;p&gt;之后就一切正常了
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
(bilbo@EltonMacBookPro)5&amp;gt; rpc:call(gandalf@EltonMacBookPro,kvs,store,[weather, fine]).
true
(bilbo@EltonMacBookPro)6&amp;gt; rpc:call(gandalf@EltonMacBookPro,kvs,lookup,[weather]).&lt;br /&gt;
{ok,fine}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如果在本地局域网多台机器上部署对应node，则需要将局域网的机器名在hosts中都设置对应的ip地址。
比如A机器机器名是ubuntu，部署服务端。现在要用B（机器名EltonMacBookPro）来远超调用A的函数。
可以在B中的/etc/hosts设置A的机器名的ip地址。如
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
192.168.1.39 ubuntu
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在A中运行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ erl -sname gandalf -setcookie abc
Erlang R15B02 (erts-5.9.2) [source] [64-bit] [smp:4:4] [async-threads:0] [hipe] [kernel-poll:false]&lt;/p&gt;

&lt;p&gt;Eshell V5.9.2  (abort with ^G)
(gandalf@ubuntu)1&amp;gt; kvs:start().
true
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在B中运行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ erl -sname bilbo -setcookie abc
Erlang R15B02 (erts-5.9.2) [source] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:false]&lt;/p&gt;

&lt;p&gt;Eshell V5.9.2  (abort with ^G)
(bilbo@EltonMacBookPro)1&amp;gt; rpc:call(gandalf@ubuntu,kvs,store,[weather,cold]).&lt;br /&gt;
true
(bilbo@EltonMacBookPro)2&amp;gt; rpc:call(gandalf@ubuntu,kvs,lookup,[weather]).&lt;br /&gt;
{ok,cold}
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Erlang解决中文问题</title>
      <link>http://blog.prosight.me/blogs/1011</link>
      <pubDate>2012-11-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1、外部文件使用utf8保存
2、erlang代码使用utf8保存
3、使用xmerl_ucs:from_utf8(Data)转换成unicode编码
4、使用io:format(&amp;rdquo;~ts~n&amp;rdquo;, [Data])在shell中打印&lt;/p&gt;

&lt;p&gt;t表示Unicode，s表示显示字符串，如果没有t，字符的编码超过255的话，就会直接报错。Unicode的编码都超过255的。&lt;/p&gt;

&lt;p&gt;这样既能在erlang中知道有中文的字数，又能打印显示中文，一举两得&lt;/p&gt;

&lt;p&gt;注：
utf8编码是变长字节码，所以中文编码之后字数就不一样了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>脚本自动化安装 erlang</title>
      <link>http://blog.prosight.me/blogs/1015</link>
      <pubDate>2012-11-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;操作系统是Ubuntu，脚本如下：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#!/bin/bash -e
echo -e &#34;please waiting...\n&#34;

sudo apt-get install -y build-essential    
sudo apt-get install -y libncurses5-dev     
sudo apt-get install -y libssl-dev  
sudo apt-get install -y m4   
sudo apt-get install -y unixodbc unixodbc-dev  
sudo apt-get install -y freeglut3-dev libwxgtk2.8-dev    
sudo apt-get install -y xsltproc
sudo apt-get install -y tk8.5   

cd ~/Source/otp_src_R15B01/
sudo ./configure
sudo make &amp;&amp; sudo make install
&lt;/pre&gt;

&lt;p&gt;假设Erlang下载到~/Source目录下。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>TCP/IP 相关总结</title>
      <link>http://blog.prosight.me/blogs/1008</link>
      <pubDate>2012-10-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;div id=&#34;sina_keyword_ad_area2&#34;&gt;&lt;/p&gt;

&lt;h1&gt;1.   三次握手协议&lt;/h1&gt;

&lt;p&gt;在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。&lt;/p&gt;

&lt;p&gt;第一次握手：建立连接时，客户端发送&lt;strong&gt;syn&lt;/strong&gt;包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；&lt;/p&gt;

&lt;p&gt;第二次握手：服务器收到syn包，必须确认客户的&lt;strong&gt;SYN&lt;/strong&gt;（ack=j+1），同时自己也发送一个SYN包（syn=k），即&lt;strong&gt;SYN+ACK&lt;/strong&gt;包，此时服务器进入SYN_RECV状态；&lt;/p&gt;

&lt;p&gt;第三次握手：客户端收到服务器的SYN＋ACK包，向服务器发送确认包&lt;strong&gt;ACK&lt;/strong&gt;(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;h1&gt;&lt;a name=&#34;t1&#34;&gt;&lt;/a&gt;2.   TCP/IP 四层&lt;/h1&gt;
应用层：HTTP，FTP，DNS，TELNET&lt;/p&gt;

&lt;p&gt;传输层：TCP，UDP&lt;/p&gt;

&lt;p&gt;网络互连层：IP&lt;/p&gt;

&lt;p&gt;网络接口层：以太网，wifi等&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;OSI 的七层模型
&lt;table cellspacing=&#34;1&#34; cellpadding=&#34;5&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;应用层&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;a title=&#34;HTTP&#34; href=&#34;http://zh.wikipedia.org/wiki/HTTP&#34;&gt;HTTP&lt;/a&gt;、&lt;a title=&#34;SMTP&#34; href=&#34;http://zh.wikipedia.org/wiki/SMTP&#34;&gt;SMTP&lt;/a&gt;、&lt;a title=&#34;SNMP&#34; href=&#34;http://zh.wikipedia.org/wiki/SNMP&#34;&gt;SNMP&lt;/a&gt;、&lt;a title=&#34;FTP&#34; href=&#34;http://zh.wikipedia.org/wiki/FTP&#34;&gt;FTP&lt;/a&gt;、&lt;a title=&#34;Telnet&#34; href=&#34;http://zh.wikipedia.org/wiki/Telnet&#34;&gt;Telnet&lt;/a&gt;、&lt;a title=&#34;SIP&#34; href=&#34;http://zh.wikipedia.org/wiki/SIP&#34;&gt;SIP&lt;/a&gt;、&lt;a title=&#34;SSH&#34; href=&#34;http://zh.wikipedia.org/wiki/SSH&#34;&gt;SSH&lt;/a&gt;、&lt;a title=&#34;NFS&#34; href=&#34;http://zh.wikipedia.org/wiki/NFS&#34;&gt;NFS&lt;/a&gt;、&lt;a title=&#34;RTSP&#34; href=&#34;http://zh.wikipedia.org/wiki/RTSP&#34;&gt;RTSP&lt;/a&gt;、&lt;a title=&#34;XMPP&#34; href=&#34;http://zh.wikipedia.org/wiki/XMPP&#34;&gt;XMPP&lt;/a&gt;、&lt;a title=&#34;Whois&#34; href=&#34;http://zh.wikipedia.org/wiki/Whois&#34;&gt;Whois&lt;/a&gt;、&lt;a title=&#34;ENRP（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=ENRP&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;ENRP&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;表示层&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;a title=&#34;External Data Representation（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=External_Data_Representation&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;XDR&lt;/a&gt;、&lt;a title=&#34;Abstract Syntax Notation 1（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=Abstract_Syntax_Notation_1&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;ASN.1&lt;/a&gt;、&lt;a title=&#34;Server message block（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=Server_message_block&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;SMB&lt;/a&gt;、&lt;a title=&#34;Apple Filing Protocol（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=Apple_Filing_Protocol&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;AFP&lt;/a&gt;、&lt;a title=&#34;NetWare Core Protocol（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=NetWare_Core_Protocol&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;NCP&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;会话层&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;a title=&#34;Aggregate Server Access Protocol（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=Aggregate_Server_Access_Protocol&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;ASAP&lt;/a&gt;、&lt;a title=&#34;Transport Layer Security&#34; href=&#34;http://zh.wikipedia.org/wiki/Transport_Layer_Security&#34;&gt;TLS&lt;/a&gt;、&lt;a title=&#34;SSH&#34; href=&#34;http://zh.wikipedia.org/wiki/SSH&#34;&gt;SSH&lt;/a&gt;、ISO 8327 / CCITT X.225、&lt;a title=&#34;Remote procedure call（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=Remote_procedure_call&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;RPC&lt;/a&gt;、&lt;a title=&#34;NetBIOS（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=NetBIOS&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;NetBIOS&lt;/a&gt;、&lt;a title=&#34;AppleTalk（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=AppleTalk&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;ASP&lt;/a&gt;、&lt;a title=&#34;Winsock（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=Winsock&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;Winsock&lt;/a&gt;、&lt;a title=&#34;Berkeley sockets&#34; href=&#34;http://zh.wikipedia.org/wiki/Berkeley_sockets&#34;&gt;BSD sockets&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;传输层&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;a title=&#34;TCP&#34; href=&#34;http://zh.wikipedia.org/wiki/TCP&#34;&gt;TCP&lt;/a&gt;、&lt;a title=&#34;User Datagram Protocol&#34; href=&#34;http://zh.wikipedia.org/wiki/User_Datagram_Protocol&#34;&gt;UDP&lt;/a&gt;、&lt;a title=&#34;实时传输协议&#34; href=&#34;http://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&#34;&gt;RTP&lt;/a&gt;、&lt;a title=&#34;流控制传输协议&#34; href=&#34;http://zh.wikipedia.org/wiki/%E6%B5%81%E6%8E%A7%E5%88%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE&#34;&gt;SCTP&lt;/a&gt;、&lt;a title=&#34;Sequenced packet exchange（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=Sequenced_packet_exchange&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;SPX&lt;/a&gt;、&lt;a title=&#34;AppleTalk（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=AppleTalk&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;ATP&lt;/a&gt;、&lt;a title=&#34;IL Protocol（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=IL_Protocol&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;IL&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;网络层&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;a title=&#34;网际协议&#34; href=&#34;http://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE&#34;&gt;IP&lt;/a&gt;、&lt;a title=&#34;ICMP&#34; href=&#34;http://zh.wikipedia.org/wiki/ICMP&#34;&gt;ICMP&lt;/a&gt;、&lt;a title=&#34;IGMP&#34; href=&#34;http://zh.wikipedia.org/wiki/IGMP&#34;&gt;IGMP&lt;/a&gt;、&lt;a title=&#34;IPX&#34; href=&#34;http://zh.wikipedia.org/wiki/IPX&#34;&gt;IPX&lt;/a&gt;、&lt;a title=&#34;BGP&#34; href=&#34;http://zh.wikipedia.org/wiki/BGP&#34;&gt;BGP&lt;/a&gt;、&lt;a title=&#34;OSPF&#34; href=&#34;http://zh.wikipedia.org/wiki/OSPF&#34;&gt;OSPF&lt;/a&gt;、&lt;a title=&#34;RIP&#34; href=&#34;http://zh.wikipedia.org/wiki/RIP&#34;&gt;RIP&lt;/a&gt;、&lt;a title=&#34;IGRP&#34; href=&#34;http://zh.wikipedia.org/wiki/IGRP&#34;&gt;IGRP&lt;/a&gt;、&lt;a title=&#34;EIGRP&#34; href=&#34;http://zh.wikipedia.org/wiki/EIGRP&#34;&gt;EIGRP&lt;/a&gt;、&lt;a title=&#34;ARP&#34; href=&#34;http://zh.wikipedia.org/wiki/ARP&#34;&gt;ARP&lt;/a&gt;、&lt;a title=&#34;RARP&#34; href=&#34;http://zh.wikipedia.org/wiki/RARP&#34;&gt;RARP&lt;/a&gt;、&lt;a title=&#34;X.25&#34; href=&#34;http://zh.wikipedia.org/wiki/X.25&#34;&gt;X.25&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;数据链路层&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;例如&lt;a title=&#34;以太网&#34; href=&#34;http://zh.wikipedia.org/wiki/%E4%BB%A5%E5%A4%AA%E7%BD%91&#34;&gt;以太网&lt;/a&gt;、&lt;a title=&#34;令牌环&#34; href=&#34;http://zh.wikipedia.org/wiki/%E4%BB%A4%E7%89%8C%E7%8E%AF&#34;&gt;令牌环&lt;/a&gt;、&lt;a title=&#34;HDLC&#34; href=&#34;http://zh.wikipedia.org/wiki/HDLC&#34;&gt;HDLC&lt;/a&gt;、&lt;a title=&#34;帧中继&#34; href=&#34;http://zh.wikipedia.org/wiki/%E5%B8%A7%E4%B8%AD%E7%BB%A7&#34;&gt;帧中继&lt;/a&gt;、&lt;a title=&#34;ISDN&#34; href=&#34;http://zh.wikipedia.org/wiki/ISDN&#34;&gt;ISDN&lt;/a&gt;、&lt;a title=&#34;异步传输模式&#34; href=&#34;http://zh.wikipedia.org/wiki/%E5%BC%82%E6%AD%A5%E4%BC%A0%E8%BE%93%E6%A8%A1%E5%BC%8F&#34;&gt;ATM&lt;/a&gt;、&lt;a title=&#34;IEEE 802.11&#34; href=&#34;http://zh.wikipedia.org/wiki/IEEE_802.11&#34;&gt;IEEE 802.11&lt;/a&gt;、&lt;a title=&#34;FDDI&#34; href=&#34;http://zh.wikipedia.org/wiki/FDDI&#34;&gt;FDDI&lt;/a&gt;、&lt;a title=&#34;PPP&#34; href=&#34;http://zh.wikipedia.org/wiki/PPP&#34;&gt;PPP&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;物理层&lt;/td&gt;
&lt;td&gt;例如&lt;a title=&#34;线路（页面不存在）&#34; href=&#34;http://zh.wikipedia.org/w/index.php?title=%E7%BA%BF%E8%B7%AF&amp;amp;action=edit&amp;amp;redlink=1&#34;&gt;线路&lt;/a&gt;、&lt;a title=&#34;无线电&#34; href=&#34;http://zh.wikipedia.org/wiki/%E6%97%A0%E7%BA%BF%E7%94%B5&#34;&gt;无线电&lt;/a&gt;、&lt;a title=&#34;光纤&#34; href=&#34;http://zh.wikipedia.org/wiki/%E5%85%89%E7%BA%A4&#34;&gt;光纤&lt;/a&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&amp;nbsp;
&lt;h1&gt;&lt;a name=&#34;t2&#34;&gt;&lt;/a&gt;3.  IP 地址分类&lt;/h1&gt;
IP地址是四段八位的二进制数组成的，IP分为A,B,C,D,E五类地址
&lt;strong&gt;A类&lt;/strong&gt;高端为0,从1.x.y.z&amp;ndash;126.x.y.z；**
**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B类&lt;/strong&gt;高端为10,从128.x.y.z&amp;ndash;191.x.y.z；**
**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C类&lt;/strong&gt;高端为110，从192.x.y.z&amp;ndash;223.x.y.z；**
**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;D类&lt;/strong&gt;高端为1110是保留的IP地址；**
**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;E类&lt;/strong&gt;高端为1111，是科研用的IP地址
其中255是广播地址，127是内部回送函数&lt;/p&gt;

&lt;p&gt;&amp;nbsp;
&lt;h1&gt;&lt;a name=&#34;t3&#34;&gt;&lt;/a&gt;4.  子网掩码等知识&lt;/h1&gt;
IP ADDRESS:你的物理IP地址;
SUBNET MASK:是&amp;rdquo;子网掩码&amp;rdquo;的意思
DEFAULT GATEWAY:默认网关;
什么是子网掩码
你一定对IP地址有所了解吧？我们知道在INTERNET中广泛使用的TCP/IP协议就是利用IP地址来区别不同的主机的。如果你曾经进行过TCP/IP协议设置，那么你一定会遇到子网掩码(Subnetmask)这一名词，那么你知道什么是子网掩码吗？它有什么作用呢？&lt;/p&gt;

&lt;p&gt;我们知道IP地址是一个4字节（共32bit）的数字，被分为4段，每段8位，段与段之间用句点分隔。为了便于表达和识别，IP地址是以十进制形式表示的如210.52.207.2，每段所能表示的十进制数最大不超过255。IP地址由两部分组成，即网络号（NetgworkID）和主机号（HostID）。网络号标识的是Internet上的一个子网，而主机号标识的是子网中的某台主机。网际地址分解成两个域后，带来了一个重要的优点：IP数据包从网际上的一个网络到达另一个网络时，选择路径可以基于网络而不是主机。在大型的网际中，这一点优势特别明显，因为路由表中只存储网络信息而不是主机信息，这样可以大大简化路由表。IP地址根据网络号和主机号的数量而分为A、B、C三类：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A类IP地址：用7位（bit）来标识网络号，24位标识主机号，最前面一位为&amp;rdquo;0&amp;rdquo;，即A类地址的第一段取值介于1～126之间&lt;/strong&gt;。A类地址通常为大型网络而提供，全世界总共只有126个只可能的A类网络，每个A类网络最多可以连接16777214台主机。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B类IP地址：用14位来标识网络号，16位标识主机号，前面两位是&amp;rdquo;10&amp;rdquo;。B类地址的第一段取值介于128～191之间，第一段和第二段合在一起表示网络号。&lt;/strong&gt;B类地址适用于中等规模的网络，全世界大约有16000个B类网络，每个B类网络最多可以连接65534台主机。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;C类IP地址：用21位来标识网络号，8位标识主机号，前面三位是&amp;rdquo;110&amp;rdquo;。C类地址的第一段取值介于192～223之间，第一段、第二段、第三段合在一起表示网络号。&lt;/strong&gt;最后一段标识网络上的主机号。C类地址适用于校园网等小型网络，每个C类网络最多可以有254台主机。&lt;/p&gt;

&lt;p&gt;从上面的介绍我们知道，IP地址是以网络号和主机号来标示网络上的主机的，只有在一个网络号下的计算机之间才能&amp;rdquo;直接&amp;rdquo;互通，不同网络号的计算机要通过网关（Gateway）才能互通。但这样的划分在某些情况下显得并十分不灵活。为此IP网络还允许划分成更小的网络，称为子网（Subnet），这样就产生了子网掩码。子网掩码的作用就是用来判断任意两个IP地址是否属于同一子网络，这时只有在同一子网的计算机才能&amp;rdquo;直接&amp;rdquo;互通。那么怎样确定子网掩码呢？&lt;/p&gt;

&lt;p&gt;前面讲到I&lt;strong&gt;P地址分网络号和主机号，要将一个网络划分为多个子网，因此网络号将要占用原来的主机位，如对于一个C类地址，它用21位来标识网络号，要将其划分为2个子网则需要占用1位原来的主机标识位。此时网络号位变为22位为主机标示变为7位&lt;/strong&gt;。&lt;strong&gt;同理借用2个主机位则可以将一个C类网络划分为4个子网&lt;/strong&gt;……那计算机是怎样才知道这一网络是否划分了子网呢？这就可以从子网掩码中看出。子网掩码和IP地址一样有32bit，&lt;strong&gt;确定子网掩码的方法是其与IP地址中标识网络号的所有对应位都用&amp;rdquo;1&amp;rdquo;，而与主机号对应的位都是&amp;rdquo;0&amp;rdquo;。&lt;/strong&gt;如分为2个子网的C类IP地址用22位来标识网络号，则其子网掩码为：1111111111111111 1111111110000000即255.255.255.128。于是我们可以知道，A类地址的缺省子网掩码为255.0.0.0,B类为255.255.0.0,C类为255.255.255.0。下表是C类地址子网划分及相关子网掩码：&lt;/p&gt;

&lt;p&gt;子网位数     子网掩码                                              主机数         可用主机数&lt;/p&gt;

&lt;p&gt;1              255.255.255.128                                    128                126&lt;/p&gt;

&lt;p&gt;2              255.255.255.192                                     64                   62&lt;/p&gt;

&lt;p&gt;3               255.255.255.224                                    32                   30&lt;/p&gt;

&lt;p&gt;4                255.255.255.240                                   16                    14&lt;/p&gt;

&lt;p&gt;5                255.255.255.248                                    8                      6&lt;/p&gt;

&lt;p&gt;6                 255.255.255.252                                   4                      2&lt;/p&gt;

&lt;p&gt;你可能注意到上表分&lt;strong&gt;了主机数和可用主机数两项&lt;/strong&gt;，这是为什么呢？&lt;strong&gt;因为但当地址的所有主机位都为&amp;rdquo;0&amp;rdquo;时，这一地址为线路（或子网）地址，而当所有主机位都为&amp;rdquo;1&amp;rdquo;时为广播地址&lt;/strong&gt;（255）。&lt;/p&gt;

&lt;p&gt;同时我们还可以使用可变长掩码（VLSM）就是指一个网络可以用不同的掩码进行配置。这样做的目的是为了使把一个网络划分成多个子网更加方便。在没有VLSM的情况下，一个网络只能使用一种子网掩码，这就限制了在给定的子网数目条件下主机的数目。例如你被分配了一个C类地址，网络号为192.168.10.0,而你现在需要将其划分为三个子网,其中一个子网有100台主机,其余的两个子网有50台主机。我们知道一个C类地址有254个可用地址，那么你如何选择子网掩码呢？从上表中我们发现，当我们在所有子网中都使用一个子网掩码时这一问题是无法解决的。此时VLSM就派上了用场，我们可以在100个主机的子网使用255.255.255.128这一掩码，它可以使用192.168.10.0到192.168.10.127这128个IP地址，其中可用主机号为126个。我们再把剩下的192.168.10.128到192.168.10.255这128个IP地址分成两个子网，子网掩码为255.255.255.192。其中一个子网的地址从192.168.10.128到192.168.10.191,另一子网的地址从192.168.10.192到192.168.10.255。子网掩码为255.255.255.192每个子网的可用主机地址都为62个，这样就达到了要求。可以看出合理使用子网掩码，可以使IP地址更加便于管理和控制。&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
（1）首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。&lt;/p&gt;

&lt;p&gt;（2）当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。&lt;/p&gt;

&lt;p&gt;（3）当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。&lt;/p&gt;

&lt;p&gt;（4）源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>计算机各系统组件的吞吐量和延迟</title>
      <link>http://blog.prosight.me/blogs/1002</link>
      <pubDate>2012-10-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;计算机各系统组件的吞吐量和延迟情况：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2012/10/latencyAndThroughputSouth.png&#34;&gt;&lt;img src=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2012/10/latencyAndThroughputSouth-242x300.png&#34; alt=&#34;&#34; title=&#34;latencyAndThroughputSouth&#34; width=&#34;242&#34; height=&#34;300&#34; class=&#34;alignnone size-medium wp-image-1003&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ulimit -t 设置引起进程被Kill掉</title>
      <link>http://blog.prosight.me/blogs/996</link>
      <pubDate>2012-10-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天看到某篇帖子反馈
&lt;blockquote&gt;某台机器的ulimit -t 不知道为啥是300， 这是不是意味着程序占用CPU 300秒后会收到SIGKILL ？
我用gdb跑mysqld 跑了一会，收到SIGKILL信号，没有配置cgroup，也没啥后台脚本，看了下，就ulimit -t 比较诡异，其他机器都是unlimited。&lt;/blockquote&gt;
我查了一下我的机器
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ ulimit -t
unlimited
&lt;/pre&gt;
简单的man ulimit下手册说：
&lt;blockquote&gt;-t The maximum amount of cpu time in seconds&lt;/blockquote&gt;
貌似限制的是CPU最大执行时间，以秒为单位。
为了验证上面的说法，我特地设计了以下的场景：我们首先运行一个死循环程序消耗CPU时间，同时把进程的最大CPU消耗时间设定在180秒，期待在这个时间点进程会被杀掉。
以下是验证过程：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ uname -r
2.6.32-131.21.1.tb477.el6.x86_64
$ ulimit -t 180
$ ulimit -t
180
$ cat busy.c
int main(int argc, char *argv[]) {
  for(;;);
  return 0;
}
$ gcc busy.c
$ time ./a.out
Killed&lt;/p&gt;

&lt;p&gt;real    3m0.029s
user    2m59.966s
sys    0m0.007s
&lt;/pre&gt;
从现象来看，3分钟后我们的busy进程确实被杀了，dmesg也没说什么原因被杀。&lt;/p&gt;

&lt;p&gt;不过不怕我早有准备，提早在运行的同时在另外一个终端开了个stap脚本来确定到底谁杀死了我们的进程：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cat sigkill.stp
probe signal.send{
  if(sig_name == &amp;ldquo;SIGKILL&amp;rdquo;)
    printf(&amp;ldquo;%s was sent to %s (pid:%d) by %s uid :%d\n&amp;rdquo;, sig_name, pid_name , sig_pid, execname(), uid())
}&lt;/p&gt;

&lt;p&gt;$ sudo stap sigkill.stp
SIGKILL was sent to a.out (pid:23700) by a.out uid :50920
&lt;/pre&gt;
我们可以看的很清楚是./a.out给自己发的kill信号，属于自杀.&lt;/p&gt;

&lt;p&gt;查看Linux对应内核程序
./kernel/posix-cpu-timers.c:1139
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
if (psecs &amp;gt;= sig-&amp;gt;rlim[RLIMIT_CPU].rlim_max) {
             /*&lt;br /&gt;
              * At the hard limit, we just die.&lt;br /&gt;
              * No need to calculate anything else now.&lt;br /&gt;
              &lt;em&gt;/
             __group_send_sig_info(SIGKILL, SEND_SIG_PRIV, tsk);
             return;
     }
     if (psecs &amp;gt;= sig-&amp;gt;rlim[RLIMIT_CPU].rlim_cur) {
             /&lt;/em&gt;&lt;br /&gt;
              * At the soft limit, send a SIGXCPU every second.&lt;br /&gt;
              */
             __group_send_sig_info(SIGXCPU, SEND_SIG_PRIV, tsk);
             if (sig-&amp;gt;rlim[RLIMIT_CPU].rlim_cur
                 &amp;lt; sig-&amp;gt;rlim[RLIMIT_CPU].rlim_max) {
                     sig-&amp;gt;rlim[RLIMIT_CPU].rlim_cur++;
             }
     }
&lt;/pre&gt;
内核的代码解释的很清楚，超过硬CPU限制就简单粗暴的让进程被自杀了。&lt;/p&gt;

&lt;p&gt;文章参考：http://blog.yufeng.info/archives/2311&lt;/p&gt;
</description>
    </item>
    <item>
      <title>qperf测量网络带宽和延迟</title>
      <link>http://blog.prosight.me/blogs/1000</link>
      <pubDate>2012-10-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;我们在做网络服务器的时候，通常会很关心网络的带宽和延迟。因为我们的很多协议都是request-reponse协议，延迟决定了最大的QPS，而带宽决定了最大的负荷。 通常我们知道自己的网卡是什么型号，交换机什么型号，主机之间的物理距离是多少，理论上是知道带宽和延迟是多少的。但是现实的情况是，真正的带宽和延迟情况会有很多变数的，比如说网卡驱动，交换机跳数，丢包率，协议栈配置，光实际速度都很大的影响了数值的估算。 所以我们需要找到工具来实际测量下。&lt;/p&gt;

&lt;p&gt;网络测量的工具有很多，netperf什么的都很不错。 我这里推荐了qperf，这是RHEL 6发行版里面自带的，所以使用起来很方便，只要简单的:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
yum install qperf
&lt;/pre&gt;
就好。
使用起来也相当简单：&lt;/p&gt;

&lt;p&gt;在其中一台机器上运行qperf,不带任何参数就好，这台机器就充当服务器角色：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ uname -r
2.6.32-131.21.1.tb477.el6.x86_64
$ qperf
&lt;/pre&gt;
在另外一台机器上运行qperf，测量tcp的带宽和延时，顺便看下双方机器的配置情况：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ qperf 10.232.64.yyy tcp_bw tcp_lat conf
tcp_bw:
    bw  =  118 MB/sec
tcp_lat:
    latency  =  31.9 us
conf:
    loc_node   =  xxx.sqa.cm4
    loc_cpu    =  16 Cores: Intel Xeon  L5630 @ 2.13GHz
    loc_os     =  Linux 2.6.32-131.21.1.tb477.el6.x86_64
    loc_qperf  =  0.4.6
    rem_node   =  yyy.sqa.cm4
    rem_cpu    =  16 Cores: Intel Xeon  L5630 @ 2.13GHz
    rem_os     =  Linux 2.6.32-131.21.1.tb477.el6.x86_64
&lt;/pre&gt;
是不是很方便？典型情况下我们的带宽是118M，延迟是32us, 在标准的千M环境下是符合预期的。&lt;/p&gt;

&lt;p&gt;当然qperf有很多高级参数，可以设置socket buffer的大小，绑定CPU亲缘性等， 很赞的一个特性是可以通过持续改变某个重要参数的值，来观察临界点.&lt;/p&gt;

&lt;p&gt;比如我们可以透过改变消息的大小（msg_size），比如从1个字节到64K，每次倍增的方式，来观察带宽和延迟的变化情况，演示下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ qperf -oo msg_size:1:64K:*2  10.232.64.yyy tcp_bw tcp_lat
tcp_bw:
    bw  =  2.43 MB/sec
tcp_bw:
    bw  =  4.69 MB/sec
tcp_bw:
    bw  =  9.12 MB/sec
tcp_bw:
    bw  =  18.5 MB/sec
tcp_bw:
    bw  =  33.1 MB/sec
tcp_bw:
    bw  =  61.4 MB/sec
tcp_bw:
    bw  =  114 MB/sec
tcp_bw:
    bw  =  118 MB/sec
tcp_bw:
    bw  =  113 MB/sec
tcp_bw:
    bw  =  114 MB/sec
tcp_bw:
    bw  =  114 MB/sec
tcp_bw:
    bw  =  118 MB/sec
tcp_bw:
    bw  =  117 MB/sec
tcp_bw:
    bw  =  118 MB/sec
tcp_bw:
    bw  =  118 MB/sec
tcp_bw:
    bw  =  117 MB/sec
tcp_bw:
    bw  =  117 MB/sec
tcp_lat:
    latency  =  31 us
tcp_lat:
    latency  =  31.1 us
tcp_lat:
    latency  =  31.1 us
tcp_lat:
    latency  =  31.4 us
tcp_lat:
    latency  =  30.8 us
tcp_lat:
    latency  =  32.1 us
tcp_lat:
    latency  =  32.6 us
tcp_lat:
    latency  =  33.3 us
tcp_lat:
    latency  =  35.5 us
tcp_lat:
    latency  =  38.6 us
tcp_lat:
    latency  =  50.1 us
tcp_lat:
    latency  =  69.6 us
tcp_lat:
    latency  =  88 us
tcp_lat:
    latency  =  128 us
tcp_lat:
    latency  =  209 us
tcp_lat:
    latency  =  365 us
tcp_lat:
    latency  =  650 us
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;我们可以看到当包的大小达到64字节的时候，带宽就上不去了；包到达1K的时候，延迟有了很大的变化。 这些临界点对我们的服务器编程时候对性能的估计和预期非常有帮助。&lt;/p&gt;

&lt;p&gt;qperf除了测量tcp的，还可以测试rdma, udp, sctp等主流网络协议的带宽和延迟，算是个很新的工具，推荐大家使用。&lt;/p&gt;

&lt;p&gt;引自：http://blog.yufeng.info/archives/2234&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在Mac上体验Erlang</title>
      <link>http://blog.prosight.me/blogs/987</link>
      <pubDate>2012-10-15 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
    &lt;li&gt;下载源代码&lt;/li&gt;
&lt;div&gt;http://erlang.org/download.html ， 最新的版本是&lt;a href=&#34;http://www.erlang.org/download/otp_src_R15B02.tar.gz&#34; target=&#34;_blank&#34;&gt;R15B02&lt;/a&gt;&lt;/div&gt;
    &lt;li&gt;编译安装&lt;/li&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;./configure \
--prefix=/usr/local/ \
--enable-smp-support \
--enable-threads \
--enable-darwin-64bit&lt;/pre&gt;
其中--enable-darwin-64bit 是为了支持64bit x86 Darwin系统

执行编译安装
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
make -j 8
sudo make install
&lt;/pre&gt;

&lt;li&gt;测试安装结果&lt;/li&gt;
在一个方便的目录中建立一个test.erl文件，内容如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-module(test).
-export([fac/1]).

fac(0) -&gt; 1;
fac(N) -&gt; N * fac(N-1).
&lt;/pre&gt;

在这个目录中，进入命令行。输入erl，进入erlang的解释器。测试以下命令：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
1&gt; c(test).
{ok,test}
2&gt; test:fac(20).
2432902008176640000
3&gt; test:fac(40).
815915283247897734345611269596115894272000000000
&lt;/pre&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>设计模式原则总结</title>
      <link>http://blog.prosight.me/blogs/984</link>
      <pubDate>2012-10-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;
&lt;p align=&#34;center&#34;&gt;名称&lt;/p&gt;
&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;
&lt;p align=&#34;center&#34;&gt;解释&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;0、单一职责原则（SRP）&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;就一个类而言，应该仅有一个引起它变化的原因。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;一、&amp;rdquo;开放－封闭&amp;rdquo;原则(OCP)&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;在软件设计模式中，这种不能修改，但可以扩展的思想也是最重要的一种设计原则。即软件实体（类、模板、函数等等）应该可以扩展，但是不可修改。&lt;/p&gt;

&lt;p&gt;【通俗】：设计的时候，时刻考虑，尽量让这个类是足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;二、里氏代换原则（LSP）&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;1.一个软件实体如果使用的是一个父类的话，那么一定适用于该子类，而且他觉察不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化。&lt;/p&gt;

&lt;p&gt;【一句话】：&lt;strong&gt;子类型必须能够替换掉他们的父类型。&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;三、依赖倒置原则(DIP)&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;1.高层模块不应该依赖于底层模块。两个都应该依赖抽象。2.抽象不应该依赖于细节，细节依赖于抽象（&lt;/p&gt;

&lt;p&gt;【白话】：针对接口编程，不要针对实现编程。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;四、接口隔离原则（ISP）&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;1.使用多个专门的接口比使用单一的总接口总要好。换而言之，从一个客户类的角度来讲：一个类对另外一个类的依赖性应当是建立在最小接口上的。&lt;/p&gt;

&lt;p&gt;2．过于臃肿的接口是对接口的污染。不应该强迫客户依赖于它们不用的方法。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;五、合成/聚合复用原则（CARP）&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;尽量使用合成/聚合，尽量不要使用类继承。&lt;/p&gt;

&lt;p&gt;【聚合】：表示一种弱的拥有关系，体现的是A对象可以包含B对象，但B对象不是A对象的一部分。&lt;/p&gt;

&lt;p&gt;【合成】：一种强的拥有关系，提现了严格的部分和整体的关系，部分和整体的生存周期一致。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;六、迪米特法则（LoD）&lt;/p&gt;

&lt;p&gt;最少知识原则&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;强调类之间的松耦合。即：如果两个类不必彼此直接通信，那么着两个类就不应当发送直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p align=&#34;right&#34;&gt;大部分内容摘自《&lt;em&gt;大话设计模式&lt;/em&gt;》&lt;/p&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用Go连接MySQL</title>
      <link>http://blog.prosight.me/blogs/976</link>
      <pubDate>2012-10-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;搭好GO开发环境后，获取mysql开发驱动包：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
go get code.google.com/p/go-mysql-driver/mysql  
&lt;/pre&gt;

&lt;p&gt;之后就可以使用MySQL了
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
package main&lt;/p&gt;

&lt;p&gt;import &amp;ldquo;fmt&amp;rdquo;&lt;br /&gt;
import &amp;ldquo;database/sql&amp;rdquo;&lt;br /&gt;
import &amp;ldquo;code.google.com/p/go-mysql-driver/mysql&amp;rdquo;&lt;/p&gt;

&lt;p&gt;func main(){&lt;br /&gt;
    fmt.Printf(&amp;ldquo;query:\n&amp;rdquo;)&lt;br /&gt;
    db,e  := sql.Open(&amp;ldquo;mysql&amp;rdquo;, &amp;ldquo;root:@/mysql?charset=utf8&amp;rdquo;)&lt;br /&gt;
    //说明：第一个参数&amp;rdquo;mysql&amp;rdquo;表示打开一个MYSQL链接&lt;br /&gt;
    //第二个参数是一个DSN，格式是：&lt;br /&gt;
    //[username[:password]@][protocol[(address)]]/dbname[?param1=value1&amp;amp;paramN=valueN]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if e != nil {  
    fmt.Printf(&amp;quot;conn error.&amp;quot;);  
    return;  
}  
rows,e := db.Query(&amp;quot;select host,user from user&amp;quot;)  
if e != nil {  
    fmt.Printf(&amp;quot;query error.&amp;quot;);  
    return;  
}  

i := 0  
for rows.Next() {  
    i++  
    var ss,s2 string  
    e = rows.Scan( &amp;amp;ss,&amp;amp;s2 )  
    if e == nil {  
        fmt.Printf(&amp;quot;Title: %s,%s \n&amp;quot;, ss,s2 )  
    }else{  
        fmt.Printf(&amp;quot;error&amp;quot;)  
    }  
}  
fmt.Printf(&amp;quot;Total: %d\n&amp;quot; , i )  
db.Close()  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Mountain Lion环境变量设置问题</title>
      <link>http://blog.prosight.me/blogs/968</link>
      <pubDate>2012-10-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近升级到Mountain Lion，安装软件突然发现之前在~/.profile中设置的环境变量都无效。&lt;/p&gt;

&lt;p&gt;经反复测试，发现只有~/.bash_profile中设置的环境变量有销，其他位置存放的环境变量都无效。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Go的格式化工具</title>
      <link>http://blog.prosight.me/blogs/970</link>
      <pubDate>2012-10-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Go对代码规范方面提供了别的语言没有提供的不错的工具。&lt;/p&gt;

&lt;p&gt;例如可以把下面的代码
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
type T struct {
    name string // name of the object
    value int // its value
}
&lt;/pre&gt;
格式化成
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
type T struct {
    name    string // name of the object
    value   int    // its value
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;使用方法如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
gofmt&lt;/p&gt;

&lt;p&gt;usage: gofmt [flags] [path &amp;hellip;]
  -comments=true: print comments
  -cpuprofile=&amp;ldquo;&amp;rdquo;: write cpu profile to this file
  -d=false: display diffs instead of rewriting files
  -e=false: print all (including spurious) errors
  -l=false: list files whose formatting differs from gofmt&amp;rsquo;s
  -r=&amp;ldquo;&amp;rdquo;: rewrite rule (e.g., &amp;lsquo;a[b:len(a)] -&amp;gt; a[b:]&amp;lsquo;)
  -s=false: simplify code
  -tabs=true: indent with tabs
  -tabwidth=8: tab width
  -w=false: write result to (source) file instead of stdout
&lt;/pre&gt;
比较有用的是-d和-w参数，分别表示比较修改后的文件和将修改后的文件替换源文件。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>网站密码存储方案比较</title>
      <link>http://blog.prosight.me/blogs/958</link>
      <pubDate>2012-10-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;为了对用户负责，用户密码采用不可逆算法的时候，我们就要考虑一下如何对用户密码进行加密。那么仅仅是使用不可逆算法就行了吗？还不是，在硬件飞速发展的今天，尤其是GPU运算能力超CPU 10-20倍甚至更多，使得暴力破解的时间大大缩短。那么为了使得暴力破解变得几乎不可能，我们就要使用一些不支持GPU加速破解的算法。这里所说的算法，实际上也是各种加密的hash方式。&lt;/p&gt;

&lt;p&gt;目前常见的&lt;strong&gt;不可逆加密算法&lt;/strong&gt;有以下几种：
&lt;ul&gt;
    &lt;li&gt;一次MD5（使用率很高）&lt;/li&gt;
    &lt;li&gt;将密码与一个随机串进行一次MD5&lt;/li&gt;
    &lt;li&gt;两次MD5，使用一个随机字符串与密码的md5值再进行一次md5，使用很广泛&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/PBKDF2&#34; target=&#34;_blank&#34;&gt;PBKDF2&lt;/a&gt;算法&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://en.wikipedia.org/wiki/Bcrypt&#34; target=&#34;_blank&#34;&gt;bcrypt&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;其它加密算法&lt;/li&gt;
&lt;/ul&gt;
现在，通常推荐使用 bcrypt 或 PBKDF2 这两种算法来对密码进行加密。下面对以上几种加密算法进行一下简单的分析。
第一种就不解释了，我们看下第二种加密算法（php代码）$salt是一个随机字符串，每个用户都不一样，并且要存储下来用于验证
&lt;pre class=&#34;prettyprint linenums&#34;&gt;md5($password.$salt)&lt;/pre&gt;
第三种算法（php代码）
&lt;pre class=&#34;prettyprint linenums&#34;&gt;md5(md5($password).$salt)&lt;/pre&gt;
第一种和第二种都是一次md5，尤其是第一种，假设原始字符串很短，当然，我们的密码通常都不会很长，所以暴力破解还是不会耗时太久的。尤其是采用GPU运算。
下面这个网址中，作者针对cpu、gup和各种单一的加密算法破解进行了一些描述，有兴趣的可以看看：
&lt;a href=&#34;http://www.codinghorror.com/blog/2012/04/speed-hashing.html&#34; target=&#34;_blank&#34;&gt;http://www.codinghorror.com/blog/&lt;sup&gt;2012&lt;/sup&gt;&amp;frasl;&lt;sub&gt;04&lt;/sub&gt;/speed-hashing.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;下面的网址还介绍了我国山东大学的王晓云和余洪波关于md5碰撞的文章，可以生成两个一样的md5值的文件。http://www.mscs.dal.ca/~selinger/md5collision/&lt;/p&gt;

&lt;p&gt;上面链接的内容同样证明了一次MD5并不可靠。那么第二种和第三种是否可靠呢？第二种，要看你随机字符串有多长了，再加上原始密码，字符串越长，暴力破解的时间就越长，第三种就要暴力破解32位字符串的MD5，耗时嘛，以目前的硬件来看，估计单台机器普通人是等不到它破解出来了。不过如果涉及到国防级别，像美国使用超级计算机集群来破解的话，或许，用不了多长时间。&lt;/p&gt;

&lt;p&gt;下面介绍第四种，是django 1.4默认采用的密码加密算法。点击上面PBKDF2的链接，在维基百科上已经有很详细的介绍，它使得暴力破解的希望更加渺茫。这也是django1.4安全性提升的一个亮点，在此之前它使用sha1来加密。PBKDF2实际上默认采用并推荐sha256，然后再配合10000次运算得出的结果。
参考标准：&lt;a href=&#34;https://www.ietf.org/rfc/rfc6070.txt&#34; target=&#34;_blank&#34;&gt;rfc6070&lt;/a&gt;，&lt;a href=&#34;https://www.ietf.org/rfc/rfc2898.txt&#34; target=&#34;_blank&#34;&gt;rfc2898&lt;/a&gt;
我们看一下django中关于PBKDF2的代码：utils/crypto.py&lt;/p&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;
def pbkdf2(password, salt, iterations, dklen=0, digest=None):
    &amp;ldquo;&amp;rdquo;&amp;rdquo;
    Implements PBKDF2 as defined in RFC 2898, section 5.2&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;HMAC+SHA256 is used as the default pseudo random function.

Right now 10,000 iterations is the recommended default which takes
100ms on a 2.2Ghz Core 2 Duo.  This is probably the bare minimum
for security given 1000 iterations was recommended in 2001. This
code is very well optimized for CPython and is only four times
slower than openssl&#39;s implementation.
&amp;quot;&amp;quot;&amp;quot;
assert iterations &amp;gt; 0
if not digest:
    digest = hashlib.sha256
hlen = digest().digest_size
if not dklen:
    dklen = hlen
if dklen &amp;gt; (2 ** 32 - 1) * hlen:
    raise OverflowError(&#39;dklen too big&#39;)
l = -(-dklen // hlen)
r = dklen - (l - 1) * hlen

hex_format_string = &amp;quot;%%0%ix&amp;quot; % (hlen * 2)

def F(i):
    def U():
        u = salt + struct.pack(&#39;&amp;gt;I&#39;, i)
        for j in xrange(int(iterations)):
            u = _fast_hmac(password, u, digest).digest()
            yield _bin_to_long(u)
    return _long_to_bin(reduce(operator.xor, U()), hex_format_string)

T = [F(x) for x in range(1, l + 1)]
return &#39;&#39;.join(T[:-1]) + T[-1][:r]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;
然后在django.contrib.auth.hashers里使用，密码以“algorithm$number of iterations$salt$password hash”的格式返回，并存储在同一个字段中。当然，如果你自己编写PBKDF2函数，你可以将salt存储在任意字段。只要让每个用户都不一样就行了。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
class PBKDF2PasswordHasher(BasePasswordHasher):
    &amp;ldquo;&amp;rdquo;&amp;rdquo;
    Secure password hashing using the PBKDF2 algorithm (recommended)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Configured to use PBKDF2 + HMAC + SHA256 with 10000 iterations.
The result is a 64 byte binary string.  Iterations may be changed
safely but you must rename the algorithm if you change SHA256.
&amp;quot;&amp;quot;&amp;quot;
algorithm = &amp;quot;pbkdf2_sha256&amp;quot;
iterations = 10000
digest = hashlib.sha256

def encode(self, password, salt, iterations=None):
    assert password
    assert salt and &#39;$&#39; not in salt
    if not iterations:
        iterations = self.iterations
    hash = pbkdf2(password, salt, iterations, digest=self.digest)
    hash = hash.encode(&#39;base64&#39;).strip()
    return &amp;quot;%s$%d$%s$%s&amp;quot; % (self.algorithm, iterations, salt, hash)

def verify(self, password, encoded):
    algorithm, iterations, salt, hash = encoded.split(&#39;$&#39;, 3)
    assert algorithm == self.algorithm
    encoded_2 = self.encode(password, salt, int(iterations))
    return constant_time_compare(encoded, encoded_2)

def safe_summary(self, encoded):
    algorithm, iterations, salt, hash = encoded.split(&#39;$&#39;, 3)
    assert algorithm == self.algorithm
    return SortedDict([
        (_(&#39;algorithm&#39;), algorithm),
        (_(&#39;iterations&#39;), iterations),
        (_(&#39;salt&#39;), mask_hash(salt)),
        (_(&#39;hash&#39;), mask_hash(hash)),
    ])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;
再贴一个php的PBKDF2加密函数
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&amp;lt;?php
  // PBKDF2 Implementation (described in RFC 2898)
  //
  // @param   string  p   password
  // @param   string  s   salt
  // @param   int     c   iteration count (use 1000 or higher)
  // @param   int     kl  derived key length
  // @param   string  a   hash algorithm
  // @param   int     st  start position of result
  //
  // @return  string  derived key
  function str_hash_pbkdf2($p, $s, $c, $kl, $a = &amp;lsquo;sha256&amp;rsquo;, $st=0)
  {
    $kb = $start+$kl;                        // Key blocks to compute
    $dk = &amp;ldquo;;                                    // Derived key&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Create key
for ($block=1; $block&amp;lt;=$kb; $block++)
{
  // Initial hash for this block
  $ib = $h = hash_hmac($a, $s . pack(&#39;N&#39;, $block), $p, true); 

  // Perform block iterations
  for ($i=1; $i&amp;lt;$c; $i++)
  {
    // XOR each iterate
    $ib ^= ($h = hash_hmac($a, $h, $p, true));
  } 

  $dk .= $ib;                                // Append iterated block
} 

// Return derived key of correct length
return substr($dk, $start, $kl);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
?&amp;gt;
&lt;/pre&gt;
bcrypt加密在使用上则简单很多。不过多数语言要针对它安装扩展。如php,python都要安装扩展。
使如django中使用bcrypt加密的代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
bcrypt = self._load_library()
        data = bcrypt.hashpw(password, salt)
&lt;/pre&gt;
所以这里就不多介绍bcrypt了。字符串的长度，影响它生成hash值的时间。当然，这似乎在任何一种hash算法上都是成正比的。&lt;/p&gt;

&lt;p&gt;实际上，无论是bcrypt还是PBKDF2都有各自的忠实拥护者。另外bcrypt不支持超过55个字符的密码短语。到底那一个好，没有标准答案，取决于你问那一方的粉丝。我个人偏向于使用PBKDF2，下面的参考资料中，或许也会给你答案。&lt;/p&gt;

&lt;p&gt;其它参考资料：
&lt;a href=&#34;http://stackoverflow.com/questions/4433216/password-encryption-pbkdf2-using-sha512-x-1000-vs-bcrypt&#34; target=&#34;_blank&#34;&gt;password-encryption-pbkdf2-using-sha512-x-1000-vs-bcrypt&lt;/a&gt;
&lt;a href=&#34;http://stackoverflow.com/questions/1561174/sha512-vs-blowfish-and-bcrypt&#34; target=&#34;_blank&#34;&gt;sha512-vs-blowfish-and-bcrypt&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>更改Mac中的默认JDK版本</title>
      <link>http://blog.prosight.me/blogs/929</link>
      <pubDate>2012-09-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在Mac中，Apple默认安装的是1.6的JDK，如果你从Oracle下载了最新的1.7的JDK(&lt;a title=&#34;Oracle JDK&#34; href=&#34;http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1637583.html&#34; target=&#34;_blank&#34;&gt;http://www.oracle.com/technetwork/java/javase/downloads/jdk7-downloads-1637583.html&lt;/a&gt;)，并安装了它。但是你会发现当你在命令行查看版本的时候，仍然是显示1.6版本的JDK&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2012/09/11.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-932&#34; title=&#34;jdk1.6&#34; src=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2012/09/11.png&#34; alt=&#34;&#34; width=&#34;538&#34; height=&#34;76&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;最新安装的JDK并没有生效。可以使用下面的办法比较方便的更改JDK的版本。&lt;/p&gt;

&lt;p&gt;在Finder中运行/Library/Java/JavaVirtualMachines/1.7.0.jdk，&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2012/09/2.png&#34;&gt;&lt;img class=&#34;alignnone size-full wp-image-934&#34; title=&#34;Java&#34; src=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2012/09/2.png&#34; alt=&#34;&#34; width=&#34;345&#34; height=&#34;61&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;然后将你希望的JDK版本拖拽到第一个位置，就可以更改JDK的版本了&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2012/09/4.png&#34;&gt;&lt;img src=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2012/09/4.png&#34; alt=&#34;&#34; title=&#34;Java&#34; width=&#34;626&#34; height=&#34;320&#34; class=&#34;alignnone size-full wp-image-940&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>五一晋西南游</title>
      <link>http://blog.prosight.me/blogs/921</link>
      <pubDate>2012-05-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;五一假期，二天半时间，行程2000多公里，去了趟晋西南的壶口瀑布和碛口古镇。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2012/05/1.png&#34;&gt;&lt;img src=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2012/05/1-300x243.png&#34; alt=&#34;&#34; title=&#34;路线图&#34; width=&#34;300&#34; height=&#34;243&#34; class=&#34;alignnone size-medium wp-image-926&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;壶口瀑布，身临其境才能体会到它的壮美
&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BW685BHt/medish.jpg&#34; title=&#34;壶口&#34; class=&#34;alignnone&#34; width=&#34;427&#34; height=&#34;640&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BW68d8xl/medium.jpg&#34; title=&#34;壶口&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;碛口古镇
&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BW68KZdv/medium.jpg&#34; title=&#34;碛口&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;139&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BW68DL3B/medium.jpg&#34; title=&#34;碛口&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BW68Q6tZ/medium.jpg&#34; title=&#34;碛口&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BW69iEgC/medium.jpg&#34; title=&#34;碛口&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BW68Z6WZ/medium.jpg&#34; title=&#34;碛口&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;317&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BW69fnyB/medium.jpg&#34; title=&#34;碛口&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BW69n5Bk/medish.jpg&#34; title=&#34;碛口&#34; class=&#34;alignnone&#34; width=&#34;427&#34; height=&#34;640&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>北国春色</title>
      <link>http://blog.prosight.me/blogs/916</link>
      <pubDate>2012-04-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;4-5月是北方姹紫嫣红的月份，各色的花争奇斗艳，树木、小草都绽放出嫩绿，甚是好看。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BSkvetpd/medium.jpg&#34; title=&#34;八大处&#34; class=&#34;alignnone&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BSkuK0X7/medium.jpg&#34; title=&#34;八大处&#34; class=&#34;alignnone&#34;  /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BSkxb7L6/medium.jpg&#34; title=&#34;首都图书馆&#34; class=&#34;alignnone&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BTFA9Th4/medium.jpg&#34; title=&#34;于桥水库&#34; class=&#34;alignnone&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BTFxuWa3/medium.jpg&#34; title=&#34;于桥水库&#34; class=&#34;alignnone&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在xcode4.2中手工添加GPX文件，指定位置。</title>
      <link>http://blog.prosight.me/blogs/910</link>
      <pubDate>2012-03-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;XCode 4.2终于支持地点模拟了,不用忍受真机调试的各种不便了,模拟方法也很简单(恕我盗用几个别人的图):&lt;/p&gt;

&lt;p&gt;当Debug一个需要地理位置信息的App时,在Debug栏默认就会有地点模拟的图标,如下图所示:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone&#34; title=&#34;地点模拟的图标&#34; src=&#34;http://longtimenoc.com/wordpress/wp-content/uploads/2011/11/WWDCxcode_simulator_location_services3.jpg&#34; alt=&#34;地点模拟的图标&#34; width=&#34;480&#34; height=&#34;230&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这个有一个前提:必须是iOS5的模拟器.&lt;/p&gt;

&lt;p&gt;默认只提供了几个地点,但是可以通过GPX文件来添加.你可以选择到网上找现成的GPX,但是Apple还是很为广大开发者考虑的,提供了GPX的模版,创建方法 新建&amp;gt;&amp;gt;Resource&amp;gt;&amp;gt;GPX File 如下图:&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone&#34; title=&#34;GPX的模版&#34; src=&#34;http://longtimenoc.com/wordpress/wp-content/uploads/2011/11/WWDCxcode_simulator_location_services2.jpg&#34; alt=&#34;GPX的模版&#34; width=&#34;480&#34; height=&#34;340&#34; /&gt;&lt;/p&gt;

&lt;p&gt;其实所谓的GPX就是一XML文件,默认的内容如下:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo;?&amp;gt; &lt;gpx version=&#34;1.1&#34; creator=&#34;Xcode&#34;&gt; &lt;wpt lat=&#34;37.331705&#34; lon=&#34;-122.030237&#34;&gt; &lt;name&gt;Cupertino&lt;/name&gt; &lt;/wpt&gt; &lt;/gpx&gt;&lt;/pre&gt;
添加了GPX文件后就可以在之前选择地点那里看到你的GPX文件了.&lt;/p&gt;

&lt;p&gt;注意：每次重新启动模拟器，需要重指定位置⋯⋯&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Apple LLVM 4.0的新特性</title>
      <link>http://blog.prosight.me/blogs/904</link>
      <pubDate>2012-02-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最新的LLVM 4.0添加了几个比较有用的特性：
&lt;ol&gt;
    &lt;li&gt;@synthesize: 自动为@property添加synthesize&lt;/li&gt;
    &lt;li&gt;语法: 创建NSArray, NSDictionary, NSNumber的时候, 可以像NSString那样写 (下面例子解释!)&lt;/li&gt;
    &lt;li&gt;容器下标: 用’[]‘来访问容器(例如NSArray和NSDictionary), 就像你在第一节C语言课上学的”arr[0]“, “arr[1]“那样. 不过这个似乎是允许在’[]‘中填入字符串的(NSDictionary).&lt;/li&gt;
&lt;/ol&gt;
下面举例解释下第二条:
NSArray
Previously:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
array = [NSArray arrayWithObjects:a, b, c, nil];
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Now:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
array = @[a, b, c];
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;NSDictionary
Previously:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
dict = [NSDictionary dictionaryWithObjects:@[o1, o2, o3] forKeys:@[k1, k2, k3]];
&lt;/pre&gt;
Now:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
dict = @{k1: o1, k2: o2, k3: o3};
&lt;/pre&gt;
NSNumber
Previously:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSNumber *number;
number = [NSNumber numberWithChar:&amp;lsquo;X&amp;rsquo;];
number = [NSNumber numberWithInt:12345];
number = [NSNumber numberWithUnsignedLong:12345ul];
number = [NSNumber numberWithLongLong:12345ll];
number = [NSNumber numberWithFloat:123.45f];
number = [NSNumber numberWithDouble:123.45];
number = [NSNumber numberWithBool:YES];
&lt;/pre&gt;
Now:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSNumber *number;
number = @&amp;lsquo;X&amp;rsquo;;
number = @12345;
number = @12345ul;
number = @12345ll;
number = @123.45f;
number = @123.45;
number = @YES;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;引自：http://seymourdev.com/?p=302#more-302&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Thrift简析</title>
      <link>http://blog.prosight.me/blogs/902</link>
      <pubDate>2012-02-12 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;RPC技术及实现简介&lt;/h2&gt;

&lt;p&gt;首先思考一下分布式系统中的 RPC (Remote Procedure Call) 问题，一个完整的 RPC 模块需要可以分为三个层次
&lt;ul&gt;
    &lt;li&gt;服务层（service）：RPC 接口定义与实现&lt;/li&gt;
    &lt;li&gt;协议层（protocol）：RPC 报文格式和数据编码格式&lt;/li&gt;
    &lt;li&gt;传输层（transport）：实现底层的通信（如 socket）以及系统相关的功能（如事件循环、多线程）&lt;/li&gt;
&lt;/ul&gt;
在实际的大型分布式系统中，不同的服务往往会使用不同的语言来实现，所以一般的 RPC 系统会提供一种跨语言的过程调用功能，比如一段用C++实现的客户端代码可以远程调用一个用 Java 实现的服务。实现跨语言 RPC 有两种方法：
&lt;ul&gt;
    &lt;li&gt;静态代码生成：开发者用一种中间语言（IDL，接口定义语言）来定义 RPC 的接口和数据类型，然后通过一个编译器来生成不同语言的代码（如C++, Java, Python），并由生成的代码来负责 RPC 协议层和传输层的实现。例如，服务的实现用C++，则服务端需要生成实现RPC协议和传输层的C++代码，服务层使用生成的代码来实现与客户端的通信；而如果客户端用 Python，则客户端需要生成Python代码。&lt;/li&gt;
    &lt;li&gt;基于“自省”的动态类型系统来实现：协议和传输层可以只用一种语言实现成一个库，但是这种语言需要关联一个具备“自省”或者反射机制的动态类型系统，对外提供其他语言的绑定，客户端和服务端通过语言绑定来使用 RPC。比如，可以考虑用 C 和 GObject 实现一个 RPC 库，然后通过 GObject 实现其他语言的绑定。&lt;/li&gt;
&lt;/ul&gt;
第一种方法的优点是RPC的协议层和传输层的实现不需要和某种动态类型系统（如GObject）绑定在一起，同时避免了动态类型检查和转换，程序效率比较高，但是它的缺点是要为不同语言提供不同的 RPC 协议层和传输层实现。第二种方法的主要难度在于语言绑定和通用的对象串行化机制的实现，同时也需要考虑效率的问题。&lt;/p&gt;

&lt;p&gt;Thrift 是一个基于静态代码生成的跨语言的RPC协议栈实现，它可以生成包括C++, Java, Python, Ruby, PHP 等主流语言的代码，这些代码实现了 RPC 的协议层和传输层功能，从而让用户可以集中精力于服务的调用和实现。Cassandra 的服务访问协议是基于 Thrift 来实现的。&lt;/p&gt;

&lt;h2&gt;Thrift介绍&lt;/h2&gt;

&lt;p&gt;Thrift源于大名鼎鼎的facebook之手，在2007年facebook提交Apache基金会将Thrift作为一个开源项目，对于当时的facebook来说创造thrift是为了解决facebook系统中各系统间大数据量的传输通信以及系统之间语言环境不同需要跨平台的特性。所以thrift可以支持多种程序语言，例如: C++, C#, Cocoa, Erlang, Haskell, Java, Ocami, Perl, PHP, Python, Ruby, Smalltalk. 在多种不同的语言之间通信thrift可以作为二进制的高性能的通讯中间件，支持数据(对象)序列化和多种类型的RPC服务。Thrift适用于程序对程 序静态的数据交换，需要先确定好他的数据结构，他是完全静态化的，当数据结构发生变化时，必须重新编辑IDL文件，代码生成，再编译载入的流程，跟其他IDL工具相比较可以视为是Thrift的弱项，Thrift适用于搭建大型数据交换及存储的通用工具，对于大型系统中的内部数据传输相对于JSON和xml无论在性能、传输大小上有明显的优势。&lt;/p&gt;

&lt;p&gt;Thrift 主要由5个部分组成：
&lt;ul&gt;
    &lt;li&gt;类型系统以及 IDL 编译器：负责由用户给定的 IDL 文件生成相应语言的接口代码&lt;/li&gt;
    &lt;li&gt;TProtocol：实现 RPC 的协议层，可以选择多种不同的对象串行化方式，如 JSON, Binary。&lt;/li&gt;
    &lt;li&gt;TTransport：实现 RPC 的传输层，同样可以选择不同的传输层实现，如socket, 非阻塞的 socket, MemoryBuffer 等。&lt;/li&gt;
    &lt;li&gt;TProcessor：作为协议层和用户提供的服务实现之间的纽带，负责调用服务实现的接口。&lt;/li&gt;
    &lt;li&gt;TServer：聚合 TProtocol, TTransport 和 TProcessor 几个对象。&lt;/li&gt;
&lt;/ul&gt;
上述的这5个部件都是在 Thrift 的源代码中通过为不同语言提供库来实现的，这些库的代码在 Thrift 源码目录的 lib 目录下面，在使用 Thrift 之前需要先熟悉与自己的语言对应的库提供的接口。&lt;/p&gt;

&lt;p&gt;Thrift 官方网站：http://thrift.apache.org&lt;/p&gt;
</description>
    </item>
    <item>
      <title>延迟加载图片的jQuery插件-Lazy Load Plugin for JQuery</title>
      <link>http://blog.prosight.me/blogs/894</link>
      <pubDate>2012-02-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Lazy Load是一个用Javascript写得jQuery插件。它可以使一个长网页中，不在当前视图中的图片延迟加载，以提高页面的载入速度。&lt;/p&gt;

&lt;h2&gt;使用方法&lt;/h2&gt;

&lt;p&gt;在页面头部加入插件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;script src=&#34;jquery.js&#34; type=&#34;text/javascript&#34;&gt;&lt;/script&gt;
&lt;script src=&#34;jquery.lazyload.js&#34; type=&#34;text/javascript&#34;&gt;&lt;/script&gt;
&lt;/pre&gt;
在使用图片的地方，使用下面的设置
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;img class=&#34;lazy&#34; src=&#34;img/grey.gif&#34; alt=&#34;&#34; width=&#34;640&#34; data-original=&#34;img/example.jpg&#34; data-pinit=&#34;registered&#34; /&gt;
&lt;/pre&gt;
src是替换图片，一般使用1*1像素的图片替代。后面data-original才是真正的图片。&lt;/p&gt;

&lt;p&gt;然后在你的代码中加入,就可以了
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$(&amp;ldquo;img.lazy&amp;rdquo;).lazyload();&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;设置延迟加载参数&lt;/h2&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;$(&amp;ldquo;img.lazy&amp;rdquo;).lazyload({ threshold : 200 });&lt;/pre&gt;
这样，图片就可以在距离显示区域200像素的时候就开始预先加载。这个值可以是负值，表示提前加载。&lt;/p&gt;

&lt;h2&gt;使用特效&lt;/h2&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$(&amp;ldquo;img.lazy&amp;rdquo;).lazyload({
    effect : &amp;ldquo;fadeIn&amp;rdquo;
});
&lt;/pre&gt;
默认延迟加载使用show方法来显示图片，可以用这个方法来改变图片的显示方法。
插件主页：http://www.appelsiini.net/projects/lazyload&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Nginx使用Linux内存加速静态文件访问</title>
      <link>http://blog.prosight.me/blogs/889</link>
      <pubDate>2012-02-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Nginx是一个非常出色的静态资源web服务器。如果你嫌它还不够快，可以把放在磁盘中的文件，映射到内存中，减少高并发下的磁盘IO。&lt;/p&gt;

&lt;p&gt;先做几个假设。nginx.conf中所配置站点的路径是/home/wwwroot/res，站点所对应文件原始存储路径：/opt/web/res&lt;/p&gt;

&lt;p&gt;shell脚本非常简单，思路就是拷贝资源文件到内存中，然后在把网站的静态文件链接指向到内存中即可。具体如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;#! /bin/bash&lt;/p&gt;

&lt;p&gt;res_path=&amp;ldquo;/opt/web/res&amp;rdquo;&lt;br /&gt;
mem_path=&amp;ldquo;/dev/shm/res&amp;rdquo;&lt;br /&gt;
lk_path=&amp;ldquo;/home/wwwroot/res&amp;rdquo;&lt;/p&gt;

&lt;p&gt;if [ ! -d &amp;ldquo;$mem_path&amp;rdquo; ]; then&lt;br /&gt;
        cp -r &amp;ldquo;$res_path&amp;rdquo; &amp;ldquo;$mem_path&amp;rdquo;&lt;br /&gt;
fi&lt;/p&gt;

&lt;p&gt;if [ ! -L &amp;ldquo;$lk_path&amp;rdquo; ]; then&lt;br /&gt;
        ln -s &amp;ldquo;$mem_path&amp;rdquo; &amp;ldquo;$lk_path&amp;rdquo;&lt;/p&gt;

&lt;h1&gt;fi&lt;/pre&gt;&lt;/h1&gt;

&lt;p&gt;更新测试数据&lt;/p&gt;

&lt;p&gt;利用上述方法，在公司的测试服务器上做了个测试，速度提升明显，速度几乎翻倍。&lt;/p&gt;

&lt;p&gt;测试前提：将测试网站的首页全部内容包括html，图片，js，css等所有元素都拷贝到内存中,并且每次用户请求静态资源文件都不会缓存。使用LoadRunner按照200和100并发分别进行压力测试。&lt;/p&gt;

&lt;p&gt;测试结果:
&lt;ol&gt;
    &lt;li&gt;在高并发下全部使用磁盘文件200人并发 2分钟 平均每次事务响应时间为19.96秒 每秒处理事务数为9.26个
使用内存200人并发 2分钟 平均每次事务响应时间为11.3秒 每秒处理事务数为15.8个&lt;/li&gt;
    &lt;li&gt;在低并发下全部使用磁盘文件100人并发 2分钟 平均每次事务响应时间为10.27秒 每秒处理事务数为9.32个
使用内存100人并发 2分钟 平均每次事务响应时间为5.84秒 每秒处理事务数为16.17个&lt;/li&gt;
&lt;/ol&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>可伸缩性架构常用技术——之数据切分（Data Sharding/Partition）</title>
      <link>http://blog.prosight.me/blogs/885</link>
      <pubDate>2012-01-29 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;简介&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我们知道，为了应对不断增长的数据，我们对数据进行切分，存储在不同的数据库里，本文提到的数据库在非特定指明的情况下，均指一个逻辑数据库（是一组数据库，比如Master-Slave），而非单一各个物理数据库。&lt;/p&gt;

&lt;p&gt;其主要有两种方式：&lt;/p&gt;

&lt;p&gt;垂直切分（Vertical Partition/Sharding）:就是把不同格式的数据，存储到不同的数据库。
水平切分（Horizontal Partition/Sharding）:就是把相同的数据格式的数据，存储到不同的数据库，本文将侧重这点进行讲述。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;垂直切分（Vertical Partition/Sharding）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于垂直切分，其实应用非常广泛，主旨是把那些关系依赖非常紧密的数据保存到同一数据库，主要包含如下几种应用方式：&lt;/p&gt;

&lt;p&gt;不同的应用使用不同数据库:这个非常容易理解，即对于一个企业来讲，往往有多个应用，甚至有些应用逐渐演变成两个或者多个应用，这其实就是一种垂直切分应用。
应用的不同模块使用不同的数据库:为同一应用的不同模块分别使用不同的数据库，之间提供低耦合的API进行访问。
同一应用相同模块使用不同数据库:在一些应用中，对于适合关系查询的数据，保存在关系数据库，而另外一些适合以NoSQL数据库保存的数据（例如key-value数据库），保存在NoSQL数据库中，方便数据扩展。这里给出一个例子，比如一个论坛应用，可以对个人用户信息保存在关系数据库，例如，其访问次数，个人信息等等，而对于发表的帖子和回帖，则可以保存在一个NoSQL里，方便扩展。注意，这里给出的例子并非真实例子，只是为了易于说明给出一个假设性的例子。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;水平切分（Horizontal Partition/Sharding）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;水平切分相对比较复杂，我们还是从水平切分的策略谈起。&lt;/p&gt;

&lt;p&gt;3.1     水平切分策略主要分为以下几种：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Round-Robin（轮询式）算法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;顾名思义，就是把数据按照轮流的方式依次存放在的数据库节点上，比如，有2个节点，N0和N1，那么Data0放在N0节点上，Data1放在N1上，Data2放在N0上，依次类推……。&lt;/p&gt;

&lt;p&gt;这种方式实现起来非常容易，对于数字键，我们有：n = key mod N。其中，key为数据的键，N为节点的数量，n为存放数据的节点编号；对于那些非数字键，我们可以让其转变为数字键，比如通过某些hash函数，让键值均匀分布，于是有：n = f (key) mod N。&lt;/p&gt;

&lt;p&gt;这种方式有个缺点非常明显，不容易应对数据节点的变化，即不易进行二次切分。所谓二次分片是指，当数据的增长超过数据库容量时，需要增加数据库，或者系统故障导致某些数据库不能使用时，这时需要重新切分数据库。例如，有两个节点，N0和N1，现在需要增加一个节点N2，这时候，都需要吧N0上的数据和N1上的数据迁移到N2上，这个工作量是巨大的；并且可能导致上层应用对数据的改变，比如，之前数据Data5存储在N1上面，上层应用访问该数据时，根据key=5知道其存储在数据库N1里，那么便会在N1里查询数据，现在增加另外一个节点N2，那么这条数据被迁移到N2上了，上层应用就应该去N2上查询此数据了，这个看似简单，其实往往导致应用程序的复杂性很高。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;虚拟分片技术&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了保证二次分片时，避免对上层应用因为实际物理数据库发生改变而引起对数据访问逻辑的改变，中间加入了一个虚拟片段—物理片段映射表，数据对象存储在虚拟分片上，每个虚拟片段通过这个映射表找到相应的物理片段。这时间，上层应用依赖于虚拟分片，而非物理分片，只要保证虚拟片段足够多，就能避免上层应用的依赖。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;一致性Hash算法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了避免数据库数量发生变化，引起大规模的数据迁移问题，而引入了一致性Hash算法。此算法由David Karger等人发表于1997年，论文题目为《Consistent hashing and random trees: distributed caching protocols for relieving hot spots on the World Wide Web》，这里有一篇文章讲述Java语言简单实现一致性Hash算法http://weblogs.java.net/blog/&lt;sup&gt;2007&lt;/sup&gt;&amp;frasl;&lt;sub&gt;11&lt;/sub&gt;/27/consistent-hashing。&lt;/p&gt;

&lt;p&gt;一致性Hash算法的主要思想是不改变Hash函数本身，当减少节点时，临近的节点接手该节点，因此，消失节点上的数据迁移只迁移到临近节点上面；而增加节点时，只接手其临近的一个节点的部分数据，因此，只有一部分临近节点的数据被迁移至新加节点。&lt;/p&gt;

&lt;p&gt;我们来详细了解一下具体实现：我们的Hash函数生成的数据都有一个值区间[min，max]，我们把该区间用一个环来表示，每个节点的hash值都映射到这个环上，如下图所示：
&lt;img alt=&#34;&#34; src=&#34;http://dl.iteye.com/upload/attachment/0062/4379/3b3d6370-1d74-3e45-bcfb-71690491ec9e.jpg&#34; title=&#34;hash&#34; class=&#34;alignnone&#34; width=&#34;217&#34; height=&#34;217&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设我们的值区间是[1,12]，我们有三个节点，1，4，9，数据的键也映射到这个环上，a的键值介于1~4之间，则存储在节点4上，即按照顺时针方向存储数据，同样b存储于节点9，而c存储于节点1。&lt;/p&gt;

&lt;p&gt;假设节点4不可用时，那么数据a就会被迁移至节点9，其他节点的数据不发生迁移，如下图所示：
&lt;img alt=&#34;&#34; src=&#34;http://dl.iteye.com/upload/attachment/0062/4381/4a544aa8-179e-3ec6-ad14-e7d0e2aa5c7f.jpg&#34; title=&#34;hash&#34; class=&#34;alignnone&#34; width=&#34;217&#34; height=&#34;217&#34; /&gt;&lt;/p&gt;

&lt;p&gt;假设增加节点7，那么将把节点9上的部分数据迁移至节点7，其他节点数据不发生改变，如下图所示：
&lt;img alt=&#34;&#34; src=&#34;http://dl.iteye.com/upload/attachment/0062/4383/72445ae5-f9d3-3c95-9fb5-174b7bd31411.jpg&#34; title=&#34;hash&#34; class=&#34;alignnone&#34; width=&#34;217&#34; height=&#34;225&#34; /&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;按照数据的特点进行切分数据&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最常见的就是按照地理位置切分数据，那么我们按照用户的注册信息或者用户数据提交的ip地址等来把它们放置于离它们地理位置最近的数据库中。&lt;/p&gt;

&lt;p&gt;3.2 实际应用&lt;/p&gt;

&lt;p&gt;在真实的应用中，往往会结合这些策略，甚至提供更为抽象的接口让开发人员实现适合自己的切分方法。我们这里讲述Mongodb和Hibernate Shards的分片方式。&lt;/p&gt;

&lt;p&gt;3.2.1       Mongodb Sharding&lt;/p&gt;

&lt;p&gt;Mongo db是基于文档的NoSQL数据库，查询方式和关系数据库非常接近。&lt;/p&gt;

&lt;p&gt;Mongodb把数据存放在称为Chuncks数据结构上面，Chunck的默认大小是64M，每个Chunck上面存储一定切分范围的数据，当数据超过64M时，会自行分裂成两个Chunks，相当于一致性Hash算法添加了一个节点，只是这个节点不是DB。而每台物理db（称为Shard）上含有多个Chunks，为了达到更好的负载均衡，这些物理db上的Chunks会自动迁移，使得db上的Chunks发布均衡。&lt;/p&gt;

&lt;p&gt;3.2.2       Hibernate Shards&lt;/p&gt;

&lt;p&gt;Hibernate Shards是在Hibernate Core上做的一层扩展，目的是在关系数据库上封装和降低水平切分的复杂性。&lt;/p&gt;

&lt;p&gt;Hibernate Shards为开发者提供了抽象接口，开发人员可以实现自己想要的切分策略，为了避免物理数据库发生改变引起应用程序的改变，其采用虚拟分片技术。&lt;/p&gt;

&lt;p&gt;Hibernate Shards参考中文文档请参见：http://redhat.iteye.com/blog/328032&lt;/p&gt;

&lt;p&gt;3.3  应注意的问题&lt;/p&gt;

&lt;p&gt;水平切分数据库之后，会给查询造成一定的困难，特别是Aggregation查询。Mongodb采用Map/Reduce方式，能够比较高效进行Aggregation查询。&lt;/p&gt;

&lt;p&gt;4        总结&lt;/p&gt;

&lt;p&gt;对于大规模，可伸缩，海量数据的应用，数据切分是其架构必须考虑的一个重点内容，我们在进行数据切分时，往往采用先垂直，再水平方式对数据分片。&lt;/p&gt;

&lt;p&gt;摘自：http://blog.csdn.net/co0der/article/details/7217974&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Bangkok春节游</title>
      <link>http://blog.prosight.me/blogs/876</link>
      <pubDate>2012-01-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;趁着春节长假，抽空走马观花看了两个东盟邻国。
24号清晨坐上开往机场的MRT，中午时分到达曼谷。&lt;/p&gt;

&lt;p&gt;“曼谷”（Bangkok）是泰国首都，东南亚第二大城市，主要港口和政治、经济、文化中心，被誉为是“佛教之都”。这是一个充满矛盾的地方。一方面，作为东南亚第二大城市，曼谷高楼林立，轻轨和高架桥在钢铁丛林间蜿蜒，商务区的白领步履匆忙，一面抱怨着高峰时段的交通堵塞，一面筹划着周末的欢乐时光；另一方面，数以千计的大小寺庙仍然遍布街头巷尾、高楼大厦间，仍然深深影响着每个人的世俗生活和精神世界，使它无愧为“黄袍佛国”的首都。这里的人仍旧谦和友善，并且不吝以最直白的方式——黄衫——来表达对国王的衷心爱戴。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp2orOX/medium.jpg&#34; title=&#34;wat&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;281&#34; /&gt;
入住酒店Bhiman Inn旁边的泰国小寺庙&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp2Xdly/medium.jpg&#34; title=&#34;湄南河&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
走到湄南河边&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp3g1it/medium.jpg&#34; title=&#34;大王宫&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp4UgXU/medium.jpg&#34; title=&#34;湄南河&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp4GQfS/medium.jpg&#34; title=&#34;湄南河&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp56sbn/medium.jpg&#34; title=&#34;湄南河&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp5ufz6/medium.jpg&#34; title=&#34;湄南河&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
湄南河又名昭披耶河，是泰国河流中水量最大、长度最长的河流，有泰国“河流之母”之称。湄南河全长1352千米，纵穿泰国东南部，流经大城，贯穿曼谷市区，在城市交通运输及岸边居民生活中扮演着重要角色。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp5F4m1/medium.jpg&#34; title=&#34;湄南河&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
这个就是在湄南河上穿梭的水上公交车&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp6MsOQ/medium.jpg&#34; title=&#34;downtown&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp6XjMW/medium.jpg&#34; title=&#34;mbk&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
曼谷Downtown，车水马龙啊。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp9p6dV/medium.jpg&#34; title=&#34;大王宫&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHp9d51c/medium.jpg&#34; title=&#34;大王宫&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
大王宫始建于1782年，紧偎湄南河的大王宫位于曼谷市中心，占地22万平方米。这里共有22座错落分布的古建筑群，汇集了泰国建筑、绘画、雕刻和园林艺术的精粹，是泰国曼谷王朝一世王至八世王的王宫，又称“大皇宫”或者“故宫”，也是曼谷保存最完美、最壮观、规模最大、最有民族特色的王宫。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHpdPgTx/medium.jpg&#34; title=&#34;黎明寺&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;340&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHpe9fLF/medium.jpg&#34; title=&#34;黎明寺&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
郑王庙（又称黎明寺）是泰国皇家寺庙之一，通称郑王寺。始建于大城王朝，当时名皇冠寺，后改称昌寺。郑王庙是纪念泰国第41代君王、民族英雄郑昭的寺庙。郑昭是华裔，于1768年，曾领导泰国各族人民奋驱外敌，重整江山，建立了吞武里王国。&lt;/p&gt;

&lt;p&gt;郑王庙又名黎明寺，据说郑王驱逐缅甸军队后，顺湄南河经过此寺时正好是黎明时刻，便下令上岸到寺里参拜，后来登上王位后便称此寺为黎明寺。另一个说法是高79米的高塔每天最先接触到阳光，所以称之为黎明寺。&lt;/p&gt;

&lt;p&gt;曼谷之前听说有恐怖袭击，但是去了之后，发现治安很好，甚至好过北京。物价又比北京上海便宜，特别是所有商品标签都除以5，感觉很爽。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Singapore春节游</title>
      <link>http://blog.prosight.me/blogs/852</link>
      <pubDate>2012-01-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;趁着春节长假，抽空走马观花看了两个东盟邻国。
腊月二十八在首都机场登上午夜的航班，经过近7个小时的飞行，在早上9点到达新加坡。新加坡是一个汇聚了现代与传统的风格特色，融合东西文化之精粹。在这里，可以感受华人文化、马来文化及印度文化等多元民族特色。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHnNR48G/medium.jpg&#34; title=&#34;鱼尾狮&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
鱼尾狮(The Merlion)是新加坡的旅游标志,是新加坡最高的自由式结构建筑。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHnYEZrK/medium.jpg&#34; title=&#34;莱佛士酒店(Raffles Hotel)&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
莱佛士大酒店(Raffles Hotel)是新加坡地标性建筑，在1887年由来自于亚美尼亚的富豪薛克兹兄弟修建。从那时起，这座代表新加坡殖民地时期建筑风格的酒店便吸引了大量游客。毛姆、吉卜林、卓别林等人都曾在此下榻。1987年新加坡政府将这家酒店列为国家历史文物，并在1991年斥资1600万新币翻新。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHo12vs7/medish.jpg&#34; title=&#34;新加坡和平纪念碑(Civilian War Memorial)&#34; class=&#34;alignnone&#34; width=&#34;427&#34; height=&#34;640&#34; /&gt;
新加坡和平纪念碑(Civilian War Memorial)位于美芝路纪念公园，象征新加坡四大种族在二战期间（1942年2月15日至1945年9月12日）共同挣扎求存的精神。同时也悼念在二次大战日军占领新加坡期间死难的平民。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHo35bNl/medish.jpg&#34; title=&#34;圣安德烈教堂(St.Andrew&amp;#039;s Cathedral)&#34; class=&#34;alignnone&#34; width=&#34;427&#34; height=&#34;640&#34; /&gt;
圣安德烈教堂(St.Andrew&amp;rsquo;s Cathedral)位于哥里门街，1862年由隆纳德·麦克佛逊上校设计并兴建，用以代替早先为纪念史丹福·莱佛士爵士所建的旧教堂。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHocKDK9/medium.jpg&#34; title=&#34;新加坡河&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHoeoqxY/medium.jpg&#34; title=&#34;新加坡河畔&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHnOfayS/medium.jpg&#34; title=&#34;新加坡河畔&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
贯穿于整个城市的新加坡河是新加坡的生命之河，早期移民都是依靠这条河流来维持生计。漫步在河畔，您可以参观许多富纪念性的标志和建筑如鱼尾狮公园、莱佛士登岸遗址和旧国会大厦艺术之家，宗教机构如奥马清真寺、保赤宫，还有驳船码头、克拉码头等繁华的街区。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHnOoUO7/medium.jpg&#34; title=&#34;滨海艺术中心(Esplanade:Theatre on the Bay) &#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
滨海艺术中心是新加坡首屈一指的艺术表演场地。造型独特的圆顶为它赢得了“榴莲”的称号。滨海艺术中心毗邻滨海湾，艺术中心内有音乐厅、剧院、演奏厅和排练室，还有户外表演空间。此外，这里还有购物中心、国际风味餐馆及新加坡首家艺术图书馆——滨海艺术中心图书馆，馆内收藏了大量关于音乐、舞蹈、电影和戏剧的书籍和多媒体资料。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHnPqs6Q/medium.jpg&#34; title=&#34;滨海湾&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
滨海湾夜景&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHnUWBEZ/medium.jpg&#34; title=&#34;小印度&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHnRQgwR/medish.jpg&#34; title=&#34;小印度&#34; class=&#34;alignnone&#34; width=&#34;427&#34; height=&#34;640&#34; /&gt;
小印度是新加坡印度族群的聚集地，犹如印度的缩影。在屠妖节（Deepavali），即兴都教光节（HinduFestivalofLights），小印度被装点成金碧辉煌的神话世界。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHnVSUF4/medish.jpg&#34; title=&#34;阿拉伯街&#34; class=&#34;alignnone&#34; width=&#34;427&#34; height=&#34;640&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BHnW46To/medium.jpg&#34; title=&#34;阿拉伯街&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;334&#34; /&gt;
甘榜格南是以生长在沼泽地周围的树木“gelam”树为名的，是新加坡穆斯林的聚居区。&lt;/p&gt;

&lt;p&gt;新加坡真的很干净，一尘不染。天气跟北方的夏天一样热，每天30多度，但是一个苍蝇蚊子都没有。令人敬佩。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>分布式文件系统MFS、Ceph、GlusterFS、Lustre的比较</title>
      <link>http://blog.prosight.me/blogs/848</link>
      <pubDate>2011-12-29 12:00:00 +0800</pubDate>
      <description>&lt;table border=&#34;1&#34; cellspacing=&#34;0&#34; cellpadding=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;**MooseFS(MFS)**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;**Ceph**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;**GlusterFS**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;**Lustre**&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**Metadata server**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;单个MDS。存在单点故障和瓶颈。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;多个MDS，不存在单点故障和瓶颈。MDS可以扩展，不存在瓶颈。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;无，不存在单点故障。靠运行在各个节点上的动态算法来代替MDS,不需同步元数据,无硬盘I/O瓶颈。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;双MDS(互相备份)。MDS不可以扩展，存在瓶颈。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**FUSE**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;支持&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;支持&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;支持&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**访问接口**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;POSIX&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;POSIX&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;POSIX&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;POSIX/MPI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**文件分布/数据分布**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;文件被分片，数据块保存在不同的存储服务器上。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;文件被分片，每个数据块是一个对象。对象保存在不同的存储服务器上。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;Cluster Translators(GlusterFS集群存储的核心)包括AFR、DHT（和Stripe三种类型。

AFR相当于RAID1，每个文件都被复制到多个存储节点上。Stripe相当于RAID0，文件被分片，数据被条带化到各个存储节点上。

Translators可以组合，即AFR和stripe可以组成RAID10，实现高性能和高可用。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;可以把大文件分片并以类似RAID0的方式分散存储在多个存储节点上。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**冗余保护/副本**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;多副本&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;多副本&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;镜像&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**数据可靠性**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;由数据的多副本提供可靠性。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;由数据的多副本提供可靠性。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;由镜像提供可靠性。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;由存储节点上的RAID1或RAID5/6提供可靠性。假如存储节点失效，则数据不可用。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**备份**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;&amp;nbsp;&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;提供备份工具。支持远程备份。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**故障恢复**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;手动恢复&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;当节点失效时，自动迁移数据、重新复制副本。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;当节点、硬件、磁盘、网络发生故障时，系统会自动处理这些故障，管理员不需介入。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**扩展性**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;增加存储服务器，可以提高容量和文件操作性能。但是由于不能增加MDS，因此元数据操作性能不能提高，是整个系统的瓶颈。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;可以增加元数据服务器和存储节点。容量可扩展。文件操作性能可扩展。元数据操作性能可扩展。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;容量可扩展。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;可增加存储节点，提高容量可文件操作性能，但是由于不能增加MDS，因此元数据操作性能不能提高，是整个系统的瓶颈。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**安装/部署**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;简单&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;简单&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;简单&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;复杂。而且Lustre严重依赖内核，需要重新编译内核。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**开发语言**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;C&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;C++&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;C&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;C&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**适合场景**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;大量小文件读写&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;小文件&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;&lt;a name=&#34;_Toc288579612&#34;&gt;&lt;/a&gt;&lt;a name=&#34;_Toc288579827&#34;&gt;&lt;/a&gt;&lt;a name=&#34;_Toc288579902&#34;&gt;&lt;/a&gt;&lt;a name=&#34;_Toc288580250&#34;&gt;&lt;/a&gt;适合大文件。

&lt;a name=&#34;_Toc288580250&#34;&gt;&lt;/a&gt;对于小文件，无元数据服务设计解决了元数据的问题。但GlusterFS并没有在I/O方面作优化，在存储服务器底层文件系统上仍然是大量小文件，本地文件系统元数据访问是瓶颈，数据分布和并行性也无法充分发挥作用。因此，GlusterFS的小文件性能还存在很大优化空间。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;大文件读写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**产品级别**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;小型&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;中型&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;中型&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;重型&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**应用**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;国内较多&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;无&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;较多用户使用&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;HPC领域。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign=&#34;top&#34;&gt;**优缺点**&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;实施简单，但是存在单点故障。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;不稳定，目前还在实验阶段，不适合于生产环境。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;无元数据服务器，堆栈式架构(基本功能模块可以进行堆栈式组合，实现强大功能)。具有线性横向扩展能力。

&amp;nbsp;

由于没有元数据服务器，因此增加了客户端的负载，占用相当的CPU和内存。

但遍历文件目录时，则实现较为复杂和低效，需要搜索所有的存储节点。因此不建议使用较深的路径。&lt;/td&gt;
&lt;td valign=&#34;top&#34;&gt;很成熟、很庞大。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;摘自&lt;a href=&#34;http://blog.csdn.net/metaxen/article/details/7108958&#34; title=&#34;存储实验室&#34; target=&#34;_blank&#34;&gt;存储实验室&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>晨@北京</title>
      <link>http://blog.prosight.me/blogs/842</link>
      <pubDate>2011-12-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;清晨起来，眺望窗外……&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BAGkYXoi/medium.jpg&#34; title=&#34;晨&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;373&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BAGkYpza/medium.jpg&#34; title=&#34;晨&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;373&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>基于位置的实时游戏MapAttack的技术实现</title>
      <link>http://blog.prosight.me/blogs/832</link>
      <pubDate>2011-10-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;MapAttack是一款实时的，基于地理位置的游戏，其通过Socket.io，node.js，和Redis实现了其实时性。下面文章对整个游戏及其技术实现进行了描述，推荐给大家。&lt;/p&gt;

&lt;p&gt;这里我将向大家表述我们如何利用Socket.io、Redis、Node.js以及一路上我们所学的东西来规划、开发并测试一款实时的、基于位置的游戏。在过去的几个月中，我们将大部分的空闲时间都用在了开发一款实时游戏上，由于它是基于地图环境的，所以我们称之为“MapAttack！”，并把它作为我们LBS平台Geoloqi的一个测试程序。游戏中，两组队员互相竞争，尽可能多的攻占游戏界面上的小圆圈。而在这里，游戏界面其实就是城市中玩家周围的街道。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.lbsvision.com/wp-content/uploads/2011/10/MapAttack-1.jpg&#34; title=&#34;MapAttack&#34; class=&#34;alignnone&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Geofence在这里指地图上带有数字的小圆圈，玩家进入这些小圆圈后，就会得到与圆圈中所标记数字相同的分数，它所在小组的总分数也会相应增加，同时圆圈的颜色会变成该玩家小组的颜色。&lt;/p&gt;

&lt;h3&gt;为什么要开发这么一款实时Geofencing游戏呢？&lt;/h3&gt;

&lt;p&gt;我们想要创造一款游戏，它能够让人们与真实世界物理交互，而不是像第一人称射击游戏或者即时战略游戏那样通过电脑控制台来交互。同时，我们也是受到了真人版吃豆人（PacManhattan）的启发。
技术挑战&lt;/p&gt;

&lt;h3&gt;处理用户进入区域的检测，同时留出200+的小圆圈。&lt;/h3&gt;

&lt;p&gt;处理一局游戏中所有手机位置信息的更新量（一局游戏有20或者更多用户）。
允许每台手机或者观看游戏的Web浏览器都能实时地看到玩家们的移动和圆圈颜色的改变。每台手机都会将它的位置发送给服务器，服务器会广播这些位置数据给其他手机以及观看游戏的浏览器。
处理GPS技术在不同智能手机模型间的错误和差异以保证游戏的公平体验。&lt;/p&gt;

&lt;h3&gt;GPS硬件的差异&lt;/h3&gt;

&lt;p&gt;众所周知，GPS信号反映了城市中高层建筑的情况。这就导致了在位置数据方面的不准确和不一致。这点在新手机上并不显著，但是在较老的手机上却十分明显。
&lt;img alt=&#34;&#34; src=&#34;http://www.lbsvision.com/wp-content/uploads/2011/10/geoloqi-gps-comparison-iphone-3gs-41.jpg&#34; title=&#34;GPS&#34; class=&#34;alignnone&#34; /&gt;&lt;/p&gt;

&lt;p&gt;MapAttack架构图
&lt;img alt=&#34;&#34; src=&#34;http://www.lbsvision.com/wp-content/uploads/2011/10/mapattack-phone-server-architecture-geoloqi.png&#34; title=&#34;structure&#34; class=&#34;alignnone&#34; /&gt;&lt;/p&gt;

&lt;h3&gt;Socket.io&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://socket.io/&#34;&gt;Socket.io&lt;/a&gt;是一个跨浏览器的Web套接字实现，它允许在浏览器上做实时数据更新，并且也支持老的浏览器。多亏了Socket.io我们可以利用最新的技术，同时不用要求所有我们的用户升级到最新的浏览器。这让我们实现了游戏中浏览器和手机间的即时更新。&lt;/p&gt;

&lt;h3&gt;Node.js&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://nodejs.org/&#34;&gt;Node.js&lt;/a&gt;是谷歌浏览器的V8 Javascript引擎事件驱动的I/O实现，它由一个反应器实现，而这个反应器使得大量异步数据的传输得以实现。
当手机要发送数据时，我们用一个Node.js服务器将位置数据流从手机传输到Redis的发布频道或者订阅频道上。数据发布到Redis上，另一个Node服务器订阅该频道。我们的Node.js服务器接收手机通过一个类似Google’s Protocol Buffers的顾客协议发来的更新，实际上就是压缩的二进制的JSON。
当一个浏览器想要开始发送数据流时，它连接Socket.io服务器然后这个服务器订阅Redis的发布频道或订阅频道。这个Socket.io服务器通过Websockets向浏览器发送数据，如果Websockets不可用，闪回或者长轮询作为后备方式。
本质上讲，Socket.io允许我们使用Websockets规范，这是全新的，但同时也能工作在较老的浏览器上。&lt;/p&gt;

&lt;h3&gt;Redis&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://redis.io/&#34;&gt;Redis&lt;/a&gt;是一个开源的、高级key-value存储系统，它支持消息队列使用发布/订阅模式。
从较高层次来说，Redis让我们所能做的事，是控制把数据实时发送到所有游戏中的手机和浏览器。游戏中的每一台手机把它的位置发送给服务器，服务器广播这些数据给其它手机和正在观看游戏的浏览器。
关于发布/订阅系统的一件吸引人的事：使用一个传统的系统你不得不维持许多连接，并且为了通过连接发送数据，你不得不重复发送，与发布/订阅系统不同，如果你有10,000个用户，你将不得不重复通过10,000个连接，发送回非常缓慢，并且容易出现死锁在套接字上的问题。&lt;/p&gt;

&lt;p&gt;使用Redis的发布/订阅模式，就像启动一个广播电台。一旦把它打开了，人们（在这里指的是浏览器）就可以收听。这让我们能够把实时数据大规模地更新给客户端（浏览器和手机）。&lt;/p&gt;

&lt;h3&gt;Sinatra Synchrony&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://kyledrake.net/sinatra-synchrony/&#34;&gt;Sinatra::Synchrony&lt;/a&gt;是Sinatra的一个小扩展，它动态提升了Sinatra网络应用的并发性。由于EventMachine和EM-Synchrony的支持，当你有很多传输和低速IO请求时（如向外部APIs发送的HTTP请求），它增加了你的应用每个过程可服务的客户的数量。由于它内部使用Fibers处理堵塞的IO，所以没有回调的需要。这意味着我们可以像写一个正常的Sinatra网络应用那样进行开发。&lt;/p&gt;

&lt;p&gt;Sinatra::Synchrony允许我们做异步程序，除了那些在Fibers中封装了回调操作的。这让我们能够实现同步程序的同时利用异步代码的优势。除了可以这样简单地变成，它也让我们根据需要可以转换一个不同的并发策略。&lt;/p&gt;

&lt;h3&gt;The MapAttack Game Server&lt;/h3&gt;

&lt;p&gt;最后，有一个MapAttack游戏的服务器，在这里，这个游戏服务器是一个简单的数据库，他负责存储玩家在地图上显示的所在点的数据，以及手机上玩家需要实时去抢夺的点的数据。&lt;/p&gt;

&lt;p&gt;英文原文：&lt;a href=&#34;blog.programmableweb.com&#34;&gt;blog.programmableweb.com&lt;/a&gt;
译文出处：&lt;a href=&#34;www.lbsvision.com&#34;&gt;www.lbsvision.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>大美长白</title>
      <link>http://blog.prosight.me/blogs/817</link>
      <pubDate>2011-10-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;十一假期抽空来了趟短途游，去了中朝边境的长白山。&lt;/p&gt;

&lt;blockquote&gt;长白山，位于吉林省延边州安图县和白山市抚松县境内，是中朝两国的界山、中华十大名山之一、国家5A级风景区、关东第一山。因其主峰多白色浮石与积雪而得名，素有“千年积雪为年松，直上人间第一峰”的美誉。中国境内的白云峰海拔高度2691米，是东北第一高峰，而长白山最高峰是位于朝鲜境内的将军峰。长白山是中国东北境内海拔最高、喷口最大的火山体。长白山还有一个美好的寓意“长相守、到白头”。&lt;/blockquote&gt;

&lt;p&gt;10月1日从北京出发，10月5日返回。历程2600多公里，跨越河北，天津，辽宁，吉林。中朝边境的S303省道是这次旅程中风景最好的一段线路。
&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyMnaXP/medium.jpg&#34; title=&#34;route&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;195&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最美的风景都在路上
&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/Bqyyd767/medium.jpg&#34; title=&#34;去往抚松松江河镇的路上&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;266&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyysHLi/medium.jpg&#34; title=&#34;去往松江河镇的路上&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyyGmLK/medium.jpg&#34; title=&#34;最美的风景在路上&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyznYcO/medium.jpg&#34; title=&#34;最美的风景在路上&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最美的风景貌似都在朝鲜那边，栅栏对面就是朝鲜人民主义共和国
&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyAyXcb/medium.jpg&#34; title=&#34;长白山&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;317&#34; /&gt;&lt;/p&gt;

&lt;p&gt;天池边远眺
&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyAJeIi/medium.jpg&#34; title=&#34;长白山&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;最美天池
&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyASWzP/medium.jpg&#34; title=&#34;长白山&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;S303省道边的白桦林
&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyE3T8r/medium.jpg&#34; title=&#34;长白山&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;下面这条小河就是著名的鸭绿江，河对面就是朝鲜。想偷渡到朝鲜的，趟河过去就好了
&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyFxB0G/medium.jpg&#34; title=&#34;长白山&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;随着往下游走，河面渐宽
&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyI6kKa/medium.jpg&#34; title=&#34;长白山&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyIlpIi/medium.jpg&#34; title=&#34;长白山&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BqyIMlz0/medium.jpg&#34; title=&#34;长白山&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>夜@什刹海</title>
      <link>http://blog.prosight.me/blogs/810</link>
      <pubDate>2011-09-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BovkbhE4/medium.jpg&#34; title=&#34;什刹海&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BovjbsPh/medium.jpg&#34; title=&#34;什刹海&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;335&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BovjRo34/medium.jpg&#34; title=&#34;什刹海&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/Bovk1UsA/medium.jpg&#34; title=&#34;什刹海&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;318&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BovkQX7B/medium.jpg&#34; title=&#34;什刹海&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://pic.yupoo.com/eltonzheng/BovljO2I/medium.jpg&#34; title=&#34;什刹海&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用rvm在Mac中安装ruby和rails</title>
      <link>http://blog.prosight.me/blogs/805</link>
      <pubDate>2011-09-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;MacOS默认安装的是ruby 1.8.7，如果你想使用ruby 1.9.2的话，除了在官网下载源码编译安装外，可以使用rvm来协助安装。&lt;/p&gt;

&lt;h3&gt;STEP-1 安装RVM&lt;/h3&gt;

&lt;p&gt;在Terminal中输入以下命令即可安装
&lt;pre class=&#34;prettyprint linenums&#34;&gt;bash &amp;lt; &amp;lt;(curl -s &lt;a href=&#34;https://rvm.beginrescueend.com/install/rvm)&amp;lt;/pre&amp;gt;&#34;&gt;https://rvm.beginrescueend.com/install/rvm)&amp;lt;/pre&amp;gt;&lt;/a&gt;
为了可以在shell中使用，需要在.bash_profile中输入以下命令
&lt;pre class=&#34;prettyprint linenums&#34;&gt;cd ~/
sudo vim .bash_profile&lt;/p&gt;

&lt;p&gt;#在.bash_profile中加入
[[ -s &amp;ldquo;$HOME/.rvm/scripts/rvm&amp;rdquo; ]] &amp;amp;&amp;amp; source &amp;ldquo;$HOME/.rvm/scripts/rvm&amp;rdquo;  # This loads RVM into a shell session.&lt;/pre&gt;
之后退出Terminal，重启它。&lt;/p&gt;

&lt;h3&gt;STEP-2 安装Ruby&lt;/h3&gt;

&lt;p&gt;使用以下命令，可以看到rvm可以支持安装的内容
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ rvm list known&lt;/p&gt;

&lt;h1&gt;MRI Rubies&lt;/h1&gt;

&lt;p&gt;1.8.6[-p420]
1.8.6-head
1.8.7[-p352]
1.8.7-head
1.9.1-p378
1.9.1[-p431]
1.9.1-head
1.9.2-p180
1.9.2[-p290]
1.9.2-head
ruby-head
&amp;hellip;
&lt;/pre&gt;
使用下面的命令安装ruby 1.9.2
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
rvm install 1.9.2
&lt;/pre&gt;
然后使用下面命令，让系统使用新的ruby
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$rvm use 1.9.2
Using /Users/elton/.rvm/gems/ruby-1.9.2-p290
$ruby -v
ruby 1.9.2p290 (2011-07-09 revision 32553) [x86_64-darwin11.1.0]
&lt;/pre&gt;
当你重启机器后，你会发现又回复成了1.8.7了，可以使用下面命令，让系统默认使用1.9.2
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
rvm &amp;ndash;default use 1.9.2
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;STEP-3 安装Rails&lt;/h3&gt;

&lt;p&gt;这步很简单
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
gem install rails
&lt;/pre&gt;
之后就可以使用最新的ruby和rails了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Redis中7种集合类型应用场景</title>
      <link>http://blog.prosight.me/blogs/802</link>
      <pubDate>2011-08-30 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;Strings&lt;/h3&gt;

&lt;p&gt;Strings 数据结构是简单的key-value类型，value其实不仅是String，也可以是数字。使用Strings类型，你可以完全实现目前 Memcached 的功能，并且效率更高。还可以享受Redis的定时持久化，操作日志及 Replication等功能。除了提供与 Memcached 一样的get、set、incr、decr 等操作外，Redis还提供了下面一些操作：
&lt;ul&gt;
    &lt;li&gt;获取字符串长度&lt;/li&gt;
    &lt;li&gt;往字符串append内容&lt;/li&gt;
    &lt;li&gt;设置和获取字符串的某一段内容&lt;/li&gt;
    &lt;li&gt;设置及获取字符串的某一位（bit）&lt;/li&gt;
    &lt;li&gt;批量设置一系列字符串的内容&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;

&lt;h3&gt;Hashs&lt;/h3&gt;

&lt;p&gt;在Memcached中，我们经常将一些结构化的信息打包成hashmap，在客户端序列化后存储为一个字符串的值，比如用户的昵称、年龄、性别、积分等，这时候在需要修改其中某一项时，通常需要将所有值取出反序列化后，修改某一项的值，再序列化存储回去。这样不仅增大了开销，也不适用于一些可能并发操作的场合（比如两个并发的操作都需要修改积分）。而Redis的Hash结构可以使你像在数据库中Update一个属性一样只修改某一项属性值。&lt;/p&gt;

&lt;h3&gt;Lists&lt;/h3&gt;

&lt;p&gt;Lists 就是链表，相信略有数据结构知识的人都应该能理解其结构。使用Lists结构，我们可以轻松地实现最新消息排行等功能。Lists的另一个应用就是消息队列，可以利用Lists的PUSH操作，将任务存在Lists中，然后工作线程再用POP操作将任务取出进行执行。Redis还提供了操作Lists中某一段的api，你可以直接查询，删除Lists中某一段的元素。&lt;/p&gt;

&lt;h3&gt;Sets&lt;/h3&gt;

&lt;p&gt;Sets 就是一个集合，集合的概念就是一堆不重复值的组合。利用Redis提供的Sets数据结构，可以存储一些集合性的数据，比如在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis还为集合提供了求交集、并集、差集等操作，可以非常方便的实现如共同关注、共同喜好、二度好友等功能，对上面的所有集合操作，你还可以使用不同的&lt;a title=&#34;查看 命令 的全部文章&#34; href=&#34;http://blog.nosqlfan.com/tags/%e5%91%bd%e4%bb%a4&#34; target=&#34;_blank&#34;&gt;命令&lt;/a&gt;选择将结果返回给客户端还是存集到一个新的集合中。&lt;/p&gt;

&lt;h3&gt;Sorted Sets&lt;/h3&gt;

&lt;p&gt;和Sets相比，Sorted Sets增加了一个权重参数score，使得集合中的元素能够按score进行有序排列，比如一个存储全班同学成绩的Sorted Sets，其集合value可以是同学的学号，而score就可以是其考试得分，这样在数据插入集合的时候，就已经进行了天然的排序。另外还可以用Sorted Sets来做带权重的队列，比如普通消息的score为1，重要消息的score为2，然后工作线程可以选择按score的倒序来获取工作任务。让重要的任务优先执行。&lt;/p&gt;

&lt;h3&gt;Pub/Sub&lt;/h3&gt;

&lt;p&gt;Pub/Sub 从字面上理解就是发布（Publish）与订阅（Subscribe），在Redis中，你可以设定对某一个key值进行消息发布及消息订阅，当一个key值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统，比如普通的即时聊天，群聊等功能。&lt;/p&gt;

&lt;h3&gt;Transactions&lt;/h3&gt;

&lt;p&gt;谁说NoSQL都不支持事务，虽然Redis的Transactions提供的并不是严格的ACID的事务（比如一串用EXEC提交执行的命令，在执行中服务器宕机，那么会有一部分命令执行了，剩下的没执行），但是这个Transactions还是提供了基本的命令打包执行的功能（在服务器不出问题的情况下，可以保证一连串的命令是顺序在一起执行的，中间有会有其它客户端命令插进来执行）。Redis还提供了一个Watch功能，你可以对一个key进行Watch，然后再执行Transactions，在这过程中，如果这个Watched的值进行了修改，那么这个Transactions会发现并拒绝执行。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>阻止iOS设备锁屏</title>
      <link>http://blog.prosight.me/blogs/800</link>
      <pubDate>2011-08-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;默认，所有iOS设备在过了设定的休眠时间后，都会自动锁屏。 如果你的应用不希望iOS设备自动锁屏，可以使用以下方式来保持屏幕一直开着。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
// Disable the idle timer
[[UIApplication sharedApplication] setIdleTimerDisabled: YES];
 
// Or for those who prefer dot syntax:
[UIApplication sharedApplication].idleTimerDisabled = YES;
&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>为自己的网站实现Heatmap</title>
      <link>http://blog.prosight.me/blogs/795</link>
      <pubDate>2011-08-20 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Heatmap，已经有网站提供此类服务，如：&lt;a href=&#34;http://www.clickdensity.com/&#34; target=&#34;_blank&#34;&gt;clickdensity&lt;/a&gt;，&lt;a href=&#34;http://www.clicktale.com/&#34; target=&#34;_blank&#34;&gt;clicktale&lt;/a&gt;，&lt;a href=&#34;http://www.crazyegg.com/&#34; target=&#34;_blank&#34;&gt;crazyegg&lt;/a&gt;等等，甚至还有类似&lt;a href=&#34;http://www.labsmedia.com/clickheat/index.html&#34; target=&#34;_blank&#34;&gt;clickheat&lt;/a&gt;项目提供源代码供你直接使用。&lt;/p&gt;

&lt;p&gt;不过最灵活的方案莫过于自己搞定，下面大概说说Heatmap的实现：&lt;/p&gt;

&lt;h2&gt;捕捉点击&lt;/h2&gt;

&lt;p&gt;当然，这需要Javascript来实现。为了不陷入浏览器兼容的泥潭，我们选择JQuery：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;script&gt;&lt;/p&gt;

&lt;p&gt;jQuery(document).ready(function() {
    $(document).mousedown(function(e) {
        if (e.clientX &amp;gt;= $(window).width() || e.clientY &amp;gt;= $(window).height()) {
            return;
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $.get(&amp;quot;/path/to/a/empty/html/file&amp;quot;, {
        page_x       : e.pageX,
        page_y       : e.pageY,
        screen_width : screen.width,
        screen_height: screen.height
    });
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;});&lt;/p&gt;

&lt;p&gt;&lt;/script&gt;&lt;/pre&gt;
客户端使用Ajax通过GET方法触发一个空HTML页面，当然，还可以更简单点：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;script&gt;&lt;/p&gt;

&lt;p&gt;var image = new Image();
image.src = &amp;ldquo;&amp;hellip;&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;&lt;/script&gt;&lt;/pre&gt;
之所以要记录屏幕分辨率是因为有的情况下需要修正点击坐标。比如说，一个居中显示的定宽的页面，其同一个位置在不同分辨率下的坐标是不同的，当渲染图片的时候，坐标需要以一个分辨率为准进行修正。&lt;/p&gt;

&lt;p&gt;另外，如果用户正在拖动滚动条，是不应该记录的。&lt;/p&gt;

&lt;h2&gt;分析日志&lt;/h2&gt;

&lt;p&gt;客户端使用Ajax通过GET方法触发一个空HTML页面，如此就会在服务端留下日志：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;page_x=&amp;hellip;&amp;amp;page_y=&amp;hellip;&amp;amp;screen_width=&amp;hellip;&amp;amp;screen_height=&amp;hellip;&lt;/pre&gt;
不同的日志格式，结果会有所不同，这里仅仅以此为例来说明问题，本文采用AWK来解析日志，当然你也可以使用Perl或别的你熟悉的语言：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;#!/usr/bin/awk -f&lt;/p&gt;

&lt;p&gt;BEGIN {
    FS=&amp;rdquo;&amp;amp;&amp;rdquo;;
}&lt;/p&gt;

&lt;p&gt;NF == 4 {
    param[&amp;ldquo;page_x&amp;rdquo;]        = &amp;ldquo;0&amp;rdquo;;
    param[&amp;ldquo;page_y&amp;rdquo;]        = &amp;ldquo;0&amp;rdquo;;
    param[&amp;ldquo;screen_width&amp;rdquo;]  = &amp;ldquo;0&amp;rdquo;;
    param[&amp;ldquo;screen_height&amp;rdquo;] = &amp;ldquo;0&amp;rdquo;;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;split($0, query, &amp;quot;&amp;amp;amp;&amp;quot;);

for (key in query) {
    split(query[key], item, &amp;quot;=&amp;quot;);
    if (item[1] in param) {
            param[item[1]] = item[2];
    }
}

print &amp;quot;page_x:&amp;quot;       , param[&amp;quot;page_x&amp;quot;];
print &amp;quot;page_y:&amp;quot;       , param[&amp;quot;page_y&amp;quot;];
print &amp;quot;screen_width:&amp;quot; , param[&amp;quot;screen_width&amp;quot;];
print &amp;quot;screen_height:&amp;quot;, param[&amp;quot;screen_height&amp;quot;];

print &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/pre&gt;
至于数据的持久化，是使用MongoDB或者别的，自己定夺，这里就不多说了。&lt;/p&gt;

&lt;h2&gt;渲染图片&lt;/h2&gt;

&lt;p&gt;出于演示方便的考虑，我使用了一些随机生成的数据，以Imagick为例，代码如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&amp;lt;?php&lt;/p&gt;

&lt;p&gt;$coordinates = array();&lt;/p&gt;

&lt;p&gt;for ($i = 0; $i &amp;lt; 1000; $i++) {
    $coordinates[] = array(rand($i, 1000), rand($i, 1000));
}&lt;/p&gt;

&lt;p&gt;$max_repeat = max(
    array_count_values(
        array_map(function($v) { return &amp;ldquo;{$v[0]}x{$v[1]}&amp;ldquo;; }, $coordinates)
    )
);&lt;/p&gt;

&lt;p&gt;$opacity = 1 - 1 / $max_repeat;&lt;/p&gt;

&lt;p&gt;$heatmap_image = new Imagick();&lt;/p&gt;

&lt;p&gt;$heatmap_image-&amp;gt;newImage(1000, 1000, new ImagickPixel(&amp;lsquo;white&amp;rsquo;));
$heatmap_image-&amp;gt;setImageFormat(&amp;lsquo;png&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;$plot_image = new Imagick(&amp;lsquo;plot.png&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;$iterator = $plot_image-&amp;gt;getPixelIterator();
foreach($iterator as $row) {
    foreach ($row as $pixel) {
        $colors = $pixel-&amp;gt;getColor();
        foreach (array(&amp;lsquo;r&amp;rsquo;, &amp;lsquo;g&amp;rsquo;, &amp;lsquo;b&amp;rsquo;) as $channel) {
            $color = $colors[$channel];
            if ($color !== 255) {
                $colors[$channel] = $color + ((255 - $color) * $opacity);
            }
        }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $pixel-&amp;amp;gt;setColor(&amp;quot;rgb({$colors[&#39;r&#39;]},{$colors[&#39;g&#39;]},{$colors[&#39;b&#39;]})&amp;quot;);
}

$iterator-&amp;amp;gt;syncIterator();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;$plot_size = $plot_image-&amp;gt;getImageGeometry();&lt;/p&gt;

&lt;p&gt;foreach ($coordinates as $pair) {
    $heatmap_image-&amp;gt;compositeImage(
        $plot_image,
        Imagick::COMPOSITE_MULTIPLY,
        $pair[0] - $plot_size[&amp;lsquo;width&amp;rsquo;] / 2,
        $pair[1] - $plot_size[&amp;lsquo;height&amp;rsquo;] / 2
    );
}&lt;/p&gt;

&lt;p&gt;$color_image = new Imagick(&amp;lsquo;clut.png&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;$heatmap_image-&amp;gt;clutImage($color_image);&lt;/p&gt;

&lt;p&gt;$heatmap_image-&amp;gt;writeImage(&amp;lsquo;heatmap.png&amp;rsquo;);&lt;/p&gt;

&lt;p&gt;?&amp;gt;&lt;/pre&gt;
代码虽然很多，但并不复杂，其中用到了两个图片，分别是：&lt;a href=&#34;http://gitorious.org/tempest/tempest-php/blobs/master/src/Tempest/plot.png&#34; target=&#34;_blank&#34;&gt;plot.png&lt;/a&gt;和&lt;a href=&#34;http://gitorious.org/tempest/tempest-php/blobs/master/src/Tempest/clut.png&#34; target=&#34;_blank&#34;&gt;clut.png&lt;/a&gt;。实际应用时，有时候点击量会非常大，此时没有必要把所有的点击都渲染出来，而应该采取随机取样的策略，如果采用MongoDB持久化的话，可以参考：&lt;a href=&#34;http://cookbook.mongodb.org/patterns/random-attribute/&#34; target=&#34;_blank&#34;&gt;The Random Attribute&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;备注：代码参考&lt;a href=&#34;http://code.google.com/p/image-tempest/&#34; target=&#34;_blank&#34;&gt;image-tempest&lt;/a&gt;。&lt;/p&gt;

&lt;h2&gt;最终展示&lt;/h2&gt;

&lt;p&gt;形象一点来说，其实就是通过CSS+Javascript把生成的图片盖在网页上，并调节图片透明度来达到合二为一的效果，篇幅所限，具体代码留给大家自己实现，例子效果可参考下图：
&lt;div id=&#34;attachment_41&#34;&gt;&lt;a href=&#34;http://huoding.com/wp-content/uploads/2011/01/heatmap.png&#34;&gt;&lt;img title=&#34;Heatmap&#34; src=&#34;http://huoding.com/wp-content/uploads/2011/01/heatmap.png&#34; alt=&#34;Heatmap&#34; width=&#34;320&#34; height=&#34;240&#34; /&gt;&lt;/a&gt;Heatmap&lt;/p&gt;

&lt;p&gt;&lt;/div&gt;
BTW：热点可能会随着时间改变，为了能对照某个时间的网页，可以使用&lt;a href=&#34;http://cutycapt.sourceforge.net/&#34; target=&#34;_blank&#34;&gt;CutyCapt&lt;/a&gt;截屏。顺手再贴一个相关的项目：&lt;a href=&#34;http://code.google.com/p/smt2/&#34; target=&#34;_blank&#34;&gt;smt2&lt;/a&gt;（simple mouse tracking）。&lt;/p&gt;

&lt;p&gt;有关Heatmap的详细介绍，还可以参考
&lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;http://blog.corunet.com/how-to-make-heat-maps/&#34; target=&#34;_blank&#34;&gt;How to make heat maps&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;http://blog.corunet.com/the-definitive-heatmap/&#34; target=&#34;_blank&#34;&gt;The definitive heatmap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
收工！Heatmap虽然不是很复杂的技术，但涉及的方面却很繁杂，希望本文能帮到大家。&lt;/p&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://huoding.com/2011/01/04/39&#34; target=&#34;_blank&#34;&gt;火丁笔记&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>MongoDB与内存管理</title>
      <link>http://blog.prosight.me/blogs/792</link>
      <pubDate>2011-08-20 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;但凡初次接触MongoDB的人，无不惊讶于它对内存的贪得无厌，至于个中缘由，我先讲讲Linux是如何管理内存的，再说说MongoDB是如何使用内存的，答案自然就清楚了。&lt;/p&gt;

&lt;p&gt;据说带着问题学习更有效，那就先看一个MongoDB服务器的top命令结果：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; top -p $(pidof mongod)
Mem:  32872124k total, 30065320k used,  2806804k free,   245020k buffers
Swap:  2097144k total,      100k used,  2097044k free, 26482048k cached&lt;/p&gt;

&lt;p&gt;VIRT  RES  SHR %MEM
1892g  21g  21g 69.6&lt;/pre&gt;
这台MongoDB服务器有没有性能问题？大家可以一边思考一边继续阅读。&lt;/p&gt;

&lt;h2&gt;先讲讲Linux是如何管理内存的&lt;/h2&gt;

&lt;p&gt;在Linux里（别的系统也差不多），内存有物理内存和&lt;a href=&#34;http://en.wikipedia.org/wiki/Virtual_memory&#34; target=&#34;_blank&#34;&gt;虚拟内存&lt;/a&gt;之说，物理内存是什么自然无需解释，虚拟内存实际是物理内存的抽象，多数情况下，出于方便性的考虑，程序访问的都是虚拟内存地址，然后操作系统会把它翻译成物理内存地址。&lt;/p&gt;

&lt;p&gt;很多人会把虚拟内存和Swap混为一谈，实际上Swap只是虚拟内存引申出的一种技术而已：操作系统一旦物理内存不足，为了腾出内存空间存放新内容，就会把当前物理内存中的内容放到交换分区里，稍后用到的时候再取回来，需要注意的是，Swap的使用可能会带来性能问题，偶尔为之无需紧张，糟糕的是物理内存和交换分区频繁的发生数据交换，这被称之为Swap颠簸，一旦发生这种情况，先要明确是什么原因造成的，如果是内存不足就好办了，加内存就可以解决，不过有的时候即使内存充足也可能会出现这种问题，比如MySQL就有可能出现这样的情况，解决方法是限制使用Swap：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; sysctl -w vm.swappiness=0&lt;/pre&gt;
查看内存情况最常用的是free命令：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; free -m
             total       used       free     shared    buffers     cached
Mem:         32101      29377       2723          0        239      25880
-/+ buffers/cache:       3258      28842
Swap:         2047          0       2047&lt;/pre&gt;
新手看到used一栏数值偏大，free一栏数值偏小，往往会认为内存要用光了。其实并非如此，之所以这样是因为每当我们操作文件的时候，Linux都会尽可能的把文件缓存到内存里，这样下次访问的时候，就可以直接从内存中取结果，所以cached一栏的数值非常的大，不过不用担心，这部分内存是可回收的，操作系统会按照&lt;a href=&#34;http://en.wikipedia.org/wiki/Cache_algorithms&#34; target=&#34;_blank&#34;&gt;LRU&lt;/a&gt;算法淘汰冷数据。还有一个buffers，也是可回收的，它和cache的区别，可以参考&lt;a href=&#34;http://en.wikipedia.org/wiki/Cache#The_difference_between_buffer_and_cache&#34; target=&#34;_blank&#34;&gt;维基百科&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;知道了原理，我们就可以推算出系统可用的内存是free + buffers + cached：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; echo &amp;ldquo;2723 + 239 + 25880&amp;rdquo; | bc -l
28842&lt;/pre&gt;
至于系统实际使用的内存是used – buffers – cached：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; echo &amp;ldquo;29377 - 239 - 25880&amp;rdquo; | bc -l
3258&lt;/pre&gt;
除了free命令，还可以使用sar命令：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; sar -r
kbmemfree kbmemused  %memused kbbuffers  kbcached
  3224392  29647732     90.19    246116  26070160&lt;/p&gt;

&lt;p&gt;shell&amp;gt; sar -W
pswpin/s pswpout/s
    0.00      0.00&lt;/pre&gt;
希望你没有被%memused吓到，如果不幸言中，重读本文。&lt;/p&gt;

&lt;h2&gt;再说说MongoDB是如何使用内存的&lt;/h2&gt;

&lt;p&gt;目前，MongoDB使用的是&lt;a href=&#34;http://www.mongodb.org/display/DOCS/Caching&#34; target=&#34;_blank&#34;&gt;内存映射存储引擎&lt;/a&gt;，它会把磁盘IO操作转换成内存操作，如果是读操作，内存中的数据起到缓存的作用，如果是写操作，内存还可以把随机的写操作转换成顺序的写操作，总之可以大幅度提升性能。MongoDB并不干涉内存管理工作，而是把这些工作留给操作系统的虚拟内存管理器去处理，这样的好处是简化了MongoDB的工作，但坏处是你没有方法很方便的控制MongoDB占多大内存，事实上MongoDB会占用所有能用的内存，所以最好不要把别的服务和MongoDB放一起。&lt;/p&gt;

&lt;p&gt;有时候，即便MongoDB使用的是64位操作系统，也可能会遭遇臭名昭著的&lt;a href=&#34;http://en.wikipedia.org/wiki/Out_of_memory&#34; target=&#34;_blank&#34;&gt;OOM&lt;/a&gt;问题，出现这种情况，多半是因为限制了虚拟内存的大小所致，可以这样查看当前值：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; ulimit -a | grep &amp;lsquo;virtual&amp;rsquo;&lt;/pre&gt;
多数操作系统缺省都是把它设置成unlimited的，如果你的操作系统不是，可以这样修改：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; ulimit -v unlimited&lt;/pre&gt;
不过要注意的是，ulimit的使用是有上下文的，最好放在MongoDB的启动脚本里。&lt;/p&gt;

&lt;p&gt;有时候，出于某些原因，你可能想释放掉MongoDB占用的内存，不过前面说了，内存管理工作是由虚拟内存管理器控制的，所以通常你只能通过重启服务来释放内存，你一定不齿于这样的方法，幸好可以使用MongoDB内置的&lt;a href=&#34;http://www.mongodb.org/display/DOCS/List+of+Database+Commands&#34; target=&#34;_blank&#34;&gt;closeAllDatabases&lt;/a&gt;命令达到目的：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;mongo&amp;gt; use admin
mongo&amp;gt; db.runCommand({closeAllDatabases:1})&lt;/pre&gt;
另外，通过调整内核参数&lt;a href=&#34;http://www.kernel.org/doc/Documentation/sysctl/vm.txt&#34; target=&#34;_blank&#34;&gt;drop_caches&lt;/a&gt;也可以释放缓存：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; sysctl -w vm.drop_caches=1&lt;/pre&gt;
平时可以通过mongo命令行来监控MongoDB的内存使用情况，如下所示：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;mongo&amp;gt; db.serverStatus().mem:
{
    &amp;ldquo;resident&amp;rdquo; : 22346,
    &amp;ldquo;virtual&amp;rdquo; : 1938524,
    &amp;ldquo;mapped&amp;rdquo; : 962283
}&lt;/pre&gt;
还可以通过&lt;a href=&#34;http://www.mongodb.org/display/DOCS/mongostat&#34; target=&#34;_blank&#34;&gt;mongostat&lt;/a&gt;命令来监控MongoDB的内存使用情况，如下所示：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; mongostat
mapped  vsize    res faults
  940g  1893g  21.9g      0&lt;/pre&gt;
其中内存相关字段的含义是：
&lt;ul&gt;
    &lt;li&gt;mapped：映射到内存的数据大小&lt;/li&gt;
    &lt;li&gt;visze：占用的虚拟内存大小&lt;/li&gt;
    &lt;li&gt;res：占用的驻留内存大小&lt;/li&gt;
&lt;/ul&gt;
注：如果操作不能在内存中完成，结果faults列的数值不会是0，视大小可能有性能问题。&lt;/p&gt;

&lt;p&gt;在上面的结果中，vsize是mapped的两倍，而mapped等于数据文件的大小，所以说vsize是数据文件的两倍，之所以会这样，是因为本例中，MongoDB开启了&lt;a href=&#34;http://www.mongodb.org/display/DOCS/Journaling&#34; target=&#34;_blank&#34;&gt;journal&lt;/a&gt;，需要在内存里多映射一次数据文件，如果关闭journal，则vsize和mapped大致相当。&lt;/p&gt;

&lt;p&gt;如果想验证这一点，可以在开启或关闭journal后，通过pmap命令来观察文件映射情况：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;shell&amp;gt; pmap $(pidof mongod)&lt;/pre&gt;
到底MongoDB配备多大内存合适？宽泛点来说，多多益善，如果要确切点来说，这实际取决于你的数据及索引的大小，内存如果能够装下全部数据加索引是最佳情况，不过很多时候，数据都会比内存大，比如本文所涉及的MongoDB实例：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;mongo&amp;gt; db.stats()
{
    &amp;ldquo;dataSize&amp;rdquo; : 1004862191980,
    &amp;ldquo;indexSize&amp;rdquo; : 1335929664
}&lt;/pre&gt;
本例中索引只有1G多，内存完全能装下，而数据文件则达到了1T，估计很难找到这么大内存，此时保证内存能装下热数据即可，至于热数据是多少，取决于具体的应用。如此一来内存大小就明确了：内存 &amp;gt; 索引 + 热数据。&lt;/p&gt;

&lt;p&gt;原文引自：&lt;a href=&#34;http://huoding.com/2011/08/19/107&#34; target=&#34;_blank&#34;&gt;火丁笔记&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在 Ubuntu 上安装和配置 OpenStack Nova</title>
      <link>http://blog.prosight.me/blogs/786</link>
      <pubDate>2011-08-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;OpenStack 是由 Rackspace 和 NASA 共同开发的云计算平台，帮助服务商和企业内部实现类似于 Amazon EC2 和 S3 的云基础架构服务（Infrastructure as a Service, IaaS）。OpenStack 包含两个主要模块：Nova 和 Swift，前者是 NASA 开发的虚拟服务器部署和业务计算模块；后者是 Rackspack 开发的分布式云存储模块，两者可以一起用，也可以分开单独用。OpenStack 是开源项目，除了有 Rackspace 和 NASA 的大力支持外，后面还有包括 Dell, Citrix, Cisco, Canonical 这些重量级公司的贡献和支持，发展速度非常快，有取代另一个业界领先开源云平台 Eucalyptus 的态势。&lt;/p&gt;

&lt;p&gt;OpenStack 是 Python 2.6 写的，CentOS 5.6 上默认的是 Python 2.4 的环境并且还有很多依赖关系不容易升级到 2.6，所以在 Ubuntu 上安装会简单一些，而且 Ubuntu 是 OpenStack 的官方首选系统，文档都是按 Ubuntu 写的，所以这里 VPSee 采用最新的 Ubuntu 11.04 Server 64bit 版本来安装和配置 OpenStack Nova.&lt;/p&gt;

&lt;h2&gt;配置网络&lt;/h2&gt;

&lt;p&gt;在安装完基本的 Ubuntu 11.04 Server 系统后升级和更新整个系统，安装完 bridge-utils 包后重启系统：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo apt-get update
$ sudo apt-get upgrade&lt;/p&gt;

&lt;p&gt;$ sudo apt-get install bridge-utils&lt;/p&gt;

&lt;p&gt;$ sudo reboot&lt;/pre&gt;
配置网桥：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo vi /etc/network/interfaces&lt;/p&gt;

&lt;p&gt;auto lo
iface lo inet loopback&lt;/p&gt;

&lt;p&gt;auto eth0
iface eth0 inet static
address 172.16.39.111
netmask 255.255.254.0
gateway 172.16.38.1&lt;/p&gt;

&lt;p&gt;auto br100
iface br100 inet static
bridge_ports eth1
bridge_stp off
bridge_maxwait 0
bridge_fd 0
address 192.168.0.1
netmask 255.255.0.0
broadcast 192.168.255.255&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;安装 NTP 服务&lt;/h2&gt;

&lt;p&gt;OpenStack Nova 需要 NTP 服务器来保持所有节点服务器（Cloud Compute）的时间同步，所以需要在前端控制服务器（Cloud Controller）上安装 NTP 服务器，然后在节点服务器上安装 NTP 客户端保持与前端的同步：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo apt-get install ntp&lt;/p&gt;

&lt;p&gt;$ sudo vi /etc/ntp.conf
server 127.127.1.0
fudge 127.127.1.0 stratum 10&lt;/p&gt;

&lt;p&gt;$ sudo /etc/init.d/ntp restart&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;安装和配置 MySQL 数据库&lt;/h2&gt;

&lt;p&gt;OpenStack Nova 需要数据库的支持，这里选用 MySQL（当然也可以用其他的数据库，比如 PostgreSQL 等）：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo apt-get install mysql-server&lt;/pre&gt;
修改 MySQL 绑定地址，以便其他的节点服务器也能访问这个数据库：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo vi /etc/mysql/my.cnf
&amp;hellip;
#bind-address           = 127.0.0.1
bind-address            = 0.0.0.0
&amp;hellip;&lt;/p&gt;

&lt;p&gt;$ sudo /etc/init.d/mysql restart&lt;/pre&gt;
创建一个名为 nova 的数据库，并设置 root 从任何 IP 访问的权限和密码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo mysql -uroot -ppassword -e &amp;lsquo;CREATE DATABASE nova;&amp;rsquo;
$ sudo mysql -uroot -ppassword -e &amp;ldquo;GRANT ALL PRIVILEGES ON &lt;em&gt;.&lt;/em&gt; TO \
&amp;lsquo;root&amp;rsquo;@&amp;lsquo;%&amp;rsquo; WITH GRANT OPTION;&amp;rdquo;
$ sudo mysql -uroot -ppassword -e &amp;ldquo;SET PASSWORD FOR \
&amp;lsquo;root&amp;rsquo;@&amp;lsquo;%&amp;rsquo; = PASSWORD(&amp;lsquo;password&amp;rsquo;);&amp;rdquo;&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;安装 Glance 镜像服务&lt;/h2&gt;

&lt;p&gt;Glance 是个镜像服务器，用来给 OpenStack Nova 提供操作系统镜像（image）服务，提供可选择的操作系统模版（镜像）。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo apt-get install glance&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;安装 OpenStack Nova&lt;/h2&gt;

&lt;p&gt;OpenStack Nova 已经进入 Ubuntu 11.04 源，所以直接安装就可以了，不必源码安装：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo apt-get install rabbitmq-server nova-common nova-doc python-nova
nova-api nova-network nova-volume nova-objectstore nova-scheduler nova-compute&lt;/p&gt;

&lt;p&gt;$ sudo apt-get install -y euca2ools&lt;/p&gt;

&lt;p&gt;$ sudo apt-get install -y unzip&lt;/pre&gt;
配置 Nova：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo vi /etc/nova/nova.conf
&amp;ndash;dhcpbridge_flagfile=/etc/nova/nova.conf
&amp;ndash;dhcpbridge=/usr/bin/nova-dhcpbridge
&amp;ndash;logdir=/var/log/nova
&amp;ndash;state_path=/var/lib/nova
&amp;ndash;lock_path=/var/lock/nova
&amp;ndash;verbose
&amp;ndash;s3_host=172.16.39.111
&amp;ndash;rabbit_host=192.168.0.1
&amp;ndash;cc_host=192.168.0.1
&amp;ndash;ec2_url=http://172.16.39.111:8773/services/Cloud
&amp;ndash;fixed_range=192.168.0.0/16
&amp;ndash;network_size=8
&amp;ndash;FAKE_subdomain=ec2
&amp;ndash;routing_source_ip=192.168.0.1
&amp;ndash;sql_connection=mysql://root:password@172.16.39.111/nova
&amp;ndash;glance_host=192.168.0.1
&amp;ndash;image_service=nova.image.glance.GlanceImageService&lt;/pre&gt;
重启 nova 相关服务以便设置生效：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo restart libvirt-bin; sudo restart nova-network;
sudo restart nova-compute; sudo restart nova-api;
sudo restart nova-objectstore; sudo restart nova-scheduler;
sudo restart nova-volume; sudo restart glance-api; sudo restart glance-registry&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;使用 Nova&lt;/h2&gt;

&lt;p&gt;开始使用 Nova 前需要创建 nova 数据库表、创建网络、创建管理员帐号、创建云并联到刚才创建的管理员上：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo nova-manage db sync
$ sudo nova-manage network create 192.168.0.0/24 1 255
$ sudo nova-manage floating create 10.10.10.2 10.10.10.&lt;sup&gt;224&lt;/sup&gt;&amp;frasl;&lt;sub&gt;27&lt;/sub&gt;
$ sudo nova-manage user admin vpsee
$ sudo nova-manage project create mycloud vpsee&lt;/pre&gt;
因为多个管理员可以创建多个不同的云，所以某个云的管理员需要特定的权限才能访问和管理自己的 Nova 云，创建权限信息，并解压到自己的目录里，需要注意的是每次使用 nova 管理云的时候都需要读取 novarc 里面的配置信息：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ mkdir /home/vpsee/creds
$ sudo nova-manage project zipfile mycloud vpsee /home/vpsee/creds/novacreds.zip&lt;/p&gt;

&lt;p&gt;$ cd /home/vpsee/creds
$ unzip novacreds.zip
$ sudo chown -R vpsee:vpsee /home/vpsee/creds/&lt;/p&gt;

&lt;p&gt;$ source /home/vpsee/creds/novarc&lt;/pre&gt;
每次用 nova 的时候都要用到 novarc 里面的环境变量，每次 source novarc 很麻烦，所以最好加到 .bashrc 里面：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ cat  /home/vpsee/creds/novarc &amp;gt;&amp;gt; /home/vpsee/.bashrc
$ source /home/vpsee/.bashrc&lt;/pre&gt;
再次重启 nova 相关的所有服务：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ sudo restart libvirt-bin; sudo restart nova-network;
sudo restart nova-compute; sudo restart nova-api;
sudo restart nova-objectstore; sudo restart nova-scheduler;
sudo restart nova-volume; sudo restart glance-api; sudo restart glance-registry&lt;/pre&gt;
如果一切正常的话，应该可以打印出如下的类似信息：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ euca-describe-availability-zones verbose
AVAILABILITYZONE    nova    available
AVAILABILITYZONE    |- node00
AVAILABILITYZONE    | |- nova-scheduler enabled :-) 2011-05-22 10:32:31
AVAILABILITYZONE    | |- nova-network   enabled :-) 2011-05-22 10:32:32
AVAILABILITYZONE    | |- nova-compute   enabled :-) 2011-05-22 10:32:24&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;启动第一个实例&lt;/h2&gt;

&lt;p&gt;启动实例之前需要先上传一个系统模版，我们称之为镜像（image），自己制作操作系统镜像有点麻烦（请看：&lt;a href=&#34;http://www.vpsee.com/2011/06/create-ubuntu-kvm-image-for-openstack-nova/&#34;&gt;为 OpenStack Nova 制作 Ubuntu 镜像&lt;/a&gt; 和 &lt;a href=&#34;http://www.vpsee.com/2011/06/create-windows-kvm-image-for-openstack-nova/&#34;&gt;为 OpenStack Nova 制作 Windows 镜像&lt;/a&gt;。），这里直接使用一个已经做好的 Ubuntu 10.10 版本镜像，下载已经做好的镜像文件并上传到镜像服务器（这里镜像服务器和前端服务器在同一台物理服务器上）：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ wget &lt;a href=&#34;http://c0179148.cdn1.cloudfiles.rackspacecloud.com/ubuntu1010-UEC-localuser-image.tar.gz&#34;&gt;http://c0179148.cdn1.cloudfiles.rackspacecloud.com/ubuntu1010-UEC-localuser-image.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;$ uec-publish-tarball ubuntu1010-UEC-localuser-image.tar.gz ubuntu1010-bucket x86_64&lt;/pre&gt;
列出云里现有的可以加载的镜像，并以某个镜像（比如编号为 ami-00000003）为模版启动一个实例（操作系统）：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ euca-describe-images
IMAGE   aki-00000001    ubuntu1010-bucket/vmlinuz-2.6.32-28-server.manifest.xml     available   public      x86_64  kernel
IMAGE   ari-00000002    ubuntu1010-bucket/initrd.img-2.6.32-28-server.manifest.xmavailable  public      x86_64  ramdisk
IMAGE   ami-00000003    ubuntu1010-bucket/maverick-server-uec-amd64.img.manifest.xml        available   public      x86_64  machine aki-00000001    ari-00000002&lt;/p&gt;

&lt;p&gt;$ euca-run-instances -k mykey -t m1.tiny ami-00000003&lt;/pre&gt;
检查一下实例是否成功启动和运行：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ virsh list&lt;/p&gt;

&lt;h2&gt;Id Name                 State&lt;/h2&gt;

&lt;p&gt;1 instance-00000001    running&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;访问实例&lt;/h2&gt;

&lt;p&gt;启动实例后怎么访问呢？和访问 VPS 一样，需要 IP 地址然后 ssh 访问，还记得上面的网络配置么，新创建的系统将按照 192.168.0.x 的形式分配 IP，所以 192.168.0.3 就是刚刚 euca-run-instances 创建的实例的 IP 地址：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ ssh ubuntu@192.168.0.3&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;摘自：&lt;a href=&#34;http://www.vpsee.com/2011/05/install-openstack-nova-on-ubuntu/&#34;&gt;vpsee.com&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在XCode4中添加程序调试错误信息</title>
      <link>http://blog.prosight.me/blogs/780</link>
      <pubDate>2011-08-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;当调试程序时，程序突然崩溃，默认条件下，XCode反馈的信息不够多。可以通过以下方式让XCode反馈足够多的信息。&lt;/p&gt;

&lt;p&gt;在Edit&amp;ndash;&amp;gt;Scheme里面 找到Arguments
&lt;a href=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2011/08/0_1310625070ICHW.png&#34;&gt;&lt;img src=&#34;http://prosight-wordpress.stor.sinaapp.com/uploads/2011/08/0_1310625070ICHW-300x201.png&#34; alt=&#34;&#34; title=&#34;XCode4设置&#34; width=&#34;300&#34; height=&#34;201&#34; class=&#34;alignnone size-medium wp-image-781&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;把下面3个值设置成YES
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSAutoreleaseFreedObjectCheckEnabled
NSZombieEnabled
NSDebugEnabled
&lt;/pre&gt;
这种方法非常好用，建议在建立一个工程的时候，加入此设置。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>通过JNI实现Java对C/C++的调用</title>
      <link>http://blog.prosight.me/blogs/769</link>
      <pubDate>2011-07-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;JNI是Java Native Interface的缩写，中文为JAVA本地调用。从Java1.1开始，Java Native Interface(JNI)标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。&lt;/p&gt;

&lt;h3&gt;大致步骤&lt;/h3&gt;

&lt;p&gt;&lt;ol&gt;
    &lt;li&gt;&lt;span style=&#34;font-size: 13px; font-weight: normal;&#34;&gt;编写带有native声明的方法的java类&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;使用javac命令编译所编写的java类&lt;/li&gt;
    &lt;li&gt;使用javah命令生成扩展名为h的头文件&lt;/li&gt;
    &lt;li&gt;使用C/C++实现本地方法&lt;/li&gt;
    &lt;li&gt;将C/C++编写的文件生成动态连接库&lt;/li&gt;
&lt;/ol&gt;
&lt;strong&gt;1) 编写java程序：&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
public class HelloNative{
  public native void greeting();//所有native所修饰的都是本地方法&lt;/p&gt;

&lt;p&gt;static{
    System.loadLibrary(&amp;ldquo;HelloNative&amp;rdquo;);//载入本地库
  }&lt;/p&gt;

&lt;p&gt;public static void main(String[] args){
    new HelloNative().greeting();
//    System.out.println(System.getProperty(&amp;ldquo;java.library.path&amp;rdquo;));
  }
}
&lt;/pre&gt;
声明native方法：如果你想将一个方法做为一个本地方法的话，那么你就必须声明该方法为native的，并且不能实现。其中方法的参数和返回值在后面讲述。 Load动态库：System.loadLibrary(&amp;ldquo;HelloNative&amp;rdquo;);加载动态库（我们可以这样理解：我们的方法 greeting()没有实现，但是我们在下面就直接使用了，所以必须在使用之前对它进行初始化）这里一般是以static块进行加载的。同时需要注意的是System.loadLibrary();的参数“HelloNative”是动态库的名字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2) 编译&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
javac HelloNative.java
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3) 生成扩展名为h的头文件&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
javah HelloNative
&lt;/pre&gt;
命令执行后会在当前目录下生产一个c的头文件，名字为HelloNative.h。内容如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/* DO NOT EDIT THIS FILE - it is machine generated &lt;em&gt;/
#include &lt;jni.h&gt;
/&lt;/em&gt; Header for class HelloNative */&lt;/p&gt;

&lt;p&gt;#ifndef _Included_HelloNative
#define _Included_HelloNative
#ifdef __cplusplus
extern &amp;ldquo;C&amp;rdquo; {
#endif
/*
 * Class:     HelloNative
 * Method:    greeting
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_HelloNative_greeting
  (JNIEnv *, jobject);&lt;/p&gt;

&lt;p&gt;#ifdef __cplusplus
}
#endif
#endif
&lt;/pre&gt;
这个h文件相当于我们在java里面的接口，这里声明了一个 Java_HelloWorld_displayHelloWorld (JNIEnv *, jobject);方法，然后在我们的本地方法里面实现这个方法，也就是说我们在编写C/C++程序的时候所使用的方法名必须和这里的一致&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4) 编写本地方法实现和由javah命令生成的头文件里面声明的方法名相同的方法。&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#include &lt;stdio.h&gt;
#include &lt;jni.h&gt;
#include &amp;ldquo;HelloNative.h&amp;rdquo;&lt;/p&gt;

&lt;p&gt;JNIEXPORT void JNICALL Java_HelloNative_greeting
  (JNIEnv * env, jobject obj)
{
  printf(&amp;ldquo;Hello, Native!\n&amp;rdquo;);
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5) 生成动态库&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
gcc -fPIC -I/home/elton/jdk/include -I/home/elton/jdk/include/linux -shared -o libHelloNative.so HelloNative.c
&lt;/pre&gt;
注意，必须告知编译器jni.h所在的接口位置。linux的动态库都是以lib开头，以.so结尾的，要遵守这个命名规范。-fPIC是告诉编译器生成跟位置无关的动态链接库
命令执行后，会在当前目录生成一个libHelloNative.so的动态链接库文件&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6) 运行程序&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
java -Djava.library.path=. HelloNative
&lt;/pre&gt;
必须指定java.library.path变量的内容，告诉java你的动态链接库的位置。
或者在命令行上输入
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
export LD_LIBRARY_PATH=.:$LD_LIBRARY_PATH
&lt;/pre&gt;
这样就不用每次调试的时候都输入-Djava.library.path=.这个参数了。&lt;/p&gt;

&lt;p&gt;当你部署的时候，你通过System.out.println(System.getProperty(&amp;ldquo;java.library.path&amp;rdquo;));得到你系统的java.library.path位置，然后把你的动态链接库拷贝到这个目录中。我用的是ubuntu 11.04 64位版本，得到的结果是
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/usr/java/packages/lib/amd64:/usr/lib64:/lib64:/lib:/usr/lib
&lt;/pre&gt;
这样你的动态链接库就永远都会被java访问到了，不用每次指定环境变量了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>让Redis使用TCMalloc，实现高性能NOSql服务器</title>
      <link>http://blog.prosight.me/blogs/766</link>
      <pubDate>2011-07-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;TCMalloc（Thread-Caching Malloc）是google开发的开源工具──“google-perftools”中的成员。与标准的glibc库的malloc相比，TCMalloc在内存的分配上效率和速度要高得多，可以在很大程度上提高MySQL服务器在高并发情况下的性能，降低系统负载。&lt;/p&gt;

&lt;p&gt;TCMalloc库的安装步骤（Linux环境）：
&lt;strong&gt;Step 1. 64位操作系统请先安装libunwind库&lt;/strong&gt;(32位操作系统不要安装)
libunwind库为基于64位CPU和操作系统的程序提供了基本的堆栈辗转开解功能，其中包括用于输出堆栈跟踪的API、用于以编程方式辗转开解堆栈的API以及支持C++异常处理机制的API。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget http://download.savannah.gnu.org/releases/libunwind/libunwind-0.99-alpha.tar.gz  
tar zxvf libunwind-0.99-alpha.tar.gz  
cd libunwind-0.99-alpha/  
CFLAGS=-fPIC ./configure  
make CFLAGS=-fPIC  
make CFLAGS=-fPIC install  
&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Step 2、安装google-perftools：&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://google-perftools.googlecode.com/files/google-perftools-1.8.1.tar.gz&#34;&gt;http://google-perftools.googlecode.com/files/google-perftools-1.8.1.tar.gz&lt;/a&gt;&lt;br /&gt;
tar zxvf google-perftools-1.8.1.tar.gz&lt;br /&gt;
cd google-perftools-1.8.1/&lt;br /&gt;
./configure  &amp;ndash;disable-cpu-profiler &amp;ndash;disable-heap-profiler &amp;ndash;disable-heap-checker &amp;ndash;disable-debugalloc &amp;ndash;enable-minimal
make &amp;amp;&amp;amp; make install&lt;/p&gt;

&lt;p&gt;sudo echo &amp;ldquo;/usr/local/lib&amp;rdquo; &amp;gt; /etc/ld.so.conf.d/usr_local_lib.conf  #如果没有这个文件，自己建一个
sudo /sbin/ldconfig
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3. 安装Redis&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ curl -O &lt;a href=&#34;http://redis.googlecode.com/files/redis-2.2.12.tar.gz&#34;&gt;http://redis.googlecode.com/files/redis-2.2.12.tar.gz&lt;/a&gt;&lt;br /&gt;
$ tar xzvf redis-2.2.12.tar.gz&lt;br /&gt;
$ cd redis-2.2.12&lt;br /&gt;
$ make USE_TCMALLOC=yes
$ sudo make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 4. 检查tcmalloc是否生效&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo lsof -n | grep tcmalloc
redis-ser 31590      elton  mem       REG                8,3  1155539    4856411 /usr/local/lib/libtcmalloc_minimal.so.0.2.1
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 5. 测试Redis&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;修改配置文件：&lt;/h1&gt;

&lt;p&gt;vim redis.conf&lt;/p&gt;

&lt;h1&gt;找到 daemonize，将后面的no改为yes，让其可以以服务方式运行&lt;/h1&gt;

&lt;h1&gt;然后启动 redis：&lt;/h1&gt;

&lt;p&gt;$ ./redis-server ./redis.conf&lt;/p&gt;

&lt;p&gt;#连接数据库进行测试
$ src/redis-cli
redis&amp;gt; set foo bar
OK
redis&amp;gt; get foo
&amp;ldquo;bar&amp;rdquo;
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>USING INDUCTION TO DESIGN 使用归纳法设计算法【全文翻译】</title>
      <link>http://blog.prosight.me/blogs/739</link>
      <pubDate>2011-07-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;h1&gt;&lt;span style=&#34;font-size: 13px; font-weight: normal;&#34;&gt;在数学定理证明和计算机算法设计之间采用类比的思想能够为算法设计提供一个极好的方法，通过解释这种做法来了解这种关键思想，从而对此有更深的理解。&lt;/span&gt;&lt;span style=&#34;font-size: 13px; font-weight: normal;&#34;&gt; &lt;/span&gt;&lt;/h1&gt;
这篇文章在进行组合算法设计和教学过程中展示了一种基于数学归纳法的方法，尽管这种方法并不能涵盖设计算法时的所有可能方法，但它包含了大部分已知的技术方法。同时这种方法也提供了一个极好的并且也是直观的结构，从而在解释算法设计的时候显得更有深度。这种方法的核心是通过对数学定理证明过程中和设计组合算法过程中的两种智力过程进行类比。尽管我们承认这两种过程是为不同的目的服务的并且取得的是不同类型的结果，但是这两者要比看上去的更加相似。这种说法可以通过一系列的算法例子得到验证，在这些算法中都可以采用这种方法进行设计和解释。我们相信通过学习这种方法，学生能够对算法产生更多的热情，也能更深入更好的理解算法。&lt;/p&gt;

&lt;p&gt;数学归纳法是一个非常强大的证明方法。使用如下：让T是一个我们想证明的定理。假设T包含一个值可为任意自然数的参数n。我们不需要直接证明T对所有的n都成立，我们只需要证明以下两点：（1）T对n=1时成立 （2）对于任意的n&amp;gt;1，T对于n-1成立。第一点往往很容易证明，证明第二点在很多情况下要比直接证明定理要容易，因为此时我们可以假设T对n-1已经成立。（从某种意义上来说，我们无条件的获得这一假设）。换句话说，减小定理的规模使用一个更小的n值而不是从头开始证明是很有帮助的，我们关注的就是这种减小。&lt;/p&gt;

&lt;p&gt;这一原则对于算法同样也适用。归纳法让人们关注于从较小的子问题延伸到那些更大的问题上。可以通过从问题的任意一个实例入手，通过假设规模较小的相同问题已经得到解决，然后再试图解决该问题。例如，给定一个n（n&amp;gt;1）的序列对其进行排序（排序一个序列显然没必要），我们可以假定已经知道如何对n-1个数进行排序。然后我们可以要么排序前n-1个数，然后把第n个数插入到正确位置（这引出了一个叫插入排序的算法），要么一开始把第n个数放在它的最终位置然后再排序剩下的数（这引出了一个叫选择排序的算法）。我们只需要解决对第n个数的操作（当然这并不是唯一的排序方法，也不是唯一一种使用归纳法进行排序的方法）。&lt;/p&gt;

&lt;p&gt;上面介绍的使用归纳法的例子很直观，然后有许多不同的方法来使用归纳法，由此带来了不同的算法设计技巧。这是一个非常强大和灵活的方法。我们将证明，在使用这种想法时很多问题变得很简单，这一点会让你惊讶不已。我们将采用其中的几种方法，并显示它们在设计算法时的强大力量。在我们讨论的归纳法的各种变形方法中，我们主要讨论巧妙的选择归纳序列，增强归纳假设，更强的归纳法以及最大的反例四种方法。&lt;/p&gt;

&lt;p&gt;我们的处理方法有两种新奇之处。首先我们把看上去不同的算法设计技术归到同一个类别下，这将使得对一个新算法的查找更有条理性。其次，我们利用已知的数学证明技巧来设计算法，这一点很重要，因为它开启了利用在别的学科多年发展过程中形成的强大的技术进行算法设计的时代。&lt;/p&gt;

&lt;p&gt;一般而言，在算法领域使用归纳法和数学证明技巧并不是第一次见到。归纳法在证明算法正确性上已经使用了很长时间，人们通过把对算法执行步骤的断言，证明它们在最初情况下成立和它们在特定操作步骤下保持不变结合起来，从而验证算法的正确性。这种方法最初由哥特斯和冯诺依曼提出的，后来由弗洛伊德和其他人对其进一步发展。Dijkstra和格里斯提出了一种和我们开发程序相似的方法，同时他们也给出了对其正确性的证明。尽管在此我们借鉴了他们的一些技术，但我们的重点却不同：我们关注于高层次的算法理念而不必下降到实际的程序层面。PRL和NuPRL（这里不会翻译，建议看http://www.cs.cornell.edu/info/projects/nuprl/book/node2.html）使用数学证明作为一个程序开发系统的基本构成。当然递归也被广泛用于算法设计之中（对于递归的详细讨论请看&amp;hellip;）&lt;/p&gt;

&lt;p&gt;我们的目标主要是用于教学，我们假设读者对数学归纳法和基本的数据结构已经很熟悉。对于任意一种证明技巧我们会对其类比进行一个简要的解释，然后给出一个或多个算法例子。对于给出的算法例子我们重点关注于如何使用这种方法。我们的目的不是在于对一个算法进行解释从而帮助一个程序员更容易地将其转换为程序，而是通过一种更容易理解的方式对其进行解释。这些算法通过一种创造性的过程加以解释而不是以一种成品的方式出现。我们教算法的目标不仅仅是向学生展示如何解决当前特定的问题，同时也是帮助他们解决未来新的问题。教学生如何把想法融入到算法设计中和教学生解决方案的实现细节同样重要。但前者通常要更难一些。我们相信我们的方法能够加强对这种思维过程的理解。&lt;/p&gt;

&lt;p&gt;尽管归纳法建议通过递归加以实现，但也未必如此。（事实上我们称这种方法为归纳而不是递归，从而淡化递归实现的概念）在很多情况下，迭代也很容易，甚至尽管在算法设计中我们心里想的是使用归纳法（递归），但迭代却更有效率。&lt;/p&gt;

&lt;p&gt;本文中提到的这些算法是经过筛选的，以便能更好的展现这种方法的魅力。我们选择的是一些简单的问题，在后续部分选择一些更复杂的例子。我们发现很多固定的算法在算法设计课上第一次教授时可以使用这种方法。（使用这种方法的算法导论书很快就要出来了）我们首先从三个简单的例子入手，（至少使用归纳法让他们看上去简单了）然后我们展示一些数学证明技巧以及它们在算法设计中类似的技巧，在每种情况下这种类比都在一个或多个例子中得到了阐明。&lt;/p&gt;

&lt;h2&gt;三个例子&lt;/h2&gt;

&lt;h3&gt;计算多项式的值【Q1】&lt;/h3&gt;

&lt;p&gt;问题：给定一个实数序列an,an-1,&amp;hellip;a1,a0和一个实数x，计算下面这个多项式的值&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pn(x)=an*x^n+an-1*x^(n-1)+&amp;hellip;a1*x+a0&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;这个问题看上去并不像是一个使用归纳法求解直观例子，尽管如此，我们将证明使用归纳法能够直接带来很不错的解决方法。我们首先使用最简单几乎微不足道的方法求解，然后通过发现其中的变化，从而找到更好的解决方案。&lt;/p&gt;

&lt;p&gt;这个问题涉及到n+2个数字。使用归纳法解决该问题的依据是对一个更小的问题进行求解。换句话说，我们尽量减小问题的规模，然后使用递归求解。（或者我们称其为归纳）第一步尝试是移除an，这将导致问题中计算的表达式变成：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Pn-1(x)=an-1*x^(n-1)+an-2*x^(n-2)+&amp;hellip;+a1*x+a0&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;除了规模外这是一个同样的问题。因此我们可以使用下面的假设运用归纳法对其进行求解：&lt;/p&gt;

&lt;p&gt;归纳假设：我们已经知道如何去计算一个多项式，该多项式在x处的输入项有an-1,&amp;hellip;a1,a0（即我们知道如何计算Pn-1(x)）&lt;/p&gt;

&lt;p&gt;我们现在可以使用这假设运用归纳法来解决该问题。首先我们需要解决最基本的情况，也就是计算a0；这是很简单的。然后我们必须表明如何通过借助规模较小的问题的解决方案（这里是Pn-1(x)的值）来解决原有问题（即计算Pn(x)）。在该例子中这是很直观的。我们仅仅需要计算x^n，乘以an然后加上Pn-1(x)即可。&lt;/p&gt;

&lt;p&gt;在这一点上看上去使用归纳法很无聊因为它仅仅是复杂了一个简单的解决方案，上面提到的算法仅仅是按照多项式的数学方式对多项式从右到左进行计算而已。然而，我们很快就会看见这种方法的强大之处。&lt;/p&gt;

&lt;p&gt;尽管这个算法是正确的，但其并不是高效的。它需要n+n-1+n-2+&amp;hellip;+1=n(n+1)/2次乘法和n次加法计算。现在我们略微改变一下归纳法的使用方法，从而得到一个更好的解决方案。&lt;/p&gt;

&lt;p&gt;改进：第一个改进之处在于我们注意到在求解过程中存在很多冗余计算：x的指数是从头开始计算的。当我们计算x^n时通过使用x^(n-1)的值能够帮我们节省很多乘法运算。这些都是在归纳法假设中通过对x^n计算的归纳得以实现的：&lt;/p&gt;

&lt;p&gt;更强的归纳假设：我们已经知道了如何去计算多项式Pn-1(x)，同时我们也知道如何计算x^(n-1)的值。&lt;/p&gt;

&lt;p&gt;这个归纳假设更强一些，因为它要求计算出x^(n-1)，但是它拓展起来更容易。我们在计算x^n时仅仅需要进行一步乘法操作，然后在进行一步乘法操作得到an*x^n，然后进行一步加法操作完成整个计算。（其实这个假设并不是太强，因为我们还是需要计算x^(n-1)的值）。总而言之，这里需要进行2n次乘法和n次加法。尽管这个归纳假设需要更多的计算，但总的说来它减少了工作量。我们在后面再来讨论这一点。在各种层面上看来这个算法很好，它高效，简单也容易实现。然而存在一个更好的算法，它是通过用一种不同的方式使用归纳法得以实现的。&lt;/p&gt;

&lt;p&gt;我们通过移去最后一个系数an来简化问题。（这是一个很直截了当的做法）但是我们也可以移去第一个系数a0。这个规模更小的问题变成了计算由an,an-1&amp;hellip;a1这些系数组成的多项式，如下所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;P&amp;rsquo;n-1(x)=an*x^(n-1)+an-1*x^(n-2)&amp;hellip;+a1&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;（注意到an现在是n-1次的系数，后面依次改变）&lt;/p&gt;

&lt;p&gt;新的归纳假设（倒序）：我们知道如何去计算由系数an,an-1&amp;hellip;a1构成的x多项式（即上面列出来的P&amp;rsquo;n-1(x)）&lt;/p&gt;

&lt;p&gt;由于这个假设更容易拓展，故其更符合我们的目的。很明显Pn(x)=x*P&amp;rsquo;n-1(x)+a0。因此这里仅仅只要一次乘法和一次加法就可以通过P&amp;rsquo;n-1(x)计算得出Pn(x)。完整的算法可以通过下面这个表达式加以描述：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;an*x^n+an-1*x^(n-1)+&amp;hellip;+a1*x+a0=((&amp;hellip;((an*x+an-1)x+an-2)&amp;hellip;)x+a1)x+a0&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个算法被称为霍纳归纳以W.G.Horner命名。（这也是牛顿提出来的）。下面给出了计算多项式的算法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;计算表达式算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(a0,a1,a2&amp;hellip;an,x:real); //输入a0至an,x,全为实数&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;begin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;** P:=an;**&lt;/p&gt;

&lt;p&gt;** for i:=1 to n do**&lt;/p&gt;

&lt;p&gt;** P:=x*P+an-i;**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;end;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;复杂度：这个算法仅仅需要n次乘法,n次加法以及一个额外的内存空间。尽管原先的解决方法看上去简单并且高效，但追求一个更好的算法是值得的。这个算法不仅仅是速度更快，同时相应的程序也更简单。&lt;/p&gt;

&lt;p&gt;总结：上面给出的简单例子阐明了归纳法使用过程中的灵活性。霍纳规则的技巧仅在于考虑到输入是从左向右的，而不是直观上看到的从右向左。&lt;/p&gt;

&lt;p&gt;当然这里有使用归纳法的许多其他潜在性，我们将在更多的例子中看到这一点&lt;/p&gt;

&lt;h3&gt;找到一一映射关系【Q2】&lt;/h3&gt;

&lt;p&gt;f是一个把有限集合A映射到其自身的函数。（例如A中的每一个元素都映射到A中的另一个元素）为了简化起见，我们把A中的元素表示为从1到n的数字。我们假定函数f以一个数组f[1..n]的形式出现，这样f[i]存放的是f(i)的值。（该值是一个位于1到n之间的整数）当A中的每一个元素都仅仅只有一个元素对应它时我们把函数f称为一一映射。函数f可以用图1中的图加以展示，在图中，两端数据都对应同一个集合，图中的边表示映射关系。（这种映射关系是从左至右的）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hi.csdn.net/attachment/201107/27/0_1311738141qBTL.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;问题：找到一个包含最多元素的子集S(ScA)，使得函数f能够把S中的任何元素映射到S中的其他元素。(即f让S映射到自身)，同时S中的每一个元素仅仅只有唯一的一个S中的元素映射到自身。（即限制S让f成为一个一一映射）&lt;/p&gt;

&lt;p&gt;如果f本来就是一个一一映射，那么全集A就满足了问题的条件，显然它也是最大的集合。在另一个方面来说，如果f(i)=f(j)存在且i≠j，那么集合S就不能同时包含i和j。例如在图1中S就不能同时包含2和3。不可能任意从两者中选择一个从集合中剔除出去。例如，假设我们决定删去3，由于1被映射到3，所以我们也必须删去1。（因为任意映射必须映射到S中而此时3已经不在S中了）。但是如果1被排除了，那么2也会因为同样的原因被删去。但是，这样得到的结果集不是最大的，因为我们很容易就能看到可以只删去2即可。这个问题其实是让我们去找到一种通用的方法来决定集合中包含哪些元素而已。&lt;/p&gt;

&lt;p&gt;使用归纳法求解的思想集中在缩减问题的规模上，这种方法使用起来也很灵活。我们可以通过寻找一个要么属于S中的元素或要么不属于S中的元素来缩减问题规模。我们将在后面进行这一操作。我们先使用简洁明了的归纳假设：&lt;/p&gt;

&lt;p&gt;归纳假设：我们已经知道如何去解决一个含n-1个元素集合的问题。&lt;/p&gt;

&lt;p&gt;最基本的情况很简单：如果集合中只含有一个元素，集合必须映射到自身，这就是一个一一映射。假设我们已经有了一个含有n个元素的集合A，现在我们寻找一个满足问题条件的子集S。很显然找到一个不属于S集合的元素要比找到一个包含在S集合中元素简单。我们可以认为任何一个元素i如果没有被其他元素映射，那么i不可能包含在S中。（换句话说，在图右侧的元素i，如果没有一条边与之相连，那么i不可能在S中）否则的话，如果i∈S，假设S中有k个元素，那么这k个元素最多映射到k-1个元素，因此这个映射不可能时一一映射。如果存在这样的i，我们仅需要把i从集合中移除即可。我们现在有一个含有n-1个元素且让函数f映射到自身的集合A&amp;rsquo;=A-{i}。通过归纳假设我们知道如何去求解A&amp;rsquo;。如果不存在这样的i，那么映射就是一一映射，这样我们就解决了问题。&lt;/p&gt;

&lt;p&gt;这种解法的关键在于我们必须移除i。我们在上面证明了i不可能属于S集。这是归纳法的优势之处。一旦我们移除了一个元素缩减了问题的规模我们就算完成了。然而我们必须格外小心，缩减后的问题和原问题几乎是一样的。（除了规模外）对于集合A和函数f的唯一条件就是f让A映射到自身。由于并没有元素映射到i，这个条件对于A-{i}后的集合依然成立。当没有元素可以移除的时候这个算法也就执行结束了。&lt;/p&gt;

&lt;p&gt;实现：上面的算法是通过使用递归的过程加以描述的。在每一步中我们找到一个没有其他元素映射到它的元素，移除它，然后继续递归执行。然而实现方法并不需要用递归。我们可以对每一个元素i使用一个计数器c[i]。初始情况下c[i]需要和映射到i的元素数目相等。这可以通过扫描数组（进行n步）以及增加对应的计数器值而计算出来。然后我们把所有计数值为0的元素放在一个队列中。在每一步执行中，我们移除队列中的元素j（同时也移除集合中的对应值）。减小c[f(j)]的值，如果c[f(j)]=0，我们就把f(j)放在队列中。当队列为空时算法执行结束。算法描述如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;映射算法（f:整型数组[1..n]）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;begin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;** S:=A{A是从1到n的数字构成的数组}**&lt;/p&gt;

&lt;p&gt;** for j:=1 to n do c[j]:=0;**&lt;/p&gt;

&lt;p&gt;** for j:=1 to n do increament(c[f(j)]);**&lt;/p&gt;

&lt;p&gt;** for j:=1 to n do**&lt;/p&gt;

&lt;p&gt;** if c[j]=0 then put j in Queue;**&lt;/p&gt;

&lt;p&gt;** while Queue is not empty do**&lt;/p&gt;

&lt;p&gt;** remove i from the top of the queue;**&lt;/p&gt;

&lt;p&gt;** S:=S-{i};**&lt;/p&gt;

&lt;p&gt;** decrement c[f(i)];**&lt;/p&gt;

&lt;p&gt;** if c[f(i)]=0 then put f(i) in Queue**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;end;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;复杂度：初始化部分需要O(n)的操作时间，每一个元素最多有一次机会被放置到队列中，把元素从队列中移除只需要常数时间。步骤的总数O(n)。&lt;/p&gt;

&lt;p&gt;总结：在本例中减少问题的规模主要在从集合中删除元素上。因此我们试图在不改变问题条件的情况下寻找一种最简单的方法来移除元素。由于对于函数的唯一的要求是它必须把A映射到自身，故我们会很自然地选择一个没有其他元素映射到的元素。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 15px; font-weight: bold;&#34;&gt;检查线段的包含情况【Q3】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;问题：输入是一条线上一系列间断线段的集合I1,I2&amp;hellip;In。对于每一个线段Ij都给出了它的两个端点Lj（左端点）,Rj（右端点）。我们想标记出所有包含在其他线段中的线段。换句话说，一个线段Ij必须被标记出来，如果存在另一条线段Ik(k≠j)并且满足Lk≤Lj以及Rk≥Rj。为了简化起见我们假定所有的线段都是不一样的（例如任意两个线段都不可能同时具有相同的左端点和右端点，但是它们可能有两个端点中的某一个相同）。图2展示了这样的一个线段集合。（为了更好的展示，每一条线段都放在另一条线段上面而不是放在一条线上）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hi.csdn.net/attachment/201107/27/0_1311738153VQ53.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;用直观的方法使用归纳法主要是移除一个线段I，对于剩下的线段使用递归的方法加以解决，然后在检查把I放回后的效果。问题在于把线段I放回需要检查所有其他的线段来判断他们中是否包含I或者被I所包含。这需要检查I和其余n-1条线段，算法中使用的比较将达到n-1+n-2+&amp;hellip;+1=n(n-1)/2次。为了获得一个更好的算法我们需要做两件事：首先我们选择一条特殊的线段加以移除，其次我们尽可能多的使用从更小规模问题的解决方案中收集到的信息。&lt;/p&gt;

&lt;p&gt;选定I为所有线段中具有最大左端点值的线段，由于其他线段左端点值都较之小，这样就不需要再检查左端点值了。因此，为了要检查I是否包含于其他线段之中，我们只需要检查其他线段中是否有右端点值比I右端点值更大的线段。为了找到这么一条具有最大左端点值的线段我们可以依据线段的左端点值对所有线段进行排序并且按照次序对其进行搜索。假定线段已经按照次序排好，L1≤L2≤&amp;hellip;≤Ln。归纳假设如下：&lt;/p&gt;

&lt;p&gt;归纳假设：我们已经知道如何去解决包含I1,I2&amp;hellip;In-1条线段的问题。&lt;/p&gt;

&lt;p&gt;最基本的问题很简单，如果只有一条线段，那么它肯定不会被标记。现在我们来考虑In。通过归纳假设我们知道已经确定了在线段I1到In-1中有哪些线段是包含在其他线段之中的，我们需要确定In是否包含其他（之前没有被标记过）的线段，以及In是否被包含在其他线段之中。让我们首先来检查In是否被包含在其他线段之中。如果In被包含在一条线段中，假如是Ij,j&amp;lt;n，于是Rj≥Rn。这是唯一的必要条件（因为排序已经确保了Lj≤Ln）。因此我们只需要在之前的线段中记录拥有的最大右端点值即可。把该右端点值与Rn进行比较就能给出我们答案。我们稍微改变一下归纳假设：&lt;/p&gt;

&lt;p&gt;更强的归纳假设：我们已经知道如何解决I1,I2&amp;hellip;In-1的问题，同时也找出了他们中右端点的最大值。&lt;/p&gt;

&lt;p&gt;我们再一次让In作为拥有最大左端点值的线段，然后让MaxR作为前n-1条线段中右端点的最大值。如果MaxR≥Rn，那么In就应该被标记，否则(MaxR≤Rn)Rn就成为新的最大的最大值。（这最后一步是必要的，因为我们现在不仅仅是标记线段，同时我们也在寻找最大的右端点值。）我们现在仅通过一步检查就能确定In的状态。&lt;/p&gt;

&lt;p&gt;为了完成这个算法我们需要检查In是否包含一条之前未被标记过的线段。In包含一条线段Ij,j&amp;lt;n，只有当满足条件Lj=Ln且Rj&amp;lt;Rn时才行。我们可以通过增强排序功能来处理这种情况。现在我们不仅按照左端点值进行排序，同时对于具有相同左端点值的线段，我们依据他们的右端点值的逆序来进行排序。这样能够排除上面提到的情况出现，因为Ij将会放置在In之后（右端点值较小），而且Ij的包含性将会被上一个算法找到。完整的算法如下所示：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;线段包含性算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;(I1,I2,&amp;hellip;In:线段)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;{用一对Lj,Rj来给出一条线段Ij}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;{我们假定没有两条线段是完全一样的}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;{当Ij被包含在另一条线段中时，Mark[j]将会被标记为真}&lt;/strong&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;begin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;** 按照线段的左端点值递增次序对所有线段进行排序**&lt;/p&gt;

&lt;p&gt;** 具有相同左端点值的线段按照他们右端点值递减的次序进行排序**&lt;/p&gt;

&lt;p&gt;** {for all j&amp;lt;k either Lj&amp;lt;Lk or Lj=Lk and Rj&amp;gt;Rk}**&lt;/p&gt;

&lt;p&gt;** MaxR:=R1;**&lt;/p&gt;

&lt;p&gt;** for j:=2 to n do**&lt;/p&gt;

&lt;p&gt;** if Rj≤MaxR then**&lt;/p&gt;

&lt;p&gt;** Mark[j]:=true;**&lt;/p&gt;

&lt;p&gt;** else**&lt;/p&gt;

&lt;p&gt;** Mark[j]:=false;**&lt;/p&gt;

&lt;p&gt;** MaxR:=Rj;**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;end;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;复杂度：除了排序外，这个算法包含一个涉及到O(n)步操作的循环。由于排序需要O(nlogn)步操作，故其占据了算法主要的运行时间。&lt;/p&gt;

&lt;p&gt;总结：这个例子阐明了一个不是那么直接运用归纳法的方法。首先我们选择可以运用归纳法执行的序列。然后我们设计归纳假设，该假设能够暗示出期望的结果同时它也易拓展。重点放在这些步骤上就能让对很多算法的设计变得简单。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 20px; font-weight: bold;&#34;&gt;明智的选择归纳序列&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在前面的例子中，重点都放在寻找一个缩减问题规模的算法上。这是使用归纳法的本质。然而有很多方法也能实现这一点。首先，问题可能包含一些参数（例如图中的左端点右端点，顶点和边），我们必须决定对其中哪一个参数进行缩减。其次，我们可能能够排除掉许多可能元素，但我们想选择其中最容易的一个。（例如最左边的端点，最小的数字）第三，我们可能想对问题加强限制条件（例如线段是有序排列的）。当然还有其他很多变化。例如我们可以假设我们已经知道对一些小于n的值的问题如何解决而不是仅仅的n-1。这往往是一个有效的假设。任何缩减问题规模的做法都是值得考虑的，因为这种做法能够引导我们回到问题的最基本情况，而这时往往我们能够直接解决。回到在归纳法中讨论的排序例子，我们可以把对n个元素的排序缩减为对两个各含n/2个元素的子集的排序。然后可以对这两个排好序的集合进行合并（引出一个称为归并排序的算法）。把问题分解（归纳性的）为一些相同的部分是一个很有用的技巧（我们将会在后面进行讨论），该技巧称为分治。&lt;/p&gt;

&lt;p&gt;一些问题的缩减很容易就能实现，然而一些却很难实现。一些规模的缩减能够带来很不错的算法，然而一些却不行。在很多情况下这就是问题中唯一的困难之处，一旦做出了正确的选择那么剩下的就很容易了（例如在映射问题中元素i的选择那样）。这在数学中极其重要。没有人能够不通过首先思考如何选择一个归纳序列就直接跳到归纳证明中去。正如估计的那样，这在算法设计中也是很重要的。在这一部分我们将给出两个例子，在这两个例子中，缩减序列的重要性得到了体现。特别是名人的例子，它说明了一种不同于一般的顺序。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 15px; font-weight: bold;&#34;&gt;拓扑排序【Q4】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;假设这里有一系列的任务，这些任务每次只能执行其中一个。其中有一些任务要依赖其他任务的完成，如果其他任务没有完成则这些任务不可能开始执行。已知所有的依赖关系，我们想找到一个符合依赖关系的任务安排计划表。（即每一个被计划执行的任务只有在它依赖的任务全部完成时才可以开始执行）我们想要设计一种能够迅速产生出这么一个计划表的算法。该问题也就是拓扑排序。任务和他们的依赖关系能够通过一幅有向图得到展现。一个有向图拥有一个顶点的集合V（与例子中的任务相对应），以及一个由一对顶点构成的边的集合E。如果一个与v对应的任务必须在一个与w对应的任务之前执行，那么图中就存在一条从v到w的边(表示(v,w)∈E)。该图一定为无环图，否则环上的任务将永远不可能开始执行。这里给出了使用图来说明问题的简单描述。&lt;/p&gt;

&lt;p&gt;问题：给定一个有n个顶点的有向无环图G=(V,E)，这些顶点从1到n进行编号，因此如果顶点v被标记为k，那么顶点v可以通过一条直接路径到达所有编号大于k的顶点。（一条路径是一系列点的序列，这些点v1,v2&amp;hellip;vk通过边(v1,v2),(v2,v3)&amp;hellip;(vk-1,vk)相连）&lt;/p&gt;

&lt;p&gt;我们再一次尝试依据规模更小的问题来解决这个问题。考虑一个更小问题的直接做法是移去一个顶点。换句话说，通过下面的方法可以看到归纳法蕴含在顶点的数量之中。&lt;/p&gt;

&lt;p&gt;归纳假设1：我们已经知道如何按照上面描述的条件用n-1个顶点为所有的图做上标记。&lt;/p&gt;

&lt;p&gt;只有一个顶点的最基本的情况是很简单的。如果n&amp;gt;1，我们可以移去一个顶点，然后尝试使用归纳假设，再尝试去拓展标记。我们首先需要核实的一点是移除一个顶点后的问题和原来的问题是一样的（除了更小的规模外）。拥有一个一样的问题很必要，否则归纳假设将无法使用。例子中唯一假设是图不是循环图。由于移除一个顶点不可能产生一个循环图，那么这种缩减是可行的。&lt;/p&gt;

&lt;p&gt;这种缩减的问题在于尽管假设可以使用但我我们不清楚如何去拓展解决方法，即怎么去标记移除的顶点。我们解决该问题的方案是精心选择顶点v。由于移去任何一个顶点产生的规模更小的问题都是符合要求的，所以我们可以任意选择一个顶点作为第n个顶点。因此，我们应该移除那些最容易获取标记的点。一个明显的选择是那些没有依赖关系的顶点（任务），也就是该顶点的入度（指向该点的边数）为0。可以把该顶点标记为1，这不会带来什么错误。&lt;/p&gt;

&lt;p&gt;但是，我们总能找到一个入度为0的点么？答案按直觉是肯定的，但我们必须从某个地方开始。毫无疑问的是，如果所有的顶点都有大于0的入度我们可以用各种方式遍历图而且永远不会停止。但是由于只有有限数量的顶点需要我们去循环查找，这与我们的假设是相矛盾的。（同理我们也可以从出度为0的顶点开始寻找，然后把该顶点标记为n）剩下的算法就很清晰了。移除选择的顶点的相邻边，剩下的图依然是无环图，再用2到n标记图的剩余部分。由于我们需要用2到n而不是1到n-1标记剩下的图，我们需要对归纳假设做点改动。&lt;/p&gt;

&lt;p&gt;归纳假设2：我们知道依据问题的条件如何使用n-1不同标记的集合去标记一个拥有n-1个顶点的图。&lt;/p&gt;

&lt;p&gt;下面给出与之对应的算法&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;拓扑排序算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;{G={V,E}:一个有向无环图};&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;begin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;** 对所有的顶点的入度初始化;**&lt;/p&gt;

&lt;p&gt;** {可以通过深度优先搜索}**&lt;/p&gt;

&lt;p&gt;** G_label:=0;**&lt;/p&gt;

&lt;p&gt;** for i:=1 to n do**&lt;/p&gt;

&lt;p&gt;** if vi.indegree=0 then put vi in Queue;**&lt;/p&gt;

&lt;p&gt;** repeat**&lt;/p&gt;

&lt;p&gt;** remove vertex v from Queue;**&lt;/p&gt;

&lt;p&gt;** G_label:=G_label + 1;**&lt;/p&gt;

&lt;p&gt;** v_label:=G_label;**&lt;/p&gt;

&lt;p&gt;** for all edges(v,w) do**&lt;/p&gt;

&lt;p&gt;** w.indegree:=w.ingegree-1;**&lt;/p&gt;

&lt;p&gt;** if w.indegree=0 then put w in Queue**&lt;/p&gt;

&lt;p&gt;** until Queue is empty**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;end;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;复杂度：初始化入度计数器需要O(|V|+|E|)时间（例如在例子中使用深度优先搜索）。找到一个入度为0的点要花费常数时间（访问队列）。每一条边（v,w）被考虑一次（当v从队列中被取出时）。因此，计数器需要更新的次数的多少就是图中边数目的多少。因此算法的执行时间就是输入规模的线性时间O(|V|+|E|)。&lt;/p&gt;

&lt;p&gt;总结：这是另一个使用归纳法直接设计算法的例子。这里的技巧在于明智选择归纳序列。我们不是武断地缩减问题规模，而是选择移除一个特殊的顶点。任何给定的问题的规模都可以用很多可能的方法加以缩减。思想就在于探寻各种各样的选择然后测试产生的算法。我们从多项式计算这个例子中看到从左向右要比从右向左好。另一个通常的可能性是对从上往下和从下往上进行比较。同样也可能每次递增2而不是递增1，当然还有更多的可能情况。有时最好的归纳序列甚至对于所有的输入来说也是不尽相同的。设计一个特殊的算法去寻找一个对问题执行规模缩减的最好的方法有时是值得的。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 15px; font-weight: bold;&#34;&gt;名人问题【Q5】（不知道业界如何翻译）&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在算法设计中有一个很流行的练习。这是一个非常好的例子，该例子的解答不需要扫描全部数据（甚至是数据的重要的组成部分）。在n个人中，一个名人被定义为其他人都认识但是自己却不认识其他人的人。该问题就是存在名人的情况下确定名人，只能通过以一种“您好，请问您认识站在那里的人么？”的方式提问。（假定所有的回答都是正确的，甚至是名人自己也会给出答案）我们的目标是让最小化提问的次数。由于存在n(n-1)/2对人，在最坏的情况下，如果问题被武断地提出，有可能需要询问n(n-1)次问题才行。我们不清楚我们能比最坏的情况做的更好。&lt;/p&gt;

&lt;p&gt;在技术上，如果我们建立一个用顶点表示人的有向图，当A认识B就有一条从A到B的边，那么一个名人就对应一个汇点。（非有意的双关语）也就一个入度为n-1出度为0的顶点。该图可以用一个n×n邻接矩阵来表示，如果第i个人认识第j个人那么在该矩阵中位于第i行第j列的位置被标记为1，否则就为0。该问题也就是通过查找矩阵中尽可能少的条目确定汇点。&lt;/p&gt;

&lt;p&gt;像往常一样，我们考虑有n-1个人和有n个人时问题的不同之处。既然由定义可知最多存在一个名人，那这里就有三种可能。其一，名人在前n-1个人中；其二，名人是第n个人；其三，这里没有名人。第一种情况最容易处理，我们只需要核对第n个人认识名人，但是名人并不认识第n个人的局面是否存在。其他两种情况就比较困难了，因为为了确定第n个人是否是名人，我们可能需要提2&lt;em&gt;(n-1)个问题。在最坏的情况下，这可能会导致n&lt;/em&gt;(n-1)个问题（这是我们试图避免发生的）。我们需要另一种解法。&lt;/p&gt;

&lt;p&gt;这里的技巧在于从逆向考虑这个问题。确定一个名人可能很难，但是确定某个人不是名人可能要简单很多。毕竟，很明显在这里非名人要比名人多。把某人排除出考虑对把问题规模从n缩减到n-1来说已经足够了。此外，我们不需要排除出特定的人，任何人都可以。假设我们问Alice她是否认识Bob，如果她认识她就不会是一个名人，如果她不认识&lt;/p&gt;

&lt;p&gt;那Bob就不会是一个名人。我们可以通过一个问题排除出他们中间的一个。&lt;/p&gt;

&lt;p&gt;现在考虑上面列出的三种情况。我们不只是任意挑选一个人作为第n个人。我们使用上面的思想去排除出Alice和Bob中的一个，然后对其余包含n-1个人的问题进行求解。我们保证情况2不会发生，因为排除出去的人不可能是名人。此外，如果情况3发生，也就是说在n-1个人中没有名人，那在n个人中也不会有名人。只有情况1存在，但是正如上面提到的，这种情况很简单。如果在n-1个人中存在一个名人，只需要提出两个问题就可以确定整个集合中是否存在名人了。否则就不会有名人存在。&lt;/p&gt;

&lt;p&gt;所得到的算法如下。我们问A是否认识B，根据A的回答排除掉他们其中的一个。假设排除的是A，然后我们在剩下的n-1个人中寻找（通过归纳法）一个名人。如果没有名人，那么算法就终止。否则我们核实A认识名人但是名人不认识A这种局面。下面给出一个非递归的算法实现。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;名人算法（已知n×n的布尔矩阵）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;begin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;** i:=1;**&lt;/p&gt;

&lt;p&gt;** j:=2;**&lt;/p&gt;

&lt;p&gt;** next:=2;**&lt;/p&gt;

&lt;p&gt;** {在第一步中我们排除了除了一个候选人以外的所有人}**&lt;/p&gt;

&lt;p&gt;** while next≤n do**&lt;/p&gt;

&lt;p&gt;** next:=next+1;**&lt;/p&gt;

&lt;p&gt;** if Know[i,j] then i:=next;**&lt;/p&gt;

&lt;p&gt;** else j:=next;**&lt;/p&gt;

&lt;p&gt;** {我们排除i和j中的一个} **&lt;/p&gt;

&lt;p&gt;** if i=n+1 then candidate:=j else candidate:=i;**&lt;/p&gt;

&lt;p&gt;** {现在我们核实该候选人是否确实是名人}**&lt;/p&gt;

&lt;p&gt;** wrong:=false;k:=1;**&lt;/p&gt;

&lt;p&gt;** Know[candidate,candidate]:=false;**&lt;/p&gt;

&lt;p&gt;** {只是一个用来测试的虚拟变量}**&lt;/p&gt;

&lt;p&gt;** while not wrong and k≤n do**&lt;/p&gt;

&lt;p&gt;** if Know[candidate,k] then wrong:=true;**&lt;/p&gt;

&lt;p&gt;** if not Know[k,candidate] then**&lt;/p&gt;

&lt;p&gt;** if candidate ≠ k then wrong:=true;**&lt;/p&gt;

&lt;p&gt;** k:=k+1；**&lt;/p&gt;

&lt;p&gt;** if not wrong then print&amp;rdquo;candidate is a celebrity!&amp;rdquo;**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;end;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;复杂度：这里最多只需要提3&lt;em&gt;(n-1)个问题。在第一步中提n-1个问题从而从候选人中排除掉n-1个人。为了确定那个候选人是否是名人最多只需要提2&lt;/em&gt;(n-1)个问题。上面给出的解答表明可以在邻接矩阵中仅查找O(n)条记录就能确定一个名人，尽管从推理上认为问题的解法与n(n-1)项输入都密切相关。（这里也可能节省掉额外的log2(n)【取下限】次提问，只需要在验证过程中以及提问排除过程中注意避免重复即可）&lt;/p&gt;

&lt;p&gt;总结：这个极佳的解法的核心思想在于用一种明智的方式把问题规模从n缩减到n-1。这个例子表明了有时候在更有效的进行问题规模的缩减上花一些努力（在该例子中提出一个疑问）是值得的。此外，逆向思维在本问题中显得很有用。与其去寻找一个名人我们不如尝试去排除非名人。这在数学证明时经常用到。一个人不需要直接去尝试解决问题。有时解决能够给原先问题带来解答的相关问题要简单一些。为了找到这些相关的问题，在开始时使用成品（数学证明中的得到的定理），然后逆向进行我们的工作看看实现这个成品需要什么东西，这往往是很有用的做法。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 20px; font-weight: bold;&#34;&gt;加强归纳假设&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在用归纳法证明数学定理时，加强归纳假设被当做一种很重要的技巧使用。当尝试使用一个归纳证明时常常会遇到下面的情况。定理用P(n)表示，归纳假设可以用P(n-1)表示，要证明结论P(n-1)推导出P(n)。很多情况下可以加上另一个假设，称为Q，在这个假设下证明会变得更简单。也就是说，证明P(n-1)和Q推导出P(n)要更加容易。这种结合的假设看上去是正确的但是还不清楚如何去证明。技巧在于在归纳假设中加上Q(如果可能的话)。现在需要证明&lt;a href=&#34;n-1&#34;&gt;P和Q&lt;/a&gt;推导出&lt;a href=&#34;n&#34;&gt;P和Q&lt;/a&gt;。结合的定理[P和Q]和仅有P相比是一个更强的定理，但是有时候更强的定理却更容易去证明（Polya称这个原理为“发明家的悖论”）。这个过程可以反复，加上正确补充的假设，定理的证明变得简单。我们在表达式计算和线段包含问题中已经初步看到了这个原理。&lt;/p&gt;

&lt;p&gt;在这部分中我们给出两个例子来展现加强归纳假设的运用。第一个问题很简单，但它阐明了使用这种技巧时最常见的错误，也就是忽视了加入额外假设这个事实从而忘记更新证明过程。换句话说，证明P(n-1)和Q推导出P(n)时没有注意到Q是被假设的。我们可以把这种转换类比与解决更小的问题，不过该问题和原先的问题已经不是完全一样的了。第二个例子更复杂一些。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 15px; font-weight: bold;&#34;&gt;在二叉树中计算平衡因子【Q6】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;假设T是一个以r为根的二叉树。节点v的高度就是v和树中最底层的叶子之间的距离（应该是节点下方的树的最底层叶子）。节点v的平衡因子被定义为节点v的左孩子和它的右孩子（我们假设一个节点的孩子被标记为左和右）高度之差。图3给出了一棵树，在树中每个节点用h/b来标记，h是节点的高度，b是节点的平衡因子。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hi.csdn.net/attachment/201107/27/0_13117382109MS8.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;问题：给出一个拥有n个节点的树，计算它所有节点的平衡因子。&lt;/p&gt;

&lt;p&gt;我们使用基本的归纳算法以及直截了当的归纳假设：&lt;/p&gt;

&lt;p&gt;归纳假设：我们已经知道如何去计算小于n个节点的平衡因子。&lt;/p&gt;

&lt;p&gt;最基本的n=1的例子很简单。给定一个拥有n&amp;gt;1节点的二叉树，我们移去根节点，然后用递归的方法解决剩下的子树。我们选择移去根节点因为一个节点的平衡因子仅仅依赖于节点下面的节点。我们现在已经知道出了根节点以外其他所有节点的平衡因子。但是根节点的平衡因子不是依赖于它的孩子的平衡因子而是依赖于它的孩子的高度。因此，一个简单的归纳法无法适用于这个例子。我们需要知道根节点孩子的高度。思想就在于在原先的问题中加上高度查询这个问题。&lt;/p&gt;

&lt;p&gt;加强的归纳假设：我们已经知道如何计算小于n个节点的平衡因子以及它们的高度。&lt;/p&gt;

&lt;p&gt;再一次的，基本问题很简单。现在考虑根节点时可以简单通过比较它的孩子的高度确定出它的平衡因子。此外，根节点的高度也能够被简单确定，也就是它两个孩子高度的最大值加上1。&lt;/p&gt;

&lt;p&gt;这个算法的关键也就是解决一个简单拓展的问题。我们也计算高度而不只是计算平衡因子。拓展后的问题要更简单因为高度是很容易计算出来的。在很多情况下，解决一个更强的问题反而更简单。这对于归纳法说尤其正确。使用归纳法，我们仅需要把一个小问题拓展成一个更大的问题。如果解法更宽泛（因为问题被拓展了）那么归纳步骤可能要更简单因为我们有更多的东西可用。在该问题中常见的一个错误是忘记其中有两个不同的变量，而且这两个变量必须要单独计算。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 15px; font-weight: bold;&#34;&gt;最近对【Q7】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;问题：给定平面上一个点的即可，找出最近两点之间的距离。&lt;/p&gt;

&lt;p&gt;最直接使用归纳法的方法是移去一个点，解决n-1个点的问题，然后再考虑那个额外的点。然而，如果从对n-1个点的情况的求解中仅仅知道他们中间的最小距离，那么从额外点到其余n-1个点的距离都需要被计算出来。这样使得计算距离的总次数变成n-1+n-2+&amp;hellip;+1=n(n-1)/2。（这其实是一个直接比较每两点的算法）我们想找到一个更快的解法。&lt;/p&gt;

&lt;p&gt;一种分治算法&lt;/p&gt;

&lt;p&gt;归纳假设如下所示&lt;/p&gt;

&lt;p&gt;归纳假设：我们已经知道在平面上如何去查找少于n个点中任意两点之间的最短距离。&lt;/p&gt;

&lt;p&gt;既然我们假设我们能够解决少于n个点的子问题，我们可以把问题缩减为两个含有n/2个点的子问题。我们假设n是2的幂，这样我们总可以把一个集合分成数量两个相等的集合。（我们再后面再讨论这个假设）有很多方法可以把一个点集分成两个相等的部分。我们可以自由选择最好的方法。我们想要从规模较小问题的解法中获得尽可能多有用的信息，因此我们想要在考虑整个问题时尽可能多的保持有效。看起来这里把问题分解为两个不相关各含一半元素的部分是有道理的。当我们找到每个子集中最小的距离后，我们只需要关心那些靠近集合边界的点之间的距离。距离来说，对所有点进行排序最简单的方法是按照它们的x坐标进行排序，把平面用一条垂直线进行分割从而把集合一分为2（见图4）。（如果有一些点位于垂直线上我们任意把它们分配给两个集合中的一个，从而确保两个集合有相等的元素）我们选择这样划分的原因是使得合并解答时要做的工作尽可能少。如果这两个部分以某种方式交叉着，那样会使得对最近对点的检查变得更复杂。排序需要仅被执行一次。&lt;/p&gt;

&lt;p&gt;给定一个集合P，我们按照上面的做法把它分解为P1和P2两个数量相等的子集。然后我们通过归纳法去查找每个子集中最近的两点距离。我们假设P1中最短的距离是d1，P2中是d2。不失一般性的，我们进一步假设d1≤d2。我们需要找到整个集合中最小的距离，也就是说我们需要去查找P1中的一个点到P2中的一个点是否有小于d1的距离。首先我们注意到只需要考虑以两部分中间的垂直线为中心宽度为2d1的带状范围内的点就足够了（见图4）。在该区域外的点中任意两点之间不可能拥有比d1更小的距离。通过上面的观察我们通常能够把很多点从考虑中排除，但是在最坏的情况下所有的点都可能仍位于这条带状区域中，对于它们我们无法使用直接的算法。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hi.csdn.net/attachment/201107/27/0_1311738245v7H2.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;另一个不是那么明显的观察点是对于在带中的任意点p，在另一边有很少的点到p点的距离要比d1小。原因在于在带中一边的所有点至少间隔为d1.假设p是带中的一个点，它的y坐标为yp，那么只需要考虑在另一边有坐标yq且满足|yp-yq|&amp;lt;d1的点即可。在带的每一边最多有六个这样的点（见图5中最坏的情况）。结果是如果我们以点的y坐标针对所有带中的点进行排序并且按顺序扫描这些点，我们只需要检查每一个点和按序排列中它的常数个邻居即可（而不是全部n-1个点）。我们在这里省略这个事实的证明（见例子[15]）。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hi.csdn.net/attachment/201107/27/0_13117382582wZn.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最近对算法{首次尝试}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;{p1,p2&amp;hellip;pn:平面上的点}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;begin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;** 按照点的x坐标对点进行排序{该排序只在开始时运行一次}**&lt;/p&gt;

&lt;p&gt;** 把集合划分成两个相等的部分**&lt;/p&gt;

&lt;p&gt;** 递归计算每个部分中最小的距离**&lt;/p&gt;

&lt;p&gt;** 把d赋值为两个最小距离中的最小值**&lt;/p&gt;

&lt;p&gt;** 排除出分割线d距离范围外的点**&lt;/p&gt;

&lt;p&gt;** 按照y坐标对剩下的点进行排序**&lt;/p&gt;

&lt;p&gt;** 按照y顺序扫描这些点并计算每个点和它的五个邻居之间的距离{事实上，4个就够了}**&lt;/p&gt;

&lt;p&gt;** if 这些距离中有小于d的 then**&lt;/p&gt;

&lt;p&gt;** 更新d值**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;end;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;复杂度：按照x坐标进行排序需要花费O(nlogn)时间，但是这仅仅需要执行一次。然后我们解决规模为n/2的两个子问题。排除出带状区域以外的点可以在O(n)的时间内完成。接下来在最坏的情况下按照y坐标对剩下的点进行排序需要O(nlogn)步。最终，扫描带中的点并在序列中把它与常数个邻居进行比较需要O(n)步。总的来说，为了在n个点中查找最近对，我们在含有n/2个点的子集中找到两个最近对，然后花费O(nlogn)的时间去寻找两个子集之间的最近对(加上一次按照x坐标进行排序的时间O(nlogn))。带来的递推关系如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;T(n)=2T(n/2)+O(nlogn), T(2)=1.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这个关系的解答是T(n)=O(n(logn)^2)。这比一个二次的算法要好，但是我们可以做的更好。现在我们来看看归纳法更巧妙的使用方法。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;一个O(nlogn)的算法&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这里的关键思想是加强归纳假设。由于要排序我们在合并步骤需要花费O(nlogn)的时间。尽管我们知道如何直接解决这个问题，但是它耗时太长。我们能够做到在解决排序问题的同时解决最近对问题么？换句话说，我们想加强归纳假设把排序作为最近对问题的一部分包含进来从而得到一个更好的解法。&lt;/p&gt;

&lt;p&gt;归纳假设：给定平面上一个少于n个点的集合，我们知道如何去寻找它们之间的最近距离也知道如何按照y坐标排序后输出该集合。&lt;/p&gt;

&lt;p&gt;我们已经知道如果知道如何排序那该怎样去寻找最小距离。因此，唯一需要做的事情是如果我们知道两个含有n/2的子集排序顺序那该如何对整个集合进行排序。换句话说，我们需要把两个有序的子集合并成一个有序的集合。合并可以在线性的时间内完成（见例【1】）。因此，递归关系变成如下：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;T(n)=2T(n/2)+O(n), T(2)=1,&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这也意味着T(n)=O(nlogn)。该算法和上一个算法唯一的区别是按照y坐标排序时不必每次都从头开始进行。当我们执行时使用加强的归纳假设来进行排序。下面给出的是改进后的算法。该算法是由Shamo和Hoey(见[15])提出来的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;最近对算法 {一个改进的版本}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;** {p1,p2&amp;hellip;pn:平面上的点}**&lt;/p&gt;

&lt;p&gt;** begin**&lt;/p&gt;

&lt;p&gt;** 按照x坐标对点进行排序**&lt;/p&gt;

&lt;p&gt;** {该排序只有在开始时执行一次}**&lt;/p&gt;

&lt;p&gt;** 把该集合划分为两个相等的部分；**&lt;/p&gt;

&lt;p&gt;** 递归的执行下面的步骤**&lt;/p&gt;

&lt;p&gt;** 计算每个部分中最小的距离；**&lt;/p&gt;

&lt;p&gt;** 按照y坐标对每个部分的点进行排序；**&lt;/p&gt;

&lt;p&gt;** 把两个有序的列表合并成一个有序列表；**&lt;/p&gt;

&lt;p&gt;** {请注意我们必须在排除点之前合并，我们需要为下一阶段的递归提供有序的全集}**&lt;/p&gt;

&lt;p&gt;** 把d赋值为两个最小距离中的最小者;**&lt;/p&gt;

&lt;p&gt;** 排除出分割线d距离范围外的点**&lt;/p&gt;

&lt;p&gt;** 按照y坐标对剩下的点进行排序**&lt;/p&gt;

&lt;p&gt;** 按照y顺序扫描这些点并计算每个点和它的五个邻居之间的距离{事实上，4个就够了}**&lt;/p&gt;

&lt;p&gt;** if 这些距离中有小于d的 then**&lt;/p&gt;

&lt;p&gt;** 更新d值**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;end;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 20px; font-weight: bold;&#34;&gt;更强的归纳法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;更强的归纳法(有时也被称为结构化归纳法)的思想在于不仅仅使用定理对于n-1(或者其他小于n的值)成立的假设，也使用定理对所有k(1≤k&amp;lt;n)成立的更强假设。把这种技巧转换到算法设计中需要维持一个含有所有小问题解法的数据结构。因此，该技巧通常引起更多的空间占用。我们给出一个使用这种技巧的例子。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 15px; font-weight: bold;&#34;&gt;背包问题【Q8】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;背包问题是一个很重要的优化问题。它也有很多不同的变种，但这里我们只讨论其中的一种变种。&lt;/p&gt;

&lt;p&gt;问题：这里有n个不同大小的物品。第i个物品有一个整型的大小ki。问题是找到一个物品的子集使得该集合的大小总和正好为K，或者我们确定不存在这样的子集。换句话说，给我们一个大小为K的背包我们想把它装满物品。我们把这个问题表示为P(n,K)，第一个参数表示物品的数目，第二个参数表示背包的大小。我们假设大小是固定的。我们用P(j,k)(j≤n且k≤K)表示有j个物品和大小为k的背包问题。为了简化，我们仅关心问题的结论，也就是决定是否存在这样的一个解答。在后面我们给出如何去寻找到一个解答。&lt;/p&gt;

&lt;p&gt;我们首先从最直接的归纳法开始。&lt;/p&gt;

&lt;p&gt;归纳假设：我们知道如何去解决P(n-1,K)的问题。&lt;/p&gt;

&lt;p&gt;基本情况很简单，如果仅有一个大小为K的物品有办法解决。如果有解决P(n-1,K)的办法，也就是说如果有能够把n-1个物品放入背包的方法我们就算完成了。我们只需要简单的不使用第n个物品即可。然而，假设没有对P(n-1,K)的解决方法，我们能够使用这个否定的结论么？答案是可以的，这也意味着第n个物品必须被包含进去。在这种情况下，剩下的物品必须装入一个更小的容量为K-kn的背包。我们把问题简化为了两个更小的问题：如果P(n,K)有解那么P(n-1,K)或者P(n-1,K-kn)两者中间必须有一个有解。为了完成这个算法我们不仅需要求解容量为K的背包问题也需要求解对最大容量为K的所有背包的问题。（这里存在把背包容量限制在一些减去ki后的大小之中，但是也可能不存在这样的限制条件）&lt;/p&gt;

&lt;p&gt;更强的归纳假设：我们已经知道对所有的0≤k≤K如何去求解P(n-1,k)。&lt;/p&gt;

&lt;p&gt;上面的简化并不依赖于一个特定的k值，它对所有的k值都是有效的。我们可以使用这个归纳假设解决所有的0≤k≤K的P(n,k)问题。我们把P(n,k)简化为P(n-1,k)和P(n-1,k-kn)这两个问题。（如果k-kn&amp;lt;0我们就忽略第二个问题）这两个问题都可以用归纳法求解。这是一个有效的简化我们也能找到一个算法，但是该算法效率不高。我们得到的仅是规模稍小一点的两个子问题。因而在对规模的每步简化中子问题的个数也是翻倍增长。由于对规模的简化可能不是那么确切，算法可能是按照指数级增长。（根据ki的值来确定）&lt;/p&gt;

&lt;p&gt;幸运的是，在很多情况下对这种问题提高运行效率是可行的。主要的观察是可能的问题的总数不是很多。事实上，我们引入P(n,k)这个记号来表示该问题。对第一个参数存在n种可能性，对于第二个参数存在K种可能性。总的来说，这里只有n*K种不同可能性的问题。在每次简化后对问题数目翻倍会带来指数运行时间，但是如果这里只有n*K个不同的问题我们肯定对同一个问题求解了多次。如果我们记下了所有的解答我们就不需要对同一个问题求解两次。这实际上是加强归纳假设和使用更强的归纳法（使用对所有已知的更小规模问题而不仅仅对n-1问题解答的假设）的结合。下面来看看我们如何实现该方法。&lt;/p&gt;

&lt;p&gt;我们把所有已知的结果存放在一个n×K的矩阵中。矩阵中第ij个位置包含着P(i,j)的解答信息。使用上面更强的归纳假设后，问题简化为基本上计算矩阵的第n行值即可。第n行的每个条目是通过其上的两个条目计算得到的。如果我们对找到实际的集合感兴趣的话，我们可以在每个位置加上一个标记字段，该字段可以表示在那步操作中对应的物品是否被选中。标记字段可以从第(n,K)个位置倒推，集合也可以被复原。这个算法列在下一列顶部。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;背包算法{k1,k2&amp;hellip;kn,K:整型};&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;{如果对于前i个元素和容量为j的背包有解那么P[i,j].exist=true，如果第i个元素包含在解中那么P[i,j].belong=true}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;begin&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;** P[0,00].exist:=true;**&lt;/p&gt;

&lt;p&gt;** for j:=1 to n do**&lt;/p&gt;

&lt;p&gt;** P[0,j].exist:=false;**&lt;/p&gt;

&lt;p&gt;** for i:=1 to n do**&lt;/p&gt;

&lt;p&gt;** for j:=0 to K do**&lt;/p&gt;

&lt;p&gt;** P[i,j].exist:=false;{默认值}**&lt;/p&gt;

&lt;p&gt;** if P[i-1,j].exist then**&lt;/p&gt;

&lt;p&gt;** P[i,j].exist:=true;**&lt;/p&gt;

&lt;p&gt;** P[i,j].belong:=false;**&lt;/p&gt;

&lt;p&gt;** else if j-ki≥0 then**&lt;/p&gt;

&lt;p&gt;** P[i-1,j-ki].exist then**&lt;/p&gt;

&lt;p&gt;** P[i,j].exist:=true;**&lt;/p&gt;

&lt;p&gt;** P[i,j].belong:=true;**&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;end;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;复杂度：矩阵中有n×K个条目，从两个不同条目计算出一个条目需要常数时间。因此，总的运行时间是O(nK)。如果物品的大小不是特别大，那么K就不可能太大并且nK比n的指数表示要小很多。（如果K非常大或者是一个实数，那么这种方法就不高效）如果我们只关心确定是否存在一个解答那么答案就在P[n,K]中。如果我们对找到实际的集合感兴趣，我们可以从第(n,K)个条目倒推，例如使用背包程序中的belong标志位，在O(n)时间内复原这个集合。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;p&gt;结论：我们刚才使用的是一种常见技术方法的一个具体实例，该方法被称为动态规划，它的本质是建立一个巨大的表，在表中填入已知的之前的解答。该表是用迭代的方法进行构造的。矩阵中的每个条目都是从其上或左侧的其他条目计算得到的。主要的问题是用一种最有效的方法进行表的构造。动态规划在问题仅能被简化为几个不是足够小的子问题时是有效的。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;

&lt;h2&gt;最大的反例&lt;/h2&gt;

&lt;p&gt;在证明数学定理中一种有特色并且强大的技巧是假设定理的反面成立然后找到一个矛盾。通常这是用一种完成非建设性的方式实现的，这对于我们的类比不是很有用。虽然有时通过一种和归纳法类似的方法能够找到一个矛盾。假设我们想证明一个确定的变量P（在一个给定的问题中）能够取到一个确定的值n。第一步我们给出P能够取到一个小值（基本情况）。第二步我们假设P无法取到n，我们可以考虑它能取到的最大值k&amp;lt;n。最后以及最主要的步骤是给出一个矛盾，通常针对最大化的假设。我们给出一个算法设计的例子，在该例子中这种技术非常有用。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 15px; font-weight: bold;&#34;&gt;稠密图中的最优匹配【Q9】&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在无向图G=(V,E)中一个匹配也就是一个没有公共顶点的边的集合。（一条边对应于两个点，一个点不可能对应于多余一个顶点）最大匹配是一个无法拓展的问题，意味着所有其他的边都至少与一个匹配的顶点相连。一个最大匹配也就是一个最大集。（一个最大匹配总是最大的，但是反过来说却未必正确）在图中一个拥有n条边和2n个点的匹配被称为最优匹配。（显然也是最大的）在这个例子中我们考虑一种很有限的情况。我们假设图中有2n个点，所有顶点的度都至少为n。可知在这些条件下总存在一个最优匹配。我们首先给出这个事实的证明，然后展示如何去修改这个证明从而得到一个查找最优匹配的算法。&lt;/p&gt;

&lt;p&gt;证明采用的是最大的反例。考虑一个图G=(V,E)，其中|V|=2n每个顶点的度至少为n。如果n=1那么这个图仅仅有一条边连接两个顶点，这就是一个最优匹配。假设n&amp;gt;1时不存在这样一个最优匹配。考虑到最大匹配M属于E。由假设知|M|&amp;lt;n，同时由于任意一条边自己就是一个匹配显然有|M|≥1。既然M不是完全的（不包括所有的点），那么就存在至少两个不相邻点v1和v2不被包含在M中（即它们不对应M中的一条边）。这两个点至少有2n个不同的边从它们射出。所有这些边通向那些包含在M中的顶点，否则这样的边就不可能被加入到M中。由于M中边的数目小于n而且从v1到v2有2n条边与之相连，M中至少有一条边，假定为(u1,u2)，与从v1到v2的三条边相连。为了不失一般性，我们假设这三条边是(u1,v1),(u1,v2)和(u2,v1)（见图6）。很容易可以看到通过从M中移除(u1,u2)加上边(u1,v2)和(u2,v1)我们能够得到一个更大的匹配，这与之前最大的假设相矛盾。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://hi.csdn.net/attachment/201107/27/0_1311738286343V.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;第一眼看上去这个证明好像无法产生一个算法，因为证明是从一个最大匹配开始的。一旦我们知道如何去寻找这样一个匹配我们就能够解决这个问题。然而，使用反证法适用于任何最大化的匹配，这里展示的只是用于最大匹配而已。查找一个最大化的匹配要比查找一个最大匹配简单。我们只需要简单的添加不相连的边（即那些没有公共顶点的边）直到不存在这样的边的可能。然后我们使用上面描述的步骤把该匹配转换为一个更大的匹配。通过上面的证明我们可以不断反复执行直到找到一个最优匹配。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 20px; font-weight: bold;&#34;&gt;其他证明技巧&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在这篇论文中我们关注于基于归纳法的证明技巧。这里有很多其他的技巧和更多的类比，一些事很明显的，一些则不那么明显。许多数学定理的证明是使用一系列的前提得到的，这直接对应于在标准设计和结构化编程的思想。证明中使用反证法在算法设计中也有类似的地方。研究那些使用“类似的论据”证明的类比是很有趣的一件事。&lt;/p&gt;

&lt;p&gt;我们这里简要列出四个证明技巧（其中的三个是基于归纳法的）以及它们的类比。更多的例子和类比可以在参考文献[12]中找到。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 15px; font-weight: bold;&#34;&gt;缩减法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;在证明定理和设计算法时，在问题之间使用缩减是一种很强大的技巧。如果问题A被指明是问题B的特例，那么解决B的算法可以被当成一个黑盒用来解决A。这个技巧对于解决下界和对问题进行分类也很有效（例如NP-完全问题）。如果已知问题A很难，那么问题B也至少一样难。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 15px; font-weight: bold;&#34;&gt;双倍归纳法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这是一种使用归纳法针对一次多余一个变量的方法。它可用于在归纳法最佳序列不明确的情况，同时在针对几个变量依据一个特定的步骤在其中进行选择时，该方法也很容易使用到。例如，如果问题包含n个物品和一个k维空间时，我们可能想在算法执行时减少物品的数量或者物品尺寸的数量【见例4】。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 15px; font-weight: bold;&#34;&gt;逆向归纳法&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;这个技巧在数学中不经常使用，但是在计算机科学领域却经常使用。普通的归纳法通过从一个基本情况(n=1)开始然后不断推广从而覆盖所有的自然数。假设我们想要逆推。我们假设它对n成立想要证明它对n-1也成立。我们称这种类型的证明为逆向归纳。但是，什么是最基本的情况呢？我们能够从一个n=M（M是一个非常大的数）的基本情况开始。如果我们证明它对n=M成立，然后我们就可以使用逆向归纳法从而证明对所有小于等于M的数也成立。尽管通常这样是不符合要求的，但在一些情况下却是满足要求的。例如，假设我们把双倍归纳法用于两个变量(即图中的顶点数和边数)。我们可以对一个变量应用普通的归纳法，如果第二个变量能够在第一个变量的范围内有界，那就对第二个变量使用逆向归纳法。例如，在一个有n个顶点的有向图中最多由n*(n-1)条边。对于n我们可以使用普通的归纳法并假设所有的边都是存在的（也就是说我们仅仅考虑完全图），然后对边的数目使用逆向归纳法。&lt;/p&gt;

&lt;p&gt;一种更常见的使用逆向归纳法的做法如下。仅对n中一个值的基本情况证明能限制于对那些比该值更小的值的证明（补充：证明了一个值比它小的值也就可以证明了）。假设我们能够直接对一个n取值无限的定理加以证明。例如无限集中包含所有2的幂。那么我们就可以使用逆向归纳法覆盖n的所有值。这是一种有效证明技巧，因为对于每个n取值在基本集中都存在一个比其大的值（由于集合式无限的）。&lt;/p&gt;

&lt;p&gt;使用这种技巧的一个非常好的例子是在算术平均不等式和几何平均不等式（柯西不等式）中用到的优雅的证明方法（例子见[3]）。当证明数学定理时，从n到n-1往往不比从n-1到n简单，同时证明一个无限集的基本情况要比一个简单集的基本情况困难的多。在设计算法时，与之相反的是，从n到n-1总是很容易，也就是针对更小的输入规模的问题求解。例如，我们可以引入那些不影响输出的假数据。结论是，在很多情况下不根据输入量的各种大小而是根据从无限集中取得的大小来设计算法往往是充分的。最常见的使用这种原理的做法是在设计算法时仅考虑是2的幂的n的大小输入。这使得设计更简洁也排除了很多杂乱的细节。很显然这些细节最终也需要被解决，但是它们往往很容易处理。例如在最近对问题中，我们使用n是2的幂的假设。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 20px; font-weight: bold;&#34;&gt;明智的选择归纳法的基本情况&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;很多递归算法（例如快排）对于小问题而言效果并不是很好。当问题被简化为一个小问题时，可以使用另一种简单的算法（例如插入排序）。从归纳法来看，这中做法符合选择一种n=k(k依据问题来定)基本情况然后使用一种直接的技巧来解决这种基本情况的思想。有些例子中这种做法甚至能够改善算法的渐近运行时间[12]。&lt;/p&gt;

&lt;p&gt;&lt;span style=&#34;font-size: 20px; font-weight: bold;&#34;&gt;结论&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;我们展示了一种解释和使用组合算法设计的方法。使用这种普通的方法的好处是两方面的。首先，它给算法设计者们提供了一个更加统一的“进攻路线”（处理问题方法）。给定一个待解决的问题，一个人可以通过使用文章中描述和阐明的技巧尝试找到一个解法。由于这些技巧有一些相似的地方（也就是数学归纳法），对它们全部进行尝试的过程能够被更好的理解也更容易进行。第二点，它提供了一种解释现有算法的的更统一的方法，使得学生能更多的参与创造过程。同时，对于算法正确性的证明在描述中占更重要的部分。我们相信这种方法能够包含在对组合算法进行教学之中。&lt;/p&gt;

&lt;p&gt;&amp;nbsp;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Staircar：Tumblr的Redis集群控制层</title>
      <link>http://blog.prosight.me/blogs/734</link>
      <pubDate>2011-07-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img class=&#34;alignnone&#34; title=&#34;Tumblr&#34; src=&#34;http://media.tumblr.com/tumblr_lol77xDgkf1qz6daf.png&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;277&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Tumblr是世界上最流行的轻博客服务，其用户量在最近的一次统计中已经达到2090万，超过了全球最大的博客服务WordPress。而我们今天要介绍的是Tumblr通知系统的架构，其通知系统由一个叫Staircar的轻量级HTTP服务器和其下层的大规模Redis集群组成。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;应用分析&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在Tumblr初期，其通知系统是由MySQL＋Memcached的传统架构组成，但是由于通知系统庞大的添加操作，导致MySQL负担非常大，经常搞得InnoDB global transaction max（1024）都超出了。于是他们打算重新构建消息系统。首先他们分析了消息系统的应用特点：
&lt;ul&gt;
    &lt;li&gt;按时间排序&lt;/li&gt;
    &lt;li&gt;唯一性，每一条消息都是唯一的&lt;/li&gt;
    &lt;li&gt;读写比大概是 60%/30%&lt;/li&gt;
    &lt;li&gt;每个用户的消息条数一定&lt;/li&gt;
    &lt;li&gt;数据按用户划分，每个用户只能读自己的消息&lt;/li&gt;
&lt;/ul&gt;
&lt;strong&gt;架构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;基于上面应用特点的考虑，Tumblr选择了Redis的sorted sets作为其数据存储。&lt;/p&gt;

&lt;p&gt;他们的存储方式是：
&lt;ul&gt;
    &lt;li&gt;给每个用户分配一个sorted sets，其中每一项保存一条通知&lt;/li&gt;
    &lt;li&gt;每条通知以时间戳为score在sorted sets中进行排序&lt;/li&gt;
    &lt;li&gt;超出100条通知后进行trim操作&lt;/li&gt;
&lt;/ul&gt;
Tumblr的数据量：2300万个BLOG，每个BLOG 100条消息，每条消息体大概160bytes。&lt;/p&gt;

&lt;p&gt;响应速度：大概每秒提供7,500次请求，每次请求的响应时间小于5ms。&lt;/p&gt;

&lt;p&gt;考虑到容灾性及可能快速增长的数据量，Tumblr打算采用preshard的方式来架构他们的Redis集群，于是他们开发了Staircar（一个提供HTTP服务的Redis集群调度管理组件）。下面是他们的通知系统架构图：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone&#34; title=&#34;架构&#34; src=&#34;http://blog.nosqlfan.com/wp-content/uploads/2011/07/tumblr_lollyoX2RT1qz6daf.png&#34; alt=&#34;&#34; width=&#34;490&#34; height=&#34;247&#34; /&gt;&lt;/p&gt;

&lt;p&gt;实际上在开发Staircar前，他们考查了一些其它的类似功能的产品，但都不能满足他们所有需求（或者说闲杂功能过多）。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Staircar由C语言写成，以libevent为网络驱动层，提供JSON格式的RESTFul接口，其性能超出了Tumblr工程师们的想象，其在最高峰时的响应时间也在5ms以下，其性能测试结果是大概能处理每秒30,000次左右的请求。下面是其性能测试图，从图上可以看到，其绝大部分请求（红色区域）的响应时间在3－4ms之间：&lt;/p&gt;

&lt;p&gt;&lt;img class=&#34;alignnone&#34; title=&#34;性能&#34; src=&#34;http://blog.nosqlfan.com/wp-content/uploads/2011/07/staircarbench.jpeg&#34; alt=&#34;&#34; width=&#34;500&#34; height=&#34;510&#34; /&gt;&lt;/p&gt;

&lt;p&gt;来源：engineering.tumblr.com&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ubuntu 11.04安装gcc 4.6.1</title>
      <link>http://blog.prosight.me/blogs/741</link>
      <pubDate>2011-07-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;首先下载相应的源代码：
&lt;a href=&#34;ftp://ftp.dti.ad.jp/pub/lang/gcc/releases/gcc-4.6.1/&#34;&gt;ftp://ftp.dti.ad.jp/pub/lang/gcc/releases/gcc-4.6.1/&lt;/a&gt;
#下载 gcc-4.6.1.tar.bz2&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;ftp://ftp.dti.ad.jp/pub/lang/gcc/infrastructure/&#34;&gt;ftp://ftp.dti.ad.jp/pub/lang/gcc/infrastructure/&lt;/a&gt;
#下载 gmp-4.3.2.tar.bz2 mpfr-2.4.2.tar.bz2 mpc-0.8.1.tar.gz&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 0:&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$sudo apt-get install build-essential
$sudo apt-get install zlibc
$sudo apt-get install zlib1g-dev
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 1: 安装 gmp-4.3.2&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#cd to src_dir
$./configure &amp;ndash;prefix=/usr/local/gmp-4.3.2
$make
$sudo make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 2: 安装 mpfr-2.4.2&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#cd to src_dir
$./configure &amp;ndash;prefix=/usr/local/mpfr-2.4.2 &amp;ndash;with-gmp=/usr/local/gmp-4.3.2
$make
$sudo make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3: 安装 mpc-0.8.1&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#cd to src_dir
$./configure &amp;ndash;prefix=/usr/local/mpc-0.8.1 &amp;ndash;with-gmp=/usr/local/gmp-4.3.2 &amp;ndash;with-mpfr=/usr/local/mpfr-2.4.2
$make
$sudo make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 4: 安装 gcc-4.6.0&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/mpc-0.8.1/lib:/usr/local/gmp-4.3.2/lib:/usr/local/mpfr-2.4.2/lib
#cd to src_dir
$./configure &amp;ndash;prefix=/usr/local/gcc-4.6.1 &amp;ndash;enable-threads=posix &amp;ndash;disable-checking &amp;ndash;disable-multilib &amp;ndash;enable-languages=c,c++ &amp;ndash;with-gmp=/usr/local/gmp-4.3.2 &amp;ndash;with-mpfr=/usr/local/mpfr-2.4.2 &amp;ndash;with-mpc=/usr/local/mpc-0.8.1
$make
$sudo make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 5: 多版本支持&lt;/strong&gt;
为了让ubuntu支持多个gcc版本，需要做以下设置：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo update-alternatives &amp;ndash;install /usr/bin/gcc gcc /usr/bin/gcc-4.5 40
$ sudo update-alternatives &amp;ndash;install /usr/bin/gcc gcc /usr/local/gcc-4.6.1/bin/gcc 60
#选择你需要的版本
$sudo update-alternatives &amp;ndash;config gcc
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 6:添加新版共享库&lt;/strong&gt;
为了在编译软件时候，可以使用到最新的共享库
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$sudo vim /etc/ld.so.conf.d/x86_64-linux-gnu.conf
&lt;/pre&gt;
添加下面内容
/usr/local/gcc-4.6.1/lib64/
保存后执行，更新共享库
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$sudo ldconfig
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>五月蜀地游</title>
      <link>http://blog.prosight.me/blogs/756</link>
      <pubDate>2011-07-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近太忙，本来五月的照片，最近才整理好。不多说，直接上图吧。&lt;/p&gt;

&lt;p&gt;小寨天坑，五六百米深的一个自然大坑。
&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5235/5819713057_5d018064b3.jpg&#34; title=&#34;小寨天坑&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;重庆中山古镇
&lt;img alt=&#34;&#34; src=&#34;http://farm3.static.flickr.com/2210/5820304444_a91118a6b4.jpg&#34; title=&#34;中山古镇&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm4.static.flickr.com/3510/5819739675_2a09309463.jpg&#34; title=&#34;中山古镇&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;重庆人民大礼堂
&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5187/5820745520_4c07a26815.jpg&#34; title=&#34;重庆人民大礼堂&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;重庆三峡博物馆
&lt;img alt=&#34;&#34; src=&#34;http://farm4.static.flickr.com/3525/5820744406_ba630abf77.jpg&#34; title=&#34;三峡博物馆&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;重庆洪崖洞
&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5315/5820190677_de9cb04acc.jpg&#34; title=&#34;洪崖洞&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;洪崖洞卖的各种辣子
&lt;img alt=&#34;&#34; src=&#34;http://farm4.static.flickr.com/3205/5820193743_e69254c032.jpg&#34; title=&#34;辣子&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;洪崖洞夜景
&lt;img alt=&#34;&#34; src=&#34;http://farm4.static.flickr.com/3608/5820196913_275e7fb646.jpg&#34; title=&#34;洪崖洞&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5262/5820761424_fd96998704.jpg&#34; title=&#34;洪崖洞&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm4.static.flickr.com/3591/5820197783_ffc3a0a285.jpg&#34; title=&#34;洪崖洞&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;重庆嘉陵江过江缆车
&lt;img alt=&#34;&#34; src=&#34;http://farm3.static.flickr.com/2305/5820202073_19e953ce73.jpg&#34; title=&#34;过江缆车&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;渝中半岛
&lt;img alt=&#34;&#34; src=&#34;http://farm3.static.flickr.com/2284/5820781958_a69aa8fce8.jpg&#34; title=&#34;渝中半岛&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5115/5820783342_af6eda3a15.jpg&#34; title=&#34;渝中半岛&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ubuntu 11.04安装OpenCV</title>
      <link>http://blog.prosight.me/blogs/749</link>
      <pubDate>2011-07-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;strong&gt;Step 1:安装必要的依赖包&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo apt-get install build-essential libgtk2.0-dev libjpeg62-dev libtiff4-dev libjasper-dev libopenexr-dev cmake python-dev python-numpy libtbb-dev libeigen2-dev yasm libfaac-dev libopencore-amrnb-dev libopencore-amrwb-dev libtheora-dev libvorbis-dev libxvidcore-dev
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 2:安装ffmpeg&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd ~
wget &lt;a href=&#34;http://ffmpeg.org/releases/ffmpeg-0.7-rc1.tar.gz&#34;&gt;http://ffmpeg.org/releases/ffmpeg-0.7-rc1.tar.gz&lt;/a&gt;
tar -xvzf ffmpeg-0.7-rc1.tar.gz
cd ffmpeg-0.7-rc1
./configure &amp;ndash;enable-gpl &amp;ndash;enable-version3 &amp;ndash;enable-nonfree &amp;ndash;enable-postproc &amp;ndash;enable-libfaac &amp;ndash;enable-libopencore-amrnb &amp;ndash;enable-libopencore-amrwb &amp;ndash;enable-libtheora &amp;ndash;enable-libvorbis &amp;ndash;enable-libxvid &amp;ndash;enable-x11grab &amp;ndash;enable-swscale &amp;ndash;enable-shared
make
sudo make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 3:安装OpenCV 2.3&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd ~
wget &lt;a href=&#34;http://downloads.sourceforge.net/project/opencvlibrary/opencv-unix/2.3/OpenCV-2.3.0.tar.bz2&#34;&gt;http://downloads.sourceforge.net/project/opencvlibrary/opencv-unix/2.3/OpenCV-2.3.0.tar.bz2&lt;/a&gt;
tar -xvf OpenCV-2.3.0.tar.bz2
cd OpenCV-2.3.0/
mkdir release
cd releasecmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D BUILD_NEW_PYTHON_SUPPORT=ON -D WITH_TBB=ON -D WITH_V4L=OFF -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D BUILD_EXAMPLES=ON ..
make
sudo make intall
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 4:添加库的路径&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo vim /etc/ld.so.conf.d/opencv.conf
&lt;/pre&gt;
加入：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/usr/local/lib
&lt;/pre&gt;
更新系统库
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$sudo ldconfig
&lt;/pre&gt;
设置环境变量
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$sudo vim /etc/environment
&lt;/pre&gt;
加入
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
PKG_CONFIG_PATH=$PKG_CONFIG_PATH:/usr/local/lib/pkgconfig
&lt;/pre&gt;
至此，OpenCV的设置都完成了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Step 5:测试&lt;/strong&gt;
进入OpenCV源代码目录中的sample
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd ~/OpenCV-2.3.0/samples/c
chmod +x build_all.sh
./build_all.sh
&lt;/pre&gt;
然后执行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
./facedetect &amp;ndash;cascade=&amp;ldquo;/usr/local/share/opencv/haarcascades/haarcascade_frontalface_alt.xml&amp;rdquo; &amp;ndash;scale=1.5 lena.jpg
&lt;/pre&gt;
你应该可以看到以下图片，说明OpenCV运行正常
&lt;img alt=&#34;&#34; src=&#34;http://www.samontab.com/web/wp-content/uploads/2010/03/Screenshot-1.png&#34; title=&#34;OpenCV&#34; class=&#34;alignnone&#34; width=&#34;518&#34; height=&#34;538&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>register、volatile、restrict 三关键字的用法</title>
      <link>http://blog.prosight.me/blogs/729</link>
      <pubDate>2011-07-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;strong&gt;register&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;使用修饰符register声明的变量属于寄存器存储类型。该类型与自动存储类型相似，具有自动存储时期、代码块作用域和内连接。声明为register仅仅是一个请求，因此该变量仍然可能是普通的自动变量。无论哪种情况，用register修饰的变量都无法获取地址。如果没有被初始化，它的值是未定的。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;volatile&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;volatile告诉编译器该被变量除了可被程序修改外，还可能被其他代理、线程修改。因此，当使用volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，而不使用寄存器中的缓存的值。比如，
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
val1=x;
val2=x;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如果没有声明volatile，系统在给val2赋值的时候可能直接从寄存器读取x，而不是从内存的初始位置读取。那么在两次赋值之间，x完全有可能被被某些编译器未知的因素更改（比如：操作系统、硬件或者其它线程等）。如果声明为volatile，编译器将不使用缓存，而是每次都从内存重新读取x。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;restrict&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;restrict是c99引入的，它只可以用于限定指针，并表明指针是访问一个数据对象的唯一且初始的方式，考虑下面的例子：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
int ar[10];
int * restrict restar=(int *)malloc(10*sizeof(int));
int *par=ar;
&lt;/pre&gt;
这里说明restar是访问由malloc()分配的内存的唯一且初始的方式。par就不是了。那么：

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
for(n=0;n&amp;lt;10;n++)
{
    par[n]+=5;
    restar[n]+=5;
    ar[n]*=2;
    par[n]+=3;
    restar[n]+=3;
}
&lt;/pre&gt;

&lt;p&gt;因为restar是访问分配的内存的唯一且初始的方式，那么编译器可以将上述对restar的操作进行优化：restar[n]+=8;。而par并不是访问数组ar的唯一方式，因此并不能进行下面的优化：par[n]+=8;。因为在par[n]+=3前，ar[n]*=2进行了改变。使用了关键字restric，编译器就可以放心地进行优化了。这个关键字据说来源于古老的FORTRAN。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;两个关键字：volatile和restrict，两者都是为了方便编译器的优化。&lt;/p&gt;

&lt;p&gt;转载自：&lt;a href=&#34;http://blog.csdn.net/hxg130435477/article/details/6636023&#34;&gt;register、volatile、restrict 三关键字的用法 - RaymondAmos的技术专栏 - CSDN博客&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>安装史上最牛的vimrc</title>
      <link>http://blog.prosight.me/blogs/726</link>
      <pubDate>2011-07-19 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;平时大家都会用到vim，发现一个不错的vimrc，大家可以试着用下。&lt;/p&gt;

&lt;p&gt;通过一下命令安装这个vimrc
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ mkdir ~/.vim_runtime
$ svn co svn://orangoo.com/vim ~/.vim_runtime
$ cat ~/.vim_runtime/install.sh
$ sh ~/.vim_runtime/install.sh &lt;system&gt;
  &lt;sytem&gt; can be &lt;code&gt;mac&lt;/code&gt;, &lt;code&gt;linux&lt;/code&gt; or &lt;code&gt;windows&lt;/code&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;安装好后的vim看起来像这个样子
&lt;img alt=&#34;&#34; src=&#34;http://amix.dk/uploads/my_vimrc.jpg&#34; title=&#34;vim&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;403&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ubuntu下自动安装雅黑字体脚本</title>
      <link>http://blog.prosight.me/blogs/722</link>
      <pubDate>2011-07-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;安装ubuntu的时候，总是需要美化中文字体。 微软雅黑是比较好的中文字体美化方案。 下面的这个脚本可以帮助大家自动来美化中文字体。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget -O get-fonts.sh.zip http://files.cnblogs.com/DengYangjun/get-fonts.sh.zip
unzip -o get-fonts.sh.zip 1&gt;/dev/null
chmod a+x get-fonts.sh
./get-fonts.sh
&lt;/pre&gt;

&lt;p&gt;删除下载的字体安装脚本文件：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
rm get-fonts.sh get-fonts.sh.zip 2&amp;gt;/dev/null
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;恢复以前的字体设置：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd /etc/fonts/conf.avail
sudo mv 51-local.conf.old 51-local.conf 2&amp;gt;/dev/null
sudo mv 69-language-selector-zh-cn.conf.old 69-language-selector-zh-cn.conf 2&amp;gt;/dev/null
sudo rm -f -r /usr/share/fonts/truetype/myfonts 2&amp;gt;/dev/null
cd -
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;修正记录：
#1.添加了最新的Windows 7的微软雅黑字体。（附件大小限制，未实现）
2.修正了CRT渲染的配置文件的链接错误。
3.添加字体：Agency FB
4.添加字体设置恢复功能。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ubuntu 11.04下，使用google-perftools的tcmalloc加速MySQL</title>
      <link>http://blog.prosight.me/blogs/717</link>
      <pubDate>2011-07-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;1.在 /usr/local/src 下准备好以下文件
libunwind-0.99.tar.gz （64位操作系统需要）
google-perftools-1.7.tar.gz&lt;/p&gt;

&lt;p&gt;2.安装libunwind（32位操作系统忽略此步骤）
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd /usr/local/src
tar zxvf libunwind-0.99.tar.gz
cd libunwind-0.99
CFLAGS=-fPIC ./configure &amp;ndash;enable-shared
make CFLAGS=-fPIC
make CFLAGS=-fPIC install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;3.安装google-perftools （最小化安装）
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd /usr/local/src
tar zvxf google-perftools-1.7.tar.gz
cd google-perftools-1.7
mkdir /tmp/tc
./configure &amp;ndash;prefix=/tmp/tc &amp;ndash;disable-cpu-profiler &amp;ndash;disable-heap-profiler &amp;ndash;disable-heap-checker &amp;ndash;disable-debugalloc &amp;ndash;enable-minimal
 make &amp;amp;&amp;amp; make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;4.复制tcmalloc动态库到系统库目录，并建立软连接
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ls -alt /tmp/tc/lib/*
cp /tmp/tc/lib/libtcmalloc_minimal.so.0.1.0 /usr/local/lib
ln -s /usr/local/lib/libtcmalloc_minimal.so.0.1.0 /usr/local/lib/libtcmalloc.so
ln -s /usr/local/lib/libtcmalloc_minimal.so.0.1.0 /usr/local/lib/libtcmalloc.so.0
ln -s /usr/local/lib/libtcmalloc_minimal.so.0.1.0 /usr/local/lib/libtcmalloc.so.0.1.0
ln -s /usr/local/lib/libtcmalloc_minimal.so.0.1.0 /usr/local/lib/libtcmalloc_minimal.so.0
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;5.删除临时目录
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
rm -rf /tmp/tc
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;6.设置Mysql运行时加载tcmalloc (根据mysql安装位置而定)
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /usr/local/mysql/bin/mysqld_safe
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在# executing mysqld_safe的下一行，加入以下内容
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
export LD_PRELOAD=&amp;ldquo;/usr/local/lib/libtcmalloc.so&amp;rdquo;
&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;重启MySQL
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/etc/init.d/mysql start
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;8.使用lsof命令查看tcmalloc是否起效
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo lsof -n |grep tcmalloc
&lt;/pre&gt;
应该看到下面的内容
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
mysqld    12484      mysql  mem       REG        8,7       860657    5382577 /usr/local/lib/libtcmalloc_minimal.so.0.1.0
&lt;/pre&gt;
说明MySQL已经使用上了tcmalloc进行加速了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ubuntu 11.04国内镜像源</title>
      <link>http://blog.prosight.me/blogs/714</link>
      <pubDate>2011-07-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Ubuntu 11.04网易源（速度很快，推荐）&lt;/p&gt;

&lt;p&gt;deb &lt;a href=&#34;http://mirrors.163.com/ubuntu/&#34;&gt;http://mirrors.163.com/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb-src &lt;a href=&#34;http://mirrors.163.com/ubuntu/&#34;&gt;http://mirrors.163.com/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb &lt;a href=&#34;http://mirrors.163.com/ubuntu/&#34;&gt;http://mirrors.163.com/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirrors.163.com/ubuntu/&#34;&gt;http://mirrors.163.com/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb &lt;a href=&#34;http://mirrors.163.com/ubuntu/&#34;&gt;http://mirrors.163.com/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted
deb &lt;a href=&#34;http://mirrors.163.com/ubuntu/&#34;&gt;http://mirrors.163.com/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirrors.163.com/ubuntu/&#34;&gt;http://mirrors.163.com/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb &lt;a href=&#34;http://mirrors.163.com/ubuntu/&#34;&gt;http://mirrors.163.com/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirrors.163.com/ubuntu/&#34;&gt;http://mirrors.163.com/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirrors.163.com/ubuntu/&#34;&gt;http://mirrors.163.com/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted&lt;/p&gt;

&lt;p&gt;lupaworld 源，提供 ArchLinux，Everest，FreeBSD，fedora，LFS，Magiclinux，Mandriva，OpenOffice，openSUSE，Puppy，Red Hat，Slitaz，Turbolinux，Ubuntu，中标普华&lt;/p&gt;

&lt;p&gt;deb &lt;a href=&#34;http://mirror.lupaworld.com/ubuntu/&#34;&gt;http://mirror.lupaworld.com/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb-src &lt;a href=&#34;http://mirror.lupaworld.com/ubuntu/&#34;&gt;http://mirror.lupaworld.com/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb &lt;a href=&#34;http://mirror.lupaworld.com/ubuntu/&#34;&gt;http://mirror.lupaworld.com/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.lupaworld.com/ubuntu/&#34;&gt;http://mirror.lupaworld.com/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb &lt;a href=&#34;http://mirror.lupaworld.com/ubuntu/&#34;&gt;http://mirror.lupaworld.com/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted
deb &lt;a href=&#34;http://mirror.lupaworld.com/ubuntu/&#34;&gt;http://mirror.lupaworld.com/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.lupaworld.com/ubuntu/&#34;&gt;http://mirror.lupaworld.com/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb &lt;a href=&#34;http://mirror.lupaworld.com/ubuntu/&#34;&gt;http://mirror.lupaworld.com/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.lupaworld.com/ubuntu/&#34;&gt;http://mirror.lupaworld.com/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.lupaworld.com/ubuntu/&#34;&gt;http://mirror.lupaworld.com/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted&lt;/p&gt;

&lt;p&gt;ubuntu 11.04 搜狐源&lt;/p&gt;

&lt;p&gt;deb &lt;a href=&#34;http://mirrors.shlug.org/ubuntu/&#34;&gt;http://mirrors.shlug.org/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb-src &lt;a href=&#34;http://mirrors.shlug.org/ubuntu/&#34;&gt;http://mirrors.shlug.org/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb &lt;a href=&#34;http://mirrors.shlug.org/ubuntu/&#34;&gt;http://mirrors.shlug.org/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirrors.shlug.org/ubuntu/&#34;&gt;http://mirrors.shlug.org/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb &lt;a href=&#34;http://mirrors.shlug.org/ubuntu/&#34;&gt;http://mirrors.shlug.org/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted
deb &lt;a href=&#34;http://mirrors.shlug.org/ubuntu/&#34;&gt;http://mirrors.shlug.org/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirrors.shlug.org/ubuntu/&#34;&gt;http://mirrors.shlug.org/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb &lt;a href=&#34;http://mirrors.shlug.org/ubuntu/&#34;&gt;http://mirrors.shlug.org/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirrors.shlug.org/ubuntu/&#34;&gt;http://mirrors.shlug.org/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirrors.shlug.org/ubuntu/&#34;&gt;http://mirrors.shlug.org/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted&lt;/p&gt;

&lt;p&gt;deb &lt;a href=&#34;http://cn.archive.ubuntu.com/ubuntu/&#34;&gt;http://cn.archive.ubuntu.com/ubuntu/&lt;/a&gt; natty multiverse
deb-src &lt;a href=&#34;http://cn.archive.ubuntu.com/ubuntu/&#34;&gt;http://cn.archive.ubuntu.com/ubuntu/&lt;/a&gt; natty multiverse
deb &lt;a href=&#34;http://cn.archive.ubuntu.com/ubuntu/&#34;&gt;http://cn.archive.ubuntu.com/ubuntu/&lt;/a&gt; natty-updates multiverse
deb-src &lt;a href=&#34;http://cn.archive.ubuntu.com/ubuntu/&#34;&gt;http://cn.archive.ubuntu.com/ubuntu/&lt;/a&gt; natty-updates multiverse
deb &lt;a href=&#34;http://security.ubuntu.com/ubuntu&#34;&gt;http://security.ubuntu.com/ubuntu&lt;/a&gt; natty-security main restricted
deb-src &lt;a href=&#34;http://security.ubuntu.com/ubuntu&#34;&gt;http://security.ubuntu.com/ubuntu&lt;/a&gt; natty-security main restricted
deb &lt;a href=&#34;http://security.ubuntu.com/ubuntu&#34;&gt;http://security.ubuntu.com/ubuntu&lt;/a&gt; natty-security universe
deb-src &lt;a href=&#34;http://security.ubuntu.com/ubuntu&#34;&gt;http://security.ubuntu.com/ubuntu&lt;/a&gt; natty-security universe
deb &lt;a href=&#34;http://security.ubuntu.com/ubuntu&#34;&gt;http://security.ubuntu.com/ubuntu&lt;/a&gt; natty-security multiverse
deb-src &lt;a href=&#34;http://security.ubuntu.com/ubuntu&#34;&gt;http://security.ubuntu.com/ubuntu&lt;/a&gt; natty-security multiverse
deb &lt;a href=&#34;http://archive.canonical.com/ubuntu&#34;&gt;http://archive.canonical.com/ubuntu&lt;/a&gt; natty partner
deb-src &lt;a href=&#34;http://archive.canonical.com/ubuntu&#34;&gt;http://archive.canonical.com/ubuntu&lt;/a&gt; natty partner&lt;/p&gt;

&lt;p&gt;ubuntu 11.04台湾源&lt;/p&gt;

&lt;p&gt;deb &lt;a href=&#34;http://tw.archive.ubuntu.com/ubuntu/&#34;&gt;http://tw.archive.ubuntu.com/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb-src &lt;a href=&#34;http://tw.archive.ubuntu.com/ubuntu/&#34;&gt;http://tw.archive.ubuntu.com/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb &lt;a href=&#34;http://tw.archive.ubuntu.com/ubuntu/&#34;&gt;http://tw.archive.ubuntu.com/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb-src &lt;a href=&#34;http://tw.archive.ubuntu.com/ubuntu/&#34;&gt;http://tw.archive.ubuntu.com/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb &lt;a href=&#34;http://tw.archive.ubuntu.com/ubuntu/&#34;&gt;http://tw.archive.ubuntu.com/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted
deb-src &lt;a href=&#34;http://tw.archive.ubuntu.com/ubuntu/&#34;&gt;http://tw.archive.ubuntu.com/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted&lt;/p&gt;

&lt;p&gt;SRT Sources&lt;/p&gt;

&lt;p&gt;deb &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty main restricted universe multiverse
deb &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-security main restricted universe multiverse
deb &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-updates main restricted universe multiverse
deb &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-proposed main restricted universe multiverse
deb &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-backports main restricted universe multiverse
deb-src &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty main restricted universe multiverse
deb-src &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-security main restricted universe multiverse
deb-src &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-updates main restricted universe multiverse
deb-src &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-proposed main restricted universe multiverse
deb-src &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-backports main restricted universe multiverse&lt;/p&gt;

&lt;p&gt;ubuntu 11.04 上海源 提供 Kernel，Hiweed，ubuntu&lt;/p&gt;

&lt;p&gt;deb &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb-src &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted
deb &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted&lt;/p&gt;

&lt;p&gt;ubuntu 11.04 骨头源 骨头源是bones7456架设的一个Ubuntu源 ，提供ubuntu,deepin&lt;/p&gt;

&lt;p&gt;deb &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb-src &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb-src &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted
deb &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb-src &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://ubuntu.srt.cn/ubuntu/&#34;&gt;http://ubuntu.srt.cn/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted&lt;/p&gt;

&lt;p&gt;rootguide源，ubuntu官方上海源，提供 Kernel，Hiweed，ubuntu&lt;/p&gt;

&lt;p&gt;deb &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb-src &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty main universe restricted multiverse
deb &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-security universe main multiverse restricted
deb &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted
deb &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-proposed universe main multiverse restricted
deb &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-backports universe main multiverse restricted
deb-src &lt;a href=&#34;http://mirror.rootguide.org/ubuntu/&#34;&gt;http://mirror.rootguide.org/ubuntu/&lt;/a&gt; natty-updates universe main multiverse restricted&lt;/p&gt;

&lt;p&gt;PS:  建议保留官方的那个security 的源 其他的官方源就可以删掉&lt;/p&gt;
</description>
    </item>
    <item>
      <title>SpringMVC+Freemarker UTF-8编码 完全解决方案</title>
      <link>http://blog.prosight.me/blogs/711</link>
      <pubDate>2011-06-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近用SpringMVC+Freemarker+AJAX作了个例子.遇到了一些关于中文编码的问题.通过查资料把问题解决了.
在这里总结一下.&lt;/p&gt;

&lt;p&gt;先解决Freemarker的中文问题.
在Spring的配置文件里要添加一些配置项.
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;bean id=&#34;freemarderConfig&#34;
          class=&#34;org.springframework.web.servlet.view.freemarker.FreeMarkerConfigurer&#34;&gt;
        &lt;property name=&#34;templateLoaderPath&#34; value=&#34;/ftl/&#34;/&gt;
        &lt;property name=&#34;freemarkerVariables&#34;&gt;
            &lt;map&gt;
                &lt;entry key=&#34;xml_escape&#34; value-ref=&#34;fmXmlEscape&#34;/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name=&#34;freemarkerSettings&#34;&gt;
            &lt;props&gt;
                &lt;prop key=&#34;defaultEncoding&#34;&gt;UTF-8&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;
    &lt;/bean&gt;
    &lt;bean id=&#34;fmXmlEscape&#34; class=&#34;freemarker.template.utility.XmlEscape&#34;/&gt;
    &lt;bean id=&#34;viewResolver&#34;
          class=&#34;org.springframework.web.servlet.view.freemarker.FreeMarkerViewResolver&#34;&gt;
        &lt;property name=&#34;cache&#34; value=&#34;true&#34;/&gt;
        &lt;property name=&#34;viewClass&#34;
                  value=&#34;org.springframework.web.servlet.view.freemarker.FreeMarkerView&#34;/&gt;
        &lt;property name=&#34;suffix&#34; value=&#34;.ftl&#34;/&gt;
        &lt;property name=&#34;exposeRequestAttributes&#34; value=&#34;true&#34;/&gt;
        &lt;property name=&#34;exposeSessionAttributes&#34; value=&#34;true&#34;/&gt;
        &lt;property name=&#34;exposeSpringMacroHelpers&#34; value=&#34;true&#34;/&gt;
        &lt;property name=&#34;contentType&#34; value=&#34;text/html;charset=UTF-8&#34;/&gt;
    &lt;/bean&gt;
&lt;/pre&gt;
在Spring的配置文件中像如上配置之后Freemarker的中文问题基本解决.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ubuntu中Compizconfig-settings-manager设置失败后的恢复办法</title>
      <link>http://blog.prosight.me/blogs/707</link>
      <pubDate>2011-06-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用Compizconfig-settings-manager设置后不知道点了什么设置，导致进入桌面后窗口标题栏，侧栏什么的都没有了
解决办法：&lt;/p&gt;

&lt;p&gt;1.命令行：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd
rm -rf .gconf/apps/compiz*
rm -rf .cache/compizconfig-1
rm -rf .config/compiz-1&lt;/p&gt;

&lt;p&gt;rm -rf .compiz
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;2.把.gconf下apps下的compizconfig-1删掉就ok了，相当与还原compiz的设置为默认，然后重新设置，可以到classic桌面下完成），然后重启，UNITY恢复正常。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ubuntu下无法正常启动eclipse</title>
      <link>http://blog.prosight.me/blogs/705</link>
      <pubDate>2011-06-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天安装Eclipse，从官网上下载了JDK，配置好JAVA_HOME后发现了一个怪现象，可以在终端顺利启动Eclipse，但是鼠标双击，或者用起动器启动就会出现如下的内容：&lt;/p&gt;

&lt;p&gt;A Java RunTime Environment (JRE) or Java Development Kit (JDK) must be available in order to run Eclipse. No java virtual machine was found after searching the following locations:…&lt;/p&gt;

&lt;p&gt;解决办法是在终端进入你的eclipse目录，然后输入：&lt;/p&gt;

&lt;p&gt;mkdir jre
cd jre
ln -s 你的JDK目录/bin bin&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Spring MVC 3.0.5+Spring 3.0.5+MyBatis3.0.4全注解实例详解（一）</title>
      <link>http://blog.prosight.me/blogs/700</link>
      <pubDate>2011-05-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Spring更新到3.0之后，其MVC框架加入了一个非常不错的东西——那就是REST。它的开放式特性，与Spring的无缝集成，以及Spring框架的优秀表现，使得现在很多公司将其作为新的系统开发框架。大象根据实际的项目经验，以之前SSH2例子为基础，对其进行一次大改造，详细的为大家讲解如何实现SSM3全注解式的开发。
    这次大象将采取两种构建方式，一是很多人喜欢用的MyEclipse，另一个，则是用Eclipse+Maven。这一篇，将主要讲解开发环境设置与Maven构建方式。
    ## 1、开发环境
    JDK1.6.0_18
    Eclipse3.2.1 MyEclipse5.1.0
    Eclipse-JEE-HELIOS-SR2 Maven3.0.1 m2eclipse0.12.1.20110112-1712
    Tomcat6.0.10 maven-jetty-plugin6.1.26
    MySQL5.0.27 Navicat Lite for MySQL 8.1.20
    每个人的开发环境可能会有差异，但有一点我需要说明的是，JDK的版本不得低于1.5，因为用到了很多1.5版才支持的新特性。Tomcat、Jetty、Maven和MySQL请不要低于我所用的版本，因为我没在其它的版本上进行测试。Navicat则是MySQL数据库的图形化操作工具。接下来我将介绍如何在Eclipse3.6中，使用m2eclipse插件构建web应用及测试开发环境。
    ## 2、设置Maven
    Maven的安装很简单，只需要解压即可，请设置PATH变量，这样可以使用命令行进行操作，然后就要在%MAVEN_HOME%conf目录下，对settings.xml作下修改
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/maven_config.jpg&#34; title=&#34;settings.xml&#34; class=&#34;alignnone&#34; width=&#34;507&#34; height=&#34;180&#34; /&gt;&lt;/p&gt;

&lt;p&gt;这就是设置本地仓库，目录可以根据自己的实际情况更改，不过请使用&amp;rdquo;/&amp;ldquo;正斜杠，因为我在实际使用中，发现反斜杠有时候获取不到资源。对于个人使用，设置好这个就OK了，至于Nexus配置不在本文讨论范围内，大家如有兴趣可以去看看juven xu的博客，他是目前公认的Maven专家。
    ## 3、安装m2eclipse
    选择Help-&amp;gt;Install New Software&amp;hellip;在弹出的窗口中，点击Add&amp;hellip;又会弹出一个小窗口，输入m2eclipse的安装地址，如下图所示：
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/install_m2eclipse_add.jpg&#34; title=&#34;m2eclipse&#34; class=&#34;alignnone&#34; width=&#34;707&#34; height=&#34;514&#34; /&gt;
输入完成后，点击OK，这时Eclipse就开始查找这个插件了，请耐心等一会。
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/install_m2eclipse_choose.jpg&#34; title=&#34;install m2eclispe&#34; class=&#34;alignnone&#34; width=&#34;710&#34; height=&#34;514&#34; /&gt;
插件找到后，请勾选要安装的内容，接下来就是一般的安装流程了，此处省略500字。安装完成请重新启动Eclipse，然后再对这个插件进行一番设置。
    ## 4、设置m2eclipse
    进入Perferences，选择Maven，去掉Download repository index updates on startup前的勾，默认情况是会在每次启动Eclipse的时候自动去Maven中央仓库下载索引，这无疑是非常不好的，要知道Maven中央仓库所包含的jar资源非常庞大，而且每天都会有很多新的项目上传，弄不好Eclipse还没开始用，就被这些东西搞挂掉了。
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/m2eclipse_index.jpg&#34; title=&#34;m2eclipse&#34; class=&#34;alignnone&#34; width=&#34;608&#34; height=&#34;409&#34; /&gt;&lt;/p&gt;

&lt;p&gt;接下来选择Installations将这个插件自带的Maven换成之前安装的Maven，这样就保证了版本的一致性。
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/m2eclipse_install.jpg&#34; title=&#34;m2eclipse&#34; class=&#34;alignnone&#34; width=&#34;738&#34; height=&#34;390&#34; /&gt;
设置好这个之后，再点击User Settings，用本机maven的settings.xml替换默认的配置文件，因为默认的设置是会将本地仓库放到系统盘符Documents and Settings用户目录.m2repository这个目录下面。
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/m2eclipse_setting.jpg&#34; title=&#34;m2eclipse&#34; class=&#34;alignnone&#34; width=&#34;609&#34; height=&#34;410&#34; /&gt;
大家可以看到，用maven中的配置文件替换后，下面的Local Repository自动变更为settings.xml中的设置。
    ## 5、创建maven工程
    做完这些，我们就可以开始创建Maven工程了。选择New-&amp;gt;other&amp;hellip;-&amp;gt;Maven-&amp;gt;Maven Project，然后选择下一步
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/new_maven_project.jpg&#34; title=&#34;maven&#34; class=&#34;alignnone&#34; width=&#34;527&#34; height=&#34;448&#34; /&gt;
 请设置工作空间路径，大象的默认工作空间放在eclipse的根目录下面，这里的Location显示的应该为空，为了进行说明，特将路径显示出来。确定没问题后，Next&amp;gt;
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/new_maven_workspace.jpg&#34; title=&#34;maven&#34; class=&#34;alignnone&#34; width=&#34;530&#34; height=&#34;390&#34; /&gt;
这个列表显示的就是maven支持的所有项目创建类型，我们是开发web应用，所以请选择maven-archetype-webapp
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/new_maven_webapp.jpg&#34; title=&#34;maven&#34; class=&#34;alignnone&#34; width=&#34;643&#34; height=&#34;459&#34; /&gt;
最后一步输入我们要创建的项目，在Maven世界中，使用坐标来唯一标识一个构件，可以理解为项目，资源等等。Group Id表示当前项目所属的实际项目，Artifact Id定义实际项目中的一个Maven项目，根据名字就可以看出来，Group Id是一个大范围，而Artifact Id是一个小范围。比如大家都很熟悉的spring，就分成了spring-core.jar、spring-beans.jar、spring-context.jar等等。在maven里面，它的Group Id就是org.springframework，而Artifact Id则为spring-core、spring-beans、spring-context。怎么样？理解了没有？
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/new_maven_artifact.jpg&#34; title=&#34;maven&#34; class=&#34;alignnone&#34; width=&#34;597&#34; height=&#34;461&#34; /&gt;
 到此，项目生成了，请展开src/main，在main目录下新建一个java文件夹，打开ssm3的项目属性，选择Java Build Path-&amp;gt;Source-&amp;gt;Add Folder&amp;hellip;-&amp;gt;勾选java，这样做的目的，就是将src/main/java这个路径作为源文件的文件夹，这和以往用MyEclipse做开发的目录结构是不同的。而maven的规则也是这样定义的，假如你不进行这个设置，就算你在main下面创建了java目录，再添加包或类时，就会有问题，大家试试，看会出现什么错误。
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/project_path.jpg&#34; title=&#34;maven&#34; class=&#34;alignnone&#34; width=&#34;698&#34; height=&#34;541&#34; /&gt;&lt;/p&gt;

&lt;h2&gt;6、运行ssm3&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;接下来，在pom.xml里面加入maven-jetty-plugin插件，默认生成的配置都可以去掉，整个pom就只有下图所示的配置。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/maven_jetty_plugin.jpg&#34; title=&#34;maven&#34; class=&#34;alignnone&#34; width=&#34;477&#34; height=&#34;306&#34; /&gt;
打开Run Configurations，这有多种方式打开，可以从菜单Run里面选，也可以从工具栏选择，还可以在项目点击右键选择。
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/maven_run_run.JPG&#34; title=&#34;maven&#34; class=&#34;alignnone&#34; width=&#34;335&#34; height=&#34;193&#34; /&gt;
在弹出的窗口，Maven Build里面设置运行参数，点击Browse Workspace&amp;hellip;会弹出下图那个小窗口，设定Base directory，加入jetty:run，点击Run，启动jetty
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/maven_run_conf.jpg&#34; title=&#34;maven&#34; class=&#34;alignnone&#34; width=&#34;692&#34; height=&#34;579&#34; /&gt;
 在浏览器中输入http://localhost:8080/ssm3会显示Hello World!，调用的是ssm3/main/webapp/index.jsp，大象加了点内容，结果就是这样的
&lt;img alt=&#34;&#34; src=&#34;http://www.blogjava.net/images/blogjava_net/bolo/spring/ie_result.jpg&#34; title=&#34;maven&#34; class=&#34;alignnone&#34; width=&#34;259&#34; height=&#34;71&#34; /&gt;
到这里，关于在Eclipse里搭建maven环境，配置，创建，运行，测试就全部讲完了，大家动手做做，熟悉一下这种开发方式，接下来就会在这个骨架上开发SSM3示例。恩，我们下次继续。
    援引自：http://bolo.blogjava.net/&lt;/p&gt;
</description>
    </item>
    <item>
      <title>清明西陵峡踏青</title>
      <link>http://blog.prosight.me/blogs/677</link>
      <pubDate>2011-04-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;清明小长假，闲来无事去荆州和宜昌兜了一圈。&lt;/p&gt;
### D1:武昌-荆州-宜昌
&lt;p&gt;来荆州还是因为关羽曾驻守于此，也算追星吧。荆州小城不大，也有一个老城墙。 但是比起西安来说还是差了很多。顺便去了一下荆州博物馆。&lt;/p&gt;
&lt;p&gt;中午在古城内吃了个饭，下午到达宜昌，高速路两边都是漂亮的油菜花。入住酒店后在楼下的旅行社看了下宜昌的旅游景点，发现三峡人家还是可以的。于是决定第二天去三峡人家。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;荆州博物馆&#34; src=&#34;http://farm6.static.flickr.com/5070/5605468027_7bc0c6e318.jpg&#34; title=&#34;荆州博物馆&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;荆州博物馆&#34; src=&#34;http://farm5.static.flickr.com/4111/5606051082_6ee273b25d.jpg&#34; title=&#34;荆州博物馆&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;镇馆之宝&#34; src=&#34;http://farm6.static.flickr.com/5026/5606051584_bccf3f845b.jpg&#34; title=&#34;镇馆之宝&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;荆州古城&#34; src=&#34;http://farm6.static.flickr.com/5185/5605469197_be798bb70c.jpg&#34; title=&#34;荆州古城&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;晚上看了江边的夜景&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5029/5605471291_e929c4d89e.jpg&#34; title=&#34;宜昌&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5264/5606054238_43135e6a56.jpg&#34; title=&#34;宜昌夜景&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
### D2:宜昌-西陵峡三峡人家
&lt;p&gt;今天是难得的好天气，第一天和最后一天都有雨。在酒店用过早餐后，就早早上路了，沿途风景很好，几乎都是盘山路，还有一段是沿着长江走的。特别值得一提的是，在一些风景好的地方，有专门为游客建的观景台，而且是免费的。觉得宜昌的旅游做得还挺好的。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5222/5606054866_f52d4d8736.jpg&#34; title=&#34;路边的风景&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;西陵峡&#34; src=&#34;http://farm6.static.flickr.com/5147/5606055040_ed4f8f071e.jpg&#34; title=&#34;西陵峡&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5222/5606056548_6e1ea87a5e.jpg&#34; title=&#34;西陵峡&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;blockquote&gt;&lt;p&gt;三峡人家风景区位于长江三峡中最为奇幻壮丽的西陵峡境内，三峡大坝和葛洲坝之间，跨越秀丽的灯影峡两岸，面积14平方公里。&lt;/p&gt;
&lt;p&gt;三峡人家石牌之美，美在“湾急、石奇、谷幽、洞绝、泉甘”，它包括龙进溪、天下第四泉、野坡岭、灯影洞、抗战纪念馆、石牌古镇、杨家溪漂流等景区，其旅游内涵可以用“一二三四”来概括，即：一个馆（石牌抗战纪念馆），两个特别项目（三峡人家风情项目和杨家溪军事漂流项目），三个第一（三峡第一湾——明月湾、中华第一神牌——石令牌、长江第一石——灯影石），天下第四泉——蛤蟆泉。其中三峡人家风情项目又分为水上人家、溪边人家、山上人家、今日人家。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt=&#34;三峡人家&#34; src=&#34;http://farm6.static.flickr.com/5148/5605478295_f8bedf2e45.jpg&#34; title=&#34;三峡人家&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;三峡人家&#34; src=&#34;http://farm6.static.flickr.com/5106/5606058430_cfb4c2f251.jpg&#34; title=&#34;三峡人家&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;三峡人家&#34; src=&#34;http://farm6.static.flickr.com/5222/5606068106_77b4738f17.jpg&#34; title=&#34;三峡人家&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;三峡人家&#34; src=&#34;http://farm5.static.flickr.com/4100/5605487253_5857b79e2e.jpg&#34; title=&#34;三峡人家&#34; width=&#34;333&#34; height=&#34;500&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;三峡人家&#34; src=&#34;http://farm6.static.flickr.com/5262/5606072574_6bf4086233.jpg&#34; title=&#34;三峡人家&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;西陵峡&#34; src=&#34;http://farm2.static.flickr.com/1432/5606073530_5353421303.jpg&#34; title=&#34;西陵峡&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
### D3:宜昌市内游 - 邮政巷 - 武昌
&lt;p&gt;坐上门口的7路公共汽车，在市政府下车。今天一个最重要的目的就是寻访百年古巷“邮政巷”。&lt;/p&gt;
&lt;p&gt;之前在网上看过照片，但是问了一下，很多宜昌人不知道。网上只说在市政府旁边。&lt;/p&gt;
&lt;p&gt;到了市政府，很快就找到了“邮政巷”。旁边还有一个很有特色的茶馆。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm6.static.flickr.com/5221/5605494489_fa91e1bebd.jpg&#34; title=&#34;邮政巷&#34; class=&#34;alignnone&#34; width=&#34;333&#34; height=&#34;500&#34; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm5.static.flickr.com/4103/5606075246_83d2d8a853.jpg&#34; title=&#34;邮政巷&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;
&lt;p&gt;市政府对面就是滨江公园，又顺便看了看。今天阴天，江面上有点迷雾。早上锻炼的人可不少。&lt;/p&gt;
&lt;p&gt;再往前走，路过了一个天主大教堂；再往前，又路过了一个基督大教堂。&lt;/p&gt;
&lt;p&gt;然后打车回酒店，在酒店餐厅吃了午饭。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>整合cocos2d API文档到XCode中</title>
      <link>http://blog.prosight.me/blogs/672</link>
      <pubDate>2010-12-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;cocos2d是经常使用的iOS游戏引擎，在编写代码的时候，经常需要参考它的API文档，本文主要介绍如何将cocos2d的文档整合到XCode中。&lt;/p&gt;

&lt;h2&gt;安装doxygen&lt;/h2&gt;

&lt;p&gt;从这里下载 &lt;a href=&#34;http://www.stack.nl/~dimitri/doxygen/download.html#latestsrc&#34; target=&#34;_blank&#34;&gt;http://www.stack.nl/~dimitri/doxygen/download.html#latestsrc&lt;/a&gt; DMG安装包。
然后点击安装即可。&lt;/p&gt;

&lt;h2&gt;安装Graphviz&lt;/h2&gt;

&lt;p&gt;从这里下载&lt;a href=&#34;http://www.ryandesign.com/graphviz/&#34; target=&#34;_blank&#34;&gt;http://www.ryandesign.com/graphviz/&lt;/a&gt;
然后点击安装。安装文件会安装到/usr/local/graphviz-x.y/bin目录中。&lt;/p&gt;

&lt;h2&gt;设置doxygen&lt;/h2&gt;

&lt;p&gt;修改doxygen.config文件，将HAVE_DOT设置成YES，将DOT_PATH设置成/usr/local/graphviz-x.y/bin&lt;/p&gt;

&lt;h2&gt;选择cocos2d-documentation target&lt;/h2&gt;

&lt;p&gt;&lt;ul&gt;
    &lt;li&gt;打开 cocos2d-iphone的xcode项目工程&lt;/li&gt;
    &lt;li&gt;选择 “cocos2d-documentation” target&lt;/li&gt;
    &lt;li&gt;XCode -&amp;gt; Project -&amp;gt; Set Active Target -&amp;gt; cocos2d-documentation&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt=&#34;&#34; src=&#34;http://www.cocos2d-iphone.org/blog/wp-content/uploads/2009/07/doc-target.png&#34; title=&#34;选择target&#34; class=&#34;alignnone&#34; width=&#34;358&#34; height=&#34;227&#34; /&gt;&lt;/p&gt;

&lt;h2&gt;生成项目&lt;/h2&gt;

&lt;p&gt;&lt;ul&gt;
    &lt;li&gt;像生成其他项目一样生成此项目&lt;/li&gt;
    &lt;li&gt;XCode -&amp;gt; Build -&amp;gt; Build&lt;/li&gt;
&lt;/ul&gt;
&lt;img alt=&#34;&#34; src=&#34;http://www.cocos2d-iphone.org/blog/wp-content/uploads/2009/07/doc-build.png&#34; title=&#34;生成项目&#34; class=&#34;alignnone&#34; width=&#34;317&#34; height=&#34;99&#34; /&gt;&lt;/p&gt;

&lt;p&gt;之后就可以在文档中查看cocos2d文档了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用Objective-C建立UUID</title>
      <link>http://blog.prosight.me/blogs/670</link>
      <pubDate>2010-11-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;UUID是128位的值，它可以保证唯一性。通常，它是由机器本身网卡的MAC地址和当前系统时间来生成的。&lt;/p&gt;

&lt;p&gt;UUID是由中划线连接而成的字符串。例如：13222F23-C76A-7781-0C12-0293E3B34398.&lt;/p&gt;

&lt;p&gt;下面这个方法可以生成UUID并以字符串的方式进行返回。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (NSString *)createUUID
{
  // Create universally unique identifier (object)
  CFUUIDRef uuidObject = CFUUIDCreate(kCFAllocatorDefault);
 
  // Get the string representation of CFUUID object.
  NSString *uuidStr = (NSString *)CFUUIDCreateString(kCFAllocatorDefault, uuidObject);
 
  // If needed, here is how to get a representation in bytes, returned as a structure
  // typedef struct {
  //   UInt8 byte0;
  //   UInt8 byte1;
  //   ...
  //   UInt8 byte15;
  // } CFUUIDBytes;
  CFUUIDBytes bytes = CFUUIDGetUUIDBytes(uuidObject);
 
  CFRelease(uuidObject);
 
  return uuidStr;
}
&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>给iPhone添加splash页面又一法</title>
      <link>http://blog.prosight.me/blogs/667</link>
      <pubDate>2010-10-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;之前有发过一篇文章，介绍了&lt;a href=&#34;http://blog.prosight.me/index.php/2009/06/118&#34;&gt;如何添加splash页面&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;现在发现有一个更简单的方法。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;将你需要的splash界面的图片，存成Default.png&lt;/li&gt;
&lt;li&gt;在XXXAppDelegate.m程序中，插入如下代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/li&gt;
&lt;li&gt;(BOOL)application:(UIApplication *)application
didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
//&amp;ndash;insert a delay of 5 seconds before the splash screen disappears&amp;ndash;
[NSThread sleepForTimeInterval:5.0];
// Override point for customization after application launch.
// Add the view controller’s view to the window and display.
[window addSubview:viewController.view];
[window makeKeyAndVisible];
return YES;
}&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样splash页面就停留5秒后，消失了。
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>自驾西游季结束了</title>
      <link>http://blog.prosight.me/blogs/662</link>
      <pubDate>2010-10-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;西游季结束了，从公元2010年10月1日开始到2010年10月14日结束，历时14天，跨越上海、江苏、安徽、河南、陕西、内蒙古、甘肃、青海共计7省1市，行程逾9000公里，翻越了贺兰山和海拔逾4000米的祁连雪山，领略了世界唯一现存的最大的胡杨林的风采，穿过了腾格里沙漠，领略了高原湖泊，最美的湖泊──青海湖，欣赏了四大石窟中的莫高窟和麦积山石窟。&lt;/p&gt;

&lt;p&gt;D1：上海 - 河南南阳
D2：南阳 - 宁夏银川
D3：银川（西夏王陵）
D4：宁夏银川 - 内蒙古额济纳旗
D5：额济纳旗（胡杨林，红城、黑城、怪树林）
D6：额济纳旗 - 甘肃嘉峪关（嘉峪关）
D7：嘉峪关 - 甘肃敦煌（莫高窟、月牙泉、鸣沙山）
D8：敦煌 - 甘肃张掖（丹霞）
D9：张掖 - 青海西宁
D10：西宁（塔尔寺、青海湖）
D11：西宁 - 甘肃天水（麦积山石窟）
D12：天水 - 陕西西安
D13：西安 - 安徽合肥
D14：合肥 - 上海&lt;/p&gt;

&lt;p&gt;&lt;iframe width=&#34;500&#34; height=&#34;350&#34; frameborder=&#34;0&#34; scrolling=&#34;no&#34; marginheight=&#34;0&#34; marginwidth=&#34;0&#34; src=&#34;http://maps.google.com/maps/ms?ie=UTF8&amp;amp;hl=zh-CN&amp;amp;msa=0&amp;amp;msid=111375824033091419173.000492bc1a79cbd56a83d&amp;amp;ll=36.590253,108.038092&amp;amp;spn=10.736219,26.751932&amp;amp;output=embed&#34;&gt;&lt;/iframe&gt;&lt;br /&gt;&lt;small&gt;在较大的地图中查看&lt;a href=&#34;http://maps.google.com/maps/ms?ie=UTF8&amp;amp;hl=zh-CN&amp;amp;msa=0&amp;amp;msid=111375824033091419173.000492bc1a79cbd56a83d&amp;amp;ll=36.590253,108.038092&amp;amp;spn=10.736219,26.751932&amp;amp;source=embed&#34; style=&#34;color:#0000FF;text-align:left&#34;&gt;西游季&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;

&lt;p&gt;一路风光无限:
&lt;a href=&#34;http://www.flickr.com/photos/eltonphotos/5085449430/&#34; title=&#34;IMG_5629 by Elton.Zheng, on Flickr&#34;&gt;&lt;img src=&#34;http://farm5.static.flickr.com/4111/5085449430_87d047cdef.jpg&#34; width=&#34;500&#34; height=&#34;333&#34; alt=&#34;IMG_5629&#34; /&gt;&lt;/a&gt;
西夏王陵&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.flickr.com/photos/eltonphotos/5085829272/&#34; title=&#34;IMG_5861 by Elton.Zheng, on Flickr&#34;&gt;&lt;img src=&#34;http://farm5.static.flickr.com/4146/5085829272_2f7fa06b7c.jpg&#34; width=&#34;500&#34; height=&#34;333&#34; alt=&#34;IMG_5861&#34; /&gt;&lt;/a&gt;
额济纳旗二道桥胡杨林&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.flickr.com/photos/eltonphotos/5085912216/&#34; title=&#34;IMG_6275 by Elton.Zheng, on Flickr&#34;&gt;&lt;img src=&#34;http://farm5.static.flickr.com/4086/5085912216_0cd88cdac2.jpg&#34; width=&#34;500&#34; height=&#34;333&#34; alt=&#34;IMG_6275&#34; /&gt;&lt;/a&gt;
敦煌莫高窟&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.flickr.com/photos/eltonphotos/5086197250/&#34; title=&#34;IMG_6402 by Elton.Zheng, on Flickr&#34;&gt;&lt;img src=&#34;http://farm5.static.flickr.com/4111/5086197250_60fbcc21b3.jpg&#34; width=&#34;500&#34; height=&#34;333&#34; alt=&#34;IMG_6402&#34; /&gt;&lt;/a&gt;
张掖丹霞地貌&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.flickr.com/photos/eltonphotos/5085653731/&#34; title=&#34;IMG_1055 by Elton.Zheng, on Flickr&#34;&gt;&lt;img src=&#34;http://farm5.static.flickr.com/4084/5085653731_ed8ec729fc.jpg&#34; width=&#34;500&#34; height=&#34;374&#34; alt=&#34;IMG_1055&#34; /&gt;&lt;/a&gt;
翻越海拔超过4000米的祁连雪山&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.flickr.com/photos/eltonphotos/5085886733/&#34; title=&#34;IMG_6647 by Elton.Zheng, on Flickr&#34;&gt;&lt;img src=&#34;http://farm5.static.flickr.com/4103/5085886733_1612f9869c.jpg&#34; width=&#34;500&#34; height=&#34;351&#34; alt=&#34;IMG_6647&#34; /&gt;&lt;/a&gt;
麦积山石窟&lt;/p&gt;

&lt;p&gt;更多精彩照片在这里：&lt;a href=&#34;http://www.flickr.com/photos/eltonphotos/collections/72157625048328465/&#34; target=&#34;_blank&#34;&gt;http://www.flickr.com/photos/eltonphotos/collections/72157625048328465/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在Mac OSX下安装和使用GO语言</title>
      <link>http://blog.prosight.me/blogs/655</link>
      <pubDate>2010-08-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Go语言是Google新推出的结合了动态语言和静态语言优势的一个新兴的语言。下面介绍一下如何在Mac系统下安装和使用这个语言。&lt;/p&gt;

&lt;h2&gt;设置环境变量&lt;/h2&gt;

&lt;p&gt;$GOROOT
GO语言的根目录，通常是$HOME/go，当然也可以是任何其他目录。&lt;/p&gt;

&lt;p&gt;$GOOS 和 $GOARCH
标明GO语言所在的系统和处理器类型。$GOOS可以是linux, freebsd, darwin (Mac OS X 10.5 or 10.6)和 nacl (Native Client, an incomplete port)。$GOARCH可以是amd64 (64-bit x86, the most mature port), 386 (32-bit x86), arm (32-bit ARM, an incomplete port)。&lt;/p&gt;

&lt;p&gt;你可以在你的shell profile中设置这些变量，我是放在了~/.bash_profile里了。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;export GOROOT=$HOME/go
export GOARCH=amd64
export GOOS=darwin
export PATH=$PATH:$GOROOT/bin&lt;/pre&gt;
其中， $GOROOT/bin是GO默认的可执行文件的目录，加入到path中方便使用go的各种命令。&lt;/p&gt;

&lt;p&gt;再执行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;source ~/.bash_profile&lt;/pre&gt;
使最新的配置文件生效。&lt;/p&gt;

&lt;h2&gt;获得源文件&lt;/h2&gt;

&lt;p&gt;如果你的系统中没有安装Mercurial（没有安装它，你就无法使用hg命令），那么使用这个命令来安装它：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo easy_install mercurial
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;然后使用下面的命令，还获得GO语言的源文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ hg clone -r release &lt;a href=&#34;https://go.googlecode.com/hg/&#34;&gt;https://go.googlecode.com/hg/&lt;/a&gt; $GOROOT
&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;安装GO语言&lt;/h2&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cd $GOROOT/src
$ ./all.bash
&lt;/pre&gt;

&lt;p&gt;如果一切正常，你应该可以在最后看到类似的结果：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&amp;mdash; cd ../test
N known bugs; 0 unexpected bugs
&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;撰写第一个Hello,World&lt;/h2&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cat &gt;hello.go &lt;&lt;EOF
package main

import &#34;fmt&#34;

func main() {
    fmt.Printf(&#34;hello, worldn&#34;)
}
EOF

$ 6g hello.go
$ 6l hello.6
$ ./6.out
hello, world
$
&lt;/pre&gt;

&lt;h2&gt;日后更新&lt;/h2&gt;

&lt;p&gt;Go是一个发展中的语言，它的版本会经常进行更新，可以使用以下命令，保持GO语言是最新版本的
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cd $GOROOT/src
$ hg pull
$ hg update release
$ ./all.bash
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Go的官方网站是:&lt;a href=&#34;http://golang.org/&#34; target=&#34;_blank&#34;&gt;http://golang.org&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>额尔古纳逐梦之旅</title>
      <link>http://blog.prosight.me/blogs/636</link>
      <pubDate>2010-08-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;经过了6天的跋涉，终于完成了此次内蒙古的行程。一路走过确实很辛苦，但是也很快乐。体会到了人生的真正含义，感受到了祖国的大好河山。&lt;/p&gt;

&lt;p&gt;从上海出发，沿途经过江苏、安徽、河北、天津、辽宁、吉林、黑龙江，最后到达内蒙古。共计8天时间，全程逾6千公里。 具体路线如下：
&lt;img alt=&#34;&#34; src=&#34;http://farm5.static.flickr.com/4141/4880944750_1e2a026a3a.jpg&#34; title=&#34;行程路线图&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;499&#34; /&gt;&lt;/p&gt;

&lt;p&gt;蓝色为去程，红色为返程。&lt;/p&gt;

&lt;p&gt;D1: 上海 - 唐山 1,235 公里
D2：唐山 - 哈尔滨  1,094 公里
D3：哈大高速（哈尔滨-大庆）-301国道（大庆-齐齐哈尔-阿荣旗（那吉）- 博克图 - 牙克石-呼伦贝尔草原-海拉尔），818公里
D4：海拉尔 - 金帐汗 - 额尔古纳 - 恩和 -  室韦 287公里
D5：室韦 - 黑山头 - 满州里330公里(走边防公路（摄影小路）全程草原风光摄影爱好者的天堂 黑山头界河游坐船饱览两岸风光住满洲里欣赏满洲里夜景）
D6：203省道（满洲里 - 达来 - 新巴尔虎右旗 - 甘珠尔 - 新巴尔虎左旗 - 罕达盖 - 伊尔施 - 阿尔山市）- 111国道 - 乌兰浩特
D7： 111国道（乌兰浩特 - 科尔沁右旗中旗 - 通辽）- 大连
D8：大连 - 葫芦岛滚装轮渡 - 上海&lt;/p&gt;

&lt;p&gt;美丽的额尔古纳
&lt;img alt=&#34;额尔古纳&#34; src=&#34;http://farm5.static.flickr.com/4136/4879434402_658dcf50c2.jpg&#34; title=&#34;美丽的额尔古纳&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://farm5.static.flickr.com/4074/4878893655_2e76c68e2a.jpg&#34; title=&#34;美丽的额尔古纳&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;边陲小镇 - 室韦
&lt;img alt=&#34;室韦&#34; src=&#34;http://farm5.static.flickr.com/4143/4878743537_2d4f3caa5b.jpg&#34; title=&#34;室韦&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;山顶的卫星接收站
&lt;img alt=&#34;额尔古纳&#34; src=&#34;http://farm5.static.flickr.com/4136/4878716343_ac7eb0d8fd_z.jpg&#34; title=&#34;卫星站&#34; class=&#34;alignnone&#34; width=&#34;427&#34; height=&#34;640&#34; /&gt;&lt;/p&gt;

&lt;p&gt;室韦 - 满洲里的边境公路
&lt;img alt=&#34;边境公路&#34; src=&#34;http://farm5.static.flickr.com/4140/4878812737_282d48e49a.jpg&#34; title=&#34;室韦 - 满洲里的边境公路&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;边境公路&#34; src=&#34;http://farm5.static.flickr.com/4073/4879051967_e584fa1b8c.jpg&#34; title=&#34;边境公路&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;美丽的中俄界河 额尔古纳河
&lt;img alt=&#34;额尔古纳河&#34; src=&#34;http://farm5.static.flickr.com/4098/4879689024_bf7cb80fa0.jpg&#34; title=&#34;额尔古纳河&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;漂亮的满洲里
&lt;img alt=&#34;满洲里&#34; src=&#34;http://farm5.static.flickr.com/4118/4879953262_5e2b15aeb7.jpg&#34; title=&#34;满洲里&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;阿尔山国家地质公园
&lt;img alt=&#34;阿尔山&#34; src=&#34;http://farm5.static.flickr.com/4119/4879955964_1d8776df05.jpg&#34; title=&#34;阿尔山&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;333&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;阿尔山&#34; src=&#34;http://farm5.static.flickr.com/4123/4879354973_cf7ba41329.jpg&#34; title=&#34;阿尔山&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;287&#34; /&gt;&lt;/p&gt;

&lt;p&gt;更多图片在我的&lt;a href=&#34;http://www.flickr.com/photos/eltonphotos/sets/72157624570591825/&#34; target=&#34;_blank&#34;&gt;相册&lt;/a&gt;里。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>URL设计准则</title>
      <link>http://blog.prosight.me/blogs/640</link>
      <pubDate>2010-08-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;URL 设计是 Web 设计中常被忽视的东西，事实上 URL 非常重要，这不仅是一个网页唯一的路径，还涉及到你的站点是否干净，友好。本文讲述 URL 这个司空见惯的 Web 元素中包含的大量不应为忽视的知识，准则与最佳实践。需要注意的是 W3C 建议使用 URI 取代 URL 一说。
关于 URL 的一些准则
首先是与 URL 有关的一些准则。&lt;/p&gt;

&lt;h2&gt;一个 URL 必须唯一地，永久地代表一个在线对象&lt;/h2&gt;

&lt;p&gt;URL 的最基本的使命是唯一地代表 Internet 上的一个对象，URL 必须和 Internet 上的对象一对一匹配。然而现实中，这很难实现，我们经常可以通过多个 URL 到达同一个页面，比如， &lt;a href=&#34;http://mysite.com/product/tv&#34;&gt;http://mysite.com/product/tv&lt;/a&gt; 和 &lt;a href=&#34;http://mysite.com/product?name=tv，这种情形在现代&#34;&gt;http://mysite.com/product?name=tv，这种情形在现代&lt;/a&gt; CMS 中更是比比皆是，针对这个问题，SEO moz 有一篇很好的文章，讲到了如何使用 Canonical URL 机制解决站点中的重复 URL 问题。
URL 应该是永久的，这就要求你在站点上线前就非常严谨地规划 URL。如果有一天，你不得不更改 URL，一定使用 HTTP 301 机制，告诉浏览器和搜索引擎，你的那个 URL 所代表的对象，已经搬迁到新地址，这个机制可以保证你旧地址所获得 PR 不会被清零。&lt;/p&gt;

&lt;h2&gt;尽可能用户友好&lt;/h2&gt;

&lt;p&gt;这是 URL 设计的根本，你的 URL 应该为最终用户而设计。保持 URL 友好的一个好办法是在保证可读性的同时让它尽可能短。比如 /about 就好过 /about-acme-corp-page，当然，保持简短不能牺牲可读性， /13d2 一类的地址短则短矣，但并不友好。如果要在 Twitter， Facebook 一类的社会媒体网络分享你的 URL，可以使用 Bit.ly 一类的网址缩短工具，但这种工具产生的缩短 URL 并不友好，在 Wordpress 一类的 CMS 中，可以使用 PrettyLink Pro 或 Short URL plugin 一类的可控制的地址缩短插件。
&lt;img alt=&#34;&#34; src=&#34;http://cdn.css-tricks.com/wp-content/uploads/2010/07/wordpresshortlink.png&#34; title=&#34;尽可能的友好的URL&#34; class=&#34;alignnone&#34; width=&#34;517&#34; height=&#34;95&#34; /&gt;&lt;/p&gt;

&lt;p&gt;URL 的设计切忌使用一些对用户来说没有意义的内容，比如数据库的 ID 号， /products/23 这样的 URL 地址对用户是极不友好的，应当使用 /products/ballpoint-pen 一类的地址。&lt;/p&gt;

&lt;h2&gt;保持一致性&lt;/h2&gt;

&lt;p&gt;站点内的所有 URL 必须保持一致的格式和结构，这样可以为用户带来信任感，如果你必须更改 URL 格式和结构，需要使用 HTTP 301 机制。&lt;/p&gt;

&lt;h2&gt;可预测的 URL&lt;/h2&gt;

&lt;p&gt;这也是 URL 一致性的一个表现，如果你的 URL 拥有很好的一致性，用户可以根据 URL 猜测别的内容的 URL，假如 /events/&lt;sup&gt;2010&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt; 指向 2010 年 1 月份的日程内容，那
/events/&lt;sup&gt;2009&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt; 应当指向 2009 年 1 月的日程。
/events/2010 应当指向 2010 年全年的日程。
/events/&lt;sup&gt;2010&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;/21 应当指向2010年1月21日的日程。&lt;/p&gt;

&lt;h2&gt;URL中的关键词&lt;/h2&gt;

&lt;p&gt;URL 中应该包含本页重点内容的关键词，比如 /posts/&lt;sup&gt;2010&lt;/sup&gt;&amp;frasl;&lt;sub&gt;07&lt;/sub&gt;/02/trip-best-buy-memory-cards 一类的 URL 本身就是对页面内容的反应。在 URL 包含重点内容关键词，也可以提高 SEO 性能。SEO 的一个很重要的原则就是，在 URL 地址中包含内容关键词。
关于 URL 的技术细节
下面说的是有关 URL 的一些技术细节。&lt;/p&gt;

&lt;h2&gt;URL 不应包含 .html, aspx, cfm 一类的后缀&lt;/h2&gt;

&lt;p&gt;这类信息对最终用户是没有意义的，却占了额外的空间，一个例外是 .atom, .rss, .json 一类的特殊地址，这类地址是有特别的意义的。译者注：在某些虚拟主机式 Web 服务器，这种做法未必现实。&lt;/p&gt;

&lt;h2&gt;URL 不应包含 WWW 部分&lt;/h2&gt;

&lt;p&gt;WWW 部分并不包含任何意义，是一个额外的负担，不友好。可以使用 HTTP 301 机制，将 www.domain.com 定向到 domain.com 。&lt;/p&gt;

&lt;h2&gt;URL 的格式&lt;/h2&gt;

&lt;p&gt;URL 的格式如下:
domain.com/[key information]/[name]/?[modifiers]
Key information 部分一般代表信息的类型或类别。Modifiers 部分则属于查询字符串范畴，它不应当代表数据结构，应当代表数据的修饰。Key information 部分应当尽可能简短，同时应当表现出一种层级关系，比如 &lt;a href=&#34;http://domain.com/posts/servers/nginx-ubuntu-10.04，或&#34;&gt;http://domain.com/posts/servers/nginx-ubuntu-10.04，或&lt;/a&gt; &lt;a href=&#34;http://domain.com/news/tech/2007/11/05/google-announces-android。&#34;&gt;http://domain.com/news/tech/2007/11/05/google-announces-android。&lt;/a&gt;
Google News 对新闻源有一个有趣的要求，Google 要求新闻源页面的 URL 中必须包含至少 3 位唯一的数字，因为他们会忽略年份数字，因此，应该使用一个5位或5位以上的数字。另外，也应该提供 Google News 站点地图 。如果你想向 Google 提供新闻，必须按这样的结构提供 URL，当然保持一致性，可以预测性也是必需的。&lt;/p&gt;

&lt;h2&gt;使用小写字符&lt;/h2&gt;

&lt;p&gt;URL 中所有字符都应使用小写，这更容易阅读。&lt;/p&gt;

&lt;h2&gt;URL 中包含的行为元素&lt;/h2&gt;

&lt;p&gt;URL 查询字符串中可能包含一些表示行为的元素，比如 show, delete, edit 等。非破坏性的行为可以体现在 URL 中，破坏性的行为应该使用 POST 。&lt;/p&gt;

&lt;h2&gt;使用 URL 友好字符&lt;/h2&gt;

&lt;p&gt;在 URL 中体现网页标题的时候，往往会用到一些特殊字符，应当把它们转换为 URL 友好字符：
全部大写字符换成小写
诸如 é 一类的字符应转换成对应的 e
空格使用短划线代替
诸如 !, @, #, $, %, ^, &amp;amp;, * 一类的字符应该使用短划线代替
双短划线应该使用单短划线代替
另外，没有必要的话，避免使用 %20 一类的 URL 逃逸符。&lt;/p&gt;

&lt;h2&gt;更多观点&lt;/h2&gt;

&lt;p&gt;Chris Shiflett 建议，可以使用一些类似句子的 URL，如：
chriscoyier.net/authored/digging-into-wordpress/
chriscoyier.net/has-worked-for/chatman-design/
chriscoyier.net/likes/trailer-park-boys
jacobwg.com/thinks/this-post/is/basically-done&lt;/p&gt;

&lt;p&gt;译者补充：URL 的长度上限
URL 的最大长度是多少？W3C 的 HTTP 协议 并没有限定，然而，在实际应用中，经过试验，不同浏览器和 Web 服务器有不同的约定：
IE 的 URL 长度上限是 2083 字节，其中纯路径部分不能超过 2048 字节。
Firefox 浏览器的地址栏中超过 65536 字符后就不再显示。
Safari 浏览器一致测试到 80000 字符还工作得好好的。
Opera 浏览器测试到 190000 字符的时候，还正常工作。
Web 服务器：
Apache Web 服务器在接收到大约 4000 字符长的 URL 时候产生 413 Entity Too Large&amp;rdquo; 错误。
IIS 默认接收的最大 URL 是 16384 字符。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone/Mac Objective-C内存管理教程和原理剖析(四)系统自动创建新的autorelease pool</title>
      <link>http://blog.prosight.me/blogs/633</link>
      <pubDate>2010-07-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;四 系统自动创建新的autorelease pool
在生成新的Run Loop的时候，系统会自动创建新的autorelease pool（非常感谢网友hhyytt和neogui的提醒）。注意，此处不同于xcode在新建项目时自动生成的代码中加入的autorelease pool，xcode生成的代码可以被删除，但系统自动创建的新的autorelease pool是无法删除的（对于无Garbage Collection的环境来说）。Objective-C没有给出实现代码，官方文档也没有说明，但我们可以通过小程序来证明。
在这个小程序中，我们先生成了一个autorelease pool，然后生成一个autorelease的ClassA的实例，再在一个新的run loop中生成一个autorelease的ClassB的对象（注意，我们并没有手动在新run loop中生成autorelease pool）。精简的示例代码如下，详细代码请见附件中的memman-run-loop-with-pool.m。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
int main(int argc, char**argv)
{
         NSLog(@&amp;ldquo;create an autorelasePooln&amp;rdquo;);
         NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     NSLog(@&amp;quot;create an instance of ClassA and autoreleasen&amp;quot;);
     ClassA *obj1 = [[[ClassA alloc] init] autorelease];
     NSDate *now = [[NSDate alloc] init];
     NSTimer *timer = [[NSTimer alloc] initWithFireDate:now
               interval:0.0
               target:obj1
               selector:@selector(createClassB)
               userInfo:nil
               repeats:NO];
     NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
     [runLoop addTimer:timer forMode:NSDefaultRunLoopMode];
     [timer release];
     [now release];
     [runLoop run]; //在新loop中调用一函数，生成ClassB的autorelease实例

     NSLog(@&amp;quot;releasing autorelasePooln&amp;quot;);
     [pool release];
     NSLog(@&amp;quot;autorelasePool is releasedn&amp;quot;);
     return 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;
输出如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
create an autorelasePool
create an instance of ClassA and autorelease
create an instance of ClassB and autorelease
ClassB destroyed
releasing autorelasePool
ClassA destroyed
autorelasePool is released
&lt;/pre&gt;
注意在我们销毁autorelease pool之前，ClassB的autorelease实例就已经被销毁了。
有人可能会说，这并不能说明新的run loop自动生成了一个新的autorelease pool，说不定还只是用了老的autorelease pool，只不过后来drain了一次而已。我们可以在main函数中不生成autorelease pool。精简的示例代码如下，详细代码请见附件中的memman-run-loop-without-pool.m。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
int main(int argc, char**argv)
{
         NSLog(@&amp;ldquo;No autorelasePool createdn&amp;rdquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     NSLog(@&amp;quot;create an instance of ClassAn&amp;quot;);
     ClassA *obj1 = [[ClassA alloc] init];
     NSDate *now = [[NSDate alloc] init];
     NSTimer *timer = [[NSTimer alloc] initWithFireDate:now
               interval:0.0
               target:obj1
               selector:@selector(createClassB)
               userInfo:nil
               repeats:NO];
     NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
     [runLoop addTimer:timer forMode:NSDefaultRunLoopMode];
     [timer release];
     [now release];
     [runLoop run]; //在新loop中调用一函数，生成ClassB的autorelease实例
     NSLog(@&amp;quot;Manually release the instance of ClassAn&amp;quot;);
     [obj1 release];

     return 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;
输出如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
No autorelasePool created
create an instance of ClassA
create an instance of ClassB and autorelease
ClassB destroyed
Manually release the instance of ClassA
ClassA destroyed
&lt;/pre&gt;
我们可以看出来，我们并没有创建任何autorelease pool，可是ClassB的实例依然被自动销毁了，这说明新的run loop自动创建了一个autorelease pool，这个pool在新的run loop结束的时候会销毁自己（并自动release所包含的对象）。&lt;/p&gt;

&lt;p&gt;补充说明
在研究retain count的时候，我不建议用NSString。因为在下面的语句中，
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSString *str1 = @”constant string”;
&lt;/pre&gt;
str1的retain count是个很大的数字。Objective-C对常量字符串做了特殊处理。
当然，如果你这样创建NSString，得到的retain count依然为1
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSString *str2 = [NSString stringWithFormat:@”123”];
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;摘自：http://www.cnblogs.com/VinceYuan&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone/Mac Objective-C内存管理教程和原理剖析(一)基本原理</title>
      <link>http://blog.prosight.me/blogs/625</link>
      <pubDate>2010-07-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;前言
初学objectice-C的朋友都有一个困惑，总觉得对objective-C的内存管理机制琢磨不透，程序经常内存泄漏或莫名其妙的崩溃。我在这里总结了自己对objective-C内存管理机制的研究成果和经验，写了这么一个由浅入深的教程。希望对大家有所帮助，也欢迎大家一起探讨。&lt;/p&gt;

&lt;p&gt;此文涉及的内存管理是针对于继承于NSObject的Class。
一 基本原理
Objective-C的内存管理机制与.Net/Java那种全自动的垃圾回收机制是不同的，它本质上还是C语言中的手动管理方式，只不过稍微加了一些自动方法。
1 Objective-C的对象生成于堆之上，生成之后，需要一个指针来指向它。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *obj1 = [[ClassA alloc] init];
 &lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;2 Objective-C的对象在使用完成之后不会自动销毁，需要执行dealloc来释放空间（销毁），否则内存泄露。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[obj1 dealloc];
&lt;/pre&gt;
         这带来了一个问题。下面代码中obj2是否需要调用dealloc？
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *obj1 = [[ClassA alloc] init];
ClassA *obj2 = obj1;
[obj1 hello]; //输出hello
[obj1 dealloc];
[obj2 hello]; //能够执行这一行和下一行吗？
[obj2 dealloc];
&lt;/pre&gt;
         不能，因为obj1和obj2只是指针，它们指向同一个对象，[obj1 dealloc]已经销毁这个对象了，不能再调用[obj2 hello]和[obj2 dealloc]。obj2实际上是个无效指针。
         如何避免无效指针？请看下一条。&lt;/p&gt;

&lt;p&gt;3  Objective-C采用了引用计数(ref count或者retain count)。对象的内部保存一个数字，表示被引用的次数。例如，某个对象被两个指针所指向（引用）那么它的retain count为2。需要销毁对象的时候，不直接调用dealloc，而是调用release。release会让retain count减1，只有retain count等于0，系统才会调用dealloc真正销毁这个对象。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *obj1 = [[ClassA alloc] init]; //对象生成时，retain count = 1
[obj1 release]; //release使retain count减1，retain count = 0，dealloc自动被调用,对象被销毁
&lt;/pre&gt;
我们回头看看刚刚那个无效指针的问题，把dealloc改成release解决了吗？
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *obj1 = [[ClassA alloc] init]; //retain count = 1
ClassA *obj2 = obj1; //retain count = 1
[obj1 hello]; //输出hello
[obj1 release]; //retain count = 0，对象被销毁
[obj2 hello];
[obj2 release];
&lt;/pre&gt;
         [obj1 release]之后，obj2依然是个无效指针。问题依然没有解决。解决方法见下一条。&lt;/p&gt;

&lt;p&gt;4 Objective-C指针赋值时，retain count不会自动增加，需要手动retain。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *obj1 = [[ClassA alloc] init]; //retain count = 1
ClassA *obj2 = obj1; //retain count = 1
[obj2 retain]; //retain count = 2
[obj1 hello]; //输出hello
[obj1 release]; //retain count = 2 – 1 = 1
[obj2 hello]; //输出hello
[obj2 release]; //retain count = 0，对象被销毁
&lt;/pre&gt;
问题解决！注意，如果没有调用[obj2 release]，这个对象的retain count始终为1，不会被销毁，内存泄露。(1-4可以参考附件中的示例程序memman-no-pool.m)
这样的确不会内存泄露，但似乎有点麻烦，有没有简单点的方法？见下一条。&lt;/p&gt;

&lt;p&gt;5  Objective-C中引入了autorelease pool（自动释放对象池），在遵守一些规则的情况下，可以自动释放对象。（autorelease pool依然不是.Net/Java那种全自动的垃圾回收机制）
5.1          新生成的对象，只要调用autorelease就行了，无需再调用release！
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *obj1 = [[[ClassA alloc] init] autorelease]; //retain count = 1 但无需调用release
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;5.2          对于存在指针赋值的情况，代码与前面类似。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *obj1 = [[[ClassA alloc] init] autorelease]; //retain count = 1
ClassA *obj2 = obj1; //retain count = 1
[obj2 retain]; //retain count = 2
[obj1 hello]; //输出hello
//对于obj1，无需调用（实际上不能调用）release
[obj2 hello]; //输出hello
[obj2 release]; //retain count = 2-1 = 1
 &lt;/pre&gt;
细心的读者肯定能发现这个对象没有被销毁，何时销毁呢？谁去销毁它？（可以参考附件中的示例程序memman-with-pool.m）请看下一条。&lt;/p&gt;

&lt;p&gt;6 autorelease pool原理剖析。（其实很简单的，一定要坚持看下去，否则还是不能理解Objective-C的内存管理机制。）
6.1 autorelease pool不是天生的，需要手动创立。只不过在新建一个iphone项目时，xcode会自动帮你写好。autorelease pool的真名是NSAutoreleasePool。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
&lt;/pre&gt;
6.2 NSAutoreleasePool内部包含一个数组（NSMutableArray），用来保存声明为autorelease的所有对象。如果一个对象声明为autorelease，系统所做的工作就是把这个对象加入到这个数组中去。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *obj1 = [[[ClassA alloc] init] autorelease]; //retain count = 1，把此对象加入autorelease pool中
&lt;/pre&gt;
6.3  NSAutoreleasePool自身在销毁的时候，会遍历一遍这个数组，release数组中的每个成员。如果此时数组中成员的retain count为1，那么release之后，retain count为0，对象正式被销毁。如果此时数组中成员的retain count大于1，那么release之后，retain count大于0，此对象依然没有被销毁，内存泄露。
6.4          默认只有一个autorelease pool，通常类似于下面这个例子。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
int main (int argc, const char *argv[])
{
NSAutoreleasePool *pool;
pool = [[NSAutoreleasePool alloc] init];&lt;/p&gt;

&lt;p&gt;// do something&lt;/p&gt;

&lt;p&gt;[pool release];
return (0);
} // main
&lt;/pre&gt;
所有标记为autorelease的对象都只有在这个pool销毁时才被销毁。如果你有大量的对象标记为autorelease，这显然不能很好的利用内存，在iphone这种内存受限的程序中是很容易造成内存不足的。例如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
int main (int argc, const char *argv[])
{
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
int i, j;
for (i = 0; i &amp;lt; 100; i++ )
{
 for (j = 0; j &amp;lt; 100000; j++ )
    [NSString stringWithFormat:@&amp;ldquo;1234567890&amp;rdquo;];//产生的对象是autorelease的。
}
[pool release];
return (0);
} // main
&lt;/pre&gt;
（可以参考附件中的示例程序memman-many-objs-one-pool.m，运行时通过监控工具可以发现使用的内存在急剧增加，直到pool销毁时才被释放）你需要考虑下一条。&lt;/p&gt;

&lt;p&gt;7 Objective-C程序中可以嵌套创建多个autorelease pool。在需要大量创建局部变量的时候，可以创建内嵌的autorelease pool来及时释放内存。（感谢网友hhyytt和neogui的提醒，某些情况下，系统会自动创建autorelease pool, 请参见第四章）
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
int main (int argc, const char *argv[])
{
NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
int i, j;
for (i = 0; i &amp;lt; 100; i++ )
{
 NSAutoreleasePool *loopPool = [[NSAutoreleasePool alloc] init];
 for (j = 0; j &amp;lt; 100000; j++ )
    [NSString stringWithFormat:@&amp;ldquo;1234567890&amp;rdquo;];//产生的对象是autorelease的。
 [loopPool release];
}
[pool release];
return (0);
} // main
&lt;/pre&gt;
（可以参考附件中的示例程序memman-many-objs-many-pools.m，占用内存的变化极小）&lt;/p&gt;

&lt;p&gt;转载自：http://www.cnblogs.com/VinceYuan&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone/Mac Objective-C内存管理教程和原理剖析(二)口诀与范式</title>
      <link>http://blog.prosight.me/blogs/628</link>
      <pubDate>2010-07-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;二 口诀与范式
1           口诀。
1.1          谁创建，谁释放（类似于“谁污染，谁治理”）。如果你通过alloc、new或copy来创建一个对象，那么你必须调用release或autorelease。换句话说，不是你创建的，就不用你去释放。
例如，你在一个函数中alloc生成了一个对象，且这个对象只在这个函数中被使用，那么你必须在这个函数中调用release或autorelease。如果你在一个class的某个方法中alloc一个成员对象，且没有调用autorelease，那么你需要在这个类的dealloc方法中调用release；如果调用了autorelease，那么在dealloc方法中什么都不需要做。
1.2          除了alloc、new或copy之外的方法创建的对象都被声明了autorelease。
1.3          谁retain，谁release。只要你调用了retain，无论这个对象是如何生成的，你都要调用release。有时候你的代码中明明没有retain，可是系统会在默认实现中加入retain。不知道为什么苹果公司的文档没有强调这个非常重要的一点，请参考范式2.7和第三章。
2           范式。
范式就是模板，就是依葫芦画瓢。由于不同人有不同的理解和习惯，我总结的范式不一定适合所有人，但我能保证照着这样做不会出问题。
2.1          创建一个对象。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA &lt;em&gt;obj1 = [[ClassA alloc] init];
&lt;/pre&gt;
2.2          创建一个autorelease的对象。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *obj1 = [[[ClassA alloc] init] autorelease];
&lt;/pre&gt;
2.3          Release一个对象后，立即把指针清空。（顺便说一句，release一个空指针是合法的，但不会发生任何事情）
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[obj1 release];
obj1 = nil;
&lt;/pre&gt;
2.4          指针赋值给另一个指针。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *obj2 = obj1;
[obj2 retain];
//do something
[obj2 release];
obj2 = nil;
&lt;/pre&gt;
2.5          在一个函数中创建并返回对象，需要把这个对象设置为autorelease
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassA *Func1()
{
  ClassA *obj = [[[ClassA alloc]init]autorelease];
  return obj;
}
&lt;/pre&gt;
2.6          在子类的dealloc方法中调用基类的dealloc方法
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-(void) dealloc
{
         …
         [super dealloc];
}
&lt;/pre&gt;
2.7          在一个class中创建和使用property。
2.7.1     声明一个成员变量。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ClassB *objB;
&lt;/pre&gt;
2.7.2     声明property，加上retain参数。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
@property (retain) ClassB&lt;/em&gt; objB;
&lt;/pre&gt;
2.7.3     定义property。（property的默认实现请看第三章）
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
@synthesize objB;
&lt;/pre&gt;
2.7.4     除了dealloc方法以外，始终用.操作符的方式来调用property。
self.objB 或者objA.objB
2.7.5     在dealloc方法中release这个成员变量。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[objB release];
&lt;/pre&gt;
示例代码如下（详细代码请参考附件中的memman-property.m，你需要特别留意对象是在何时被销毁的。）：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
@interface ClassA : NSObject
{
         ClassB* objB;
}&lt;/p&gt;

&lt;p&gt;@property (retain) ClassB* objB;
@end&lt;/p&gt;

&lt;p&gt;@implementation ClassA
@synthesize objB;
-(void) dealloc
{
         [objB release];
         [super dealloc];
}
@end
&lt;/pre&gt;
2.7.6     给这个property赋值时，有手动release和autorelease两种方式。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
void funcNoAutorelease()
{
         ClassB *objB1 = [[ClassB alloc]init];
         ClassA *objA = [[ClassA alloc]init];
         objA.objB = objB1;
         [objB1 release];
         [objA release];
}&lt;/p&gt;

&lt;p&gt;void funcAutorelease()
{
         ClassB *objB1 = [[[ClassB alloc]init] autorelease];
         ClassA *objA = [[[ClassA alloc]init] autorelease];
         objA.objB = objB1;
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;摘自： &lt;a href=&#34;http://www.cnblogs.com/VinceYuan/&#34;&gt;http://www.cnblogs.com/VinceYuan/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone/Mac Objective-C内存管理教程和原理剖析(三)@property (retain)和@synthesize的默认实现</title>
      <link>http://blog.prosight.me/blogs/630</link>
      <pubDate>2010-07-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;三 @property (retain)和@synthesize的默认实现
在这里解释一下@property (retain) ClassB* objB;和@synthesize objB;背后到底发生了什么(retain property的默认实现)。property实际上是getter和setter，针对有retain参数的property，背后的实现如下（请参考附件中的memman-getter-setter.m，你会发现，结果和memman-property.m一样）：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
@interface ClassA : NSObject
{
         ClassB *objB;
}&lt;/p&gt;

&lt;p&gt;-(ClassB *) getObjB;
-(void) setObjB:(ClassB *) value;
@end&lt;/p&gt;

&lt;p&gt;@implementation ClassA
-(ClassB*) getObjB
{
         return objB;
}&lt;/p&gt;

&lt;p&gt;-(void) setObjB:(ClassB*) value
{
         if (objB != value)
         {
                   [objB release];
                   objB = [value retain];
         }
}
&lt;/pre&gt;
在setObjB中，如果新设定的值和原值不同的话，必须要把原值对象release一次，这样才能保证retain count是正确的。
由于我们在class内部retain了一次（虽然是默认实现的），所以我们要在dealloc方法中release这个成员变量。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-(void) dealloc
{
         [objB release];
         [super dealloc];
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;摘自：http://www.cnblogs.com/VinceYuan&lt;/p&gt;
</description>
    </item>
    <item>
      <title>通过URL Rewrite来设置JBoss的301跳转</title>
      <link>http://blog.prosight.me/blogs/622</link>
      <pubDate>2010-07-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;strong&gt;Introduction&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The rewrite valve implements URL rewrite functionnality in a way that is very similar to mod_rewrite from Apache HTTP Server.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Configuration&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The rewrite valve is configured as a regular valve, by adding the following to server.xml as child of an Engine or Host element (or inside a context.xml file):&lt;/p&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;Valve className=&#34;org.jboss.web.rewrite.RewriteValve&#34; /&gt;&lt;/pre&gt;
The valve will then use a rewrite.properties file containing the rewrite directives, located according to the container it is assocaited to:&lt;/p&gt;

&lt;p&gt;If associated with an engine, it should be placed in a folder named [engine_name] placed either in the classloader, or in the conf folder of the current JBoss profile
If associated with a host, it should be placed in a folder named [engine_name]/[host_name] placed either in the classloader, or in the conf folder of the current JBoss profile
If associated with a context, it should be placed in the WEB-INF folder of the web application
Directives&lt;/p&gt;

&lt;p&gt;The rewrite.properties file contains a list of directives which closely resemble the directives used by mod_rewrite, in particular the central RewriteRule and RewriteCond directives.&lt;/p&gt;

&lt;p&gt;Note: This section is a modified version of the mod_rewrite documentation, which is Copyright 1995-2006 The Apache Software Foundation, and licensed under the under the Apache License, Version 2.0.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RewriteCond&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Syntax: RewriteCond TestString CondPattern&lt;/p&gt;

&lt;p&gt;The RewriteCond directive defines a rule condition. One or more RewriteCond can precede a RewriteRule directive. The following rule is then only used if both the current state of the URI matches its pattern, and if these conditions are met.&lt;/p&gt;

&lt;p&gt;TestString is a string which can contain the following expanded constructs in addition to plain text:&lt;/p&gt;

&lt;p&gt;RewriteRule backreferences: These are backreferences of the form $N (0 &amp;lt;= N &amp;lt;= 9), which provide access to the grouped parts (in parentheses) of the pattern, from the RewriteRule which is subject to the current set of RewriteCond conditions..
RewriteCond backreferences: These are backreferences of the form %N (1 &amp;lt;= N &amp;lt;= 9), which provide access to the grouped parts (again, in parentheses) of the pattern, from the last matched RewriteCond in the current set of conditions.
RewriteMap expansions: These are expansions of the form ${mapname:key|default}. See the documentation for RewriteMap for more details.
Server-Variables: These are variables of the form %{ NAME_OF_VARIABLE } where NAME_OF_VARIABLE can be a string taken from the following list:
HTTP headers:   connection &amp;amp; request:&lt;br /&gt;
HTTP_USER_AGENT
HTTP_REFERER
HTTP_COOKIE
HTTP_FORWARDED
HTTP_HOST
HTTP_PROXY_CONNECTION
HTTP_ACCEPT
REMOTE_ADDR
REMOTE_HOST
REMOTE_PORT
REMOTE_USER
REMOTE_IDENT
REQUEST_METHOD
SCRIPT_FILENAME
REQUEST_PATH
CONTEXT_PATH
SERVLET_PATH
PATH_INFO
QUERY_STRING
AUTH_TYPE
server internals:   date and time:  specials:
DOCUMENT_ROOT
SERVER_NAME
SERVER_ADDR
SERVER_PORT
SERVER_PROTOCOL
SERVER_SOFTWARE
TIME_YEAR
TIME_MON
TIME_DAY
TIME_HOUR
TIME_MIN
TIME_SEC
TIME_WDAY
TIME
THE_REQUEST
REQUEST_URI
REQUEST_FILENAME
HTTPS
These variables all correspond to the similarly named HTTP MIME-headers and Servlet API methods. Most are documented elsewhere in the Manual or in the CGI specification. Those that are special to the rewrite valve include those below.&lt;/p&gt;

&lt;p&gt;REQUEST_PATH
Corresponds to the full path that is used for mapping.
CONTEXT_PATH
Corresponds to the path of the mapped context.
SERVLET_PATH
Corresponds to the servlet path.
THE_REQUEST
The full HTTP request line sent by the browser to the server (e.g., &amp;ldquo;GET /index.html HTTP/1.1&amp;rdquo;). This does not include any additional headers sent by the browser.
REQUEST_URI
The resource requested in the HTTP request line. (In the example above, this would be &amp;ldquo;/index.html&amp;rdquo;.)
REQUEST_FILENAME
The full local filesystem path to the file or script matching the request.
HTTPS
Will contain the text &amp;ldquo;on&amp;rdquo; if the connection is using SSL/TLS, or &amp;ldquo;off&amp;rdquo; otherwise.
Other things you should be aware of:&lt;/p&gt;

&lt;p&gt;The variables SCRIPT_FILENAME and REQUEST_FILENAME contain the same value - the value of the filename field of the internal request_rec structure of the Apache server. The first name is the commonly known CGI variable name while the second is the appropriate counterpart of REQUEST_URI (which contains the value of the uri field of request_rec).
%{ENV:variable}, where variable can be any Java system property, is also available.
%{SSL:variable}, where variable is the name of an SSL environment variable, are not implemented yet. Example: %{SSL:SSL_CIPHER_USEKEYSIZE} may expand to 128.
%{HTTP:header}, where header can be any HTTP MIME-header name, can always be used to obtain the value of a header sent in the HTTP request. Example: %{HTTP:Proxy-Connection} is the value of the HTTP header Proxy-Connection:&amp;ldquo;.
CondPattern is the condition pattern, a regular expression which is applied to the current instance of the TestString. TestString is first evaluated, before being matched against CondPattern.&lt;/p&gt;

&lt;p&gt;Remember: CondPattern is a perl compatible regular expression with some additions:&lt;/p&gt;

&lt;p&gt;You can prefix the pattern string with a &amp;lsquo;!&amp;rsquo; character (exclamation mark) to specify a non-matching pattern.
There are some special variants of CondPatterns. Instead of real regular expression strings you can also use one of the following:
&amp;lsquo;&lt;CondPattern&#39; (lexicographically precedes)
Treats the CondPattern as a plain string and compares it lexicographically to TestString. True if TestString lexicographically precedes CondPattern.
&#39;&gt;CondPattern&amp;rsquo; (lexicographically follows)
Treats the CondPattern as a plain string and compares it lexicographically to TestString. True if TestString lexicographically follows CondPattern.
&amp;lsquo;=CondPattern&amp;rsquo; (lexicographically equal)
Treats the CondPattern as a plain string and compares it lexicographically to TestString. True if TestString is lexicographically equal to CondPattern (the two strings are exactly equal, character for character). If CondPattern is &amp;ldquo;&amp;rdquo; (two quotation marks) this compares TestString to the empty string.
&amp;lsquo;-d&amp;rsquo; (is directory)
Treats the TestString as a pathname and tests whether or not it exists, and is a directory.
&amp;lsquo;-f&amp;rsquo; (is regular file)
Treats the TestString as a pathname and tests whether or not it exists, and is a regular file.
&amp;lsquo;-s&amp;rsquo; (is regular file, with size)
Treats the TestString as a pathname and tests whether or not it exists, and is a regular file with size greater than zero.
. All of these tests can also be prefixed by an exclamation mark (&amp;lsquo;!&amp;rsquo;) to negate their meaning.
You can also set special flags for CondPattern by appending [flags] as the third argument to the RewriteCond directive, where flags is a comma-separated list of any of the following flags:
&amp;lsquo;nocase|NC&amp;rsquo; (no case)
This makes the test case-insensitive - differences between &amp;lsquo;A-Z&amp;rsquo; and &amp;lsquo;a-z&amp;rsquo; are ignored, both in the expanded TestString and the CondPattern. This flag is effective only for comparisons between TestString and CondPattern. It has no effect on filesystem and subrequest checks.
&amp;lsquo;ornext|OR&amp;rsquo; (or next condition)
Use this to combine rule conditions with a local OR instead of the implicit AND. Typical example:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
RewriteCond %{REMOTE_HOST}  ^host1.*  [OR]
RewriteCond %{REMOTE_HOST}  ^host2.*  [OR]
RewriteCond %{REMOTE_HOST}  ^host3.*
&lt;/pre&gt;
RewriteRule &amp;hellip;some special stuff for any of these hosts&amp;hellip;
Without this flag you would have to write the condition/rule pair three times.
Example:&lt;/p&gt;

&lt;p&gt;To rewrite the Homepage of a site according to the User-Agent:&amp;rdquo; header of the request, you can use the following:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
RewriteCond  %{HTTP_USER_AGENT}  ^Mozilla.*
RewriteRule  ^/$                 /homepage.max.html  [L]&lt;/p&gt;

&lt;p&gt;RewriteCond  %{HTTP_USER_AGENT}  ^Lynx.*
RewriteRule  ^/$                 /homepage.min.html  [L]&lt;/p&gt;

&lt;p&gt;RewriteRule  ^/$                 /homepage.std.html  [L]
&lt;/pre&gt;
Explanation: If you use a browser which identifies itself as &amp;lsquo;Mozilla&amp;rsquo; (including Netscape Navigator, Mozilla etc), then you get the max homepage (which could include frames, or other special features). If you use the Lynx browser (which is terminal-based), then you get the min homepage (which could be a version designed for easy, text-only browsing). If neither of these conditions apply (you use any other browser, or your browser identifies itself as something non-standard), you get the std (standard) homepage.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;RewriteMap&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Syntax: RewriteMap name rewriteMapClassName optionalParameters&lt;/p&gt;

&lt;p&gt;The maps are implemented using an interface that users must implement. Its class name is org.jboss.web.rewrite.RewriteMap, and its code is:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
package org.jboss.web.rewrite;&lt;/p&gt;

&lt;p&gt;public interface RewriteMap {
    public String setParameters(String params);
    public String lookup(String key);
}
&lt;/pre&gt;
&lt;strong&gt;RewriteRule&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Syntax: RewriteRule Pattern Substitution&lt;/p&gt;

&lt;p&gt;The RewriteRule directive is the real rewriting workhorse. The directive can occur more than once, with each instance defining a single rewrite rule. The order in which these rules are defined is important - this is the order in which they will be applied at run-time.&lt;/p&gt;

&lt;p&gt;Pattern is a perl compatible regular expression, which is applied to the current URL. Current&amp;rdquo; means the value of the URL when this rule is applied. This may not be the originally requested URL, which may already have matched a previous rule, and have been altered.&lt;/p&gt;

&lt;p&gt;Some hints on the syntax of regular expressions:&lt;/p&gt;

&lt;p&gt;Text:
  .           Any single character
  [chars]     Character class: Any character of the class &lt;code&gt;chars&#39;&#39;
  [^chars]    Character class: Not a character of the class&lt;/code&gt;chars&amp;rdquo;
  text1|text2 Alternative: text1 or text2&lt;/p&gt;

&lt;p&gt;Quantifiers:
  ?           0 or 1 occurrences of the preceding text
  *           0 or N occurrences of the preceding text (N &amp;gt; 0)
  +           1 or N occurrences of the preceding text (N &amp;gt; 1)&lt;/p&gt;

&lt;p&gt;Grouping:
  (text)      Grouping of text
              (used either to set the borders of an alternative as above, or
              to make backreferences, where the Nth group can
              be referred to on the RHS of a RewriteRule as $N)&lt;/p&gt;

&lt;p&gt;Anchors:
  ^           Start-of-line anchor
  $           End-of-line anchor&lt;/p&gt;

&lt;p&gt;Escaping:
  char       escape the given char
              (for instance, to specify the chars &amp;ldquo;.[]()&amp;rdquo; etc.)
For more information about regular expressions, have a look at the perl regular expression manpage (&amp;ldquo;perldoc perlre&amp;rdquo;). If you are interested in more detailed information about regular expressions and their variants (POSIX regex etc.) the following book is dedicated to this topic:&lt;/p&gt;

&lt;p&gt;Mastering Regular Expressions, 2nd Edition
Jeffrey E.F. Friedl
O&amp;rsquo;Reilly &amp;amp; Associates, Inc. 2002
ISBN 0-596-00289-0
In the rules, the NOT character  (&amp;lsquo;!&amp;rsquo;) is also available as a possible pattern prefix. This enables you to negate a pattern; to say, for instance: if the current URL does NOT match this pattern&amp;rdquo;. This can be used for exceptional cases, where it is easier to match the negative pattern, or as a last default rule.&lt;/p&gt;

&lt;p&gt;Note: When using the NOT character to negate a pattern, you cannot include grouped wildcard parts in that pattern. This is because, when the pattern does NOT match (ie, the negation matches), there are no contents for the groups. Thus, if negated patterns are used, you cannot use $N in the substitution string!&lt;/p&gt;

&lt;p&gt;The substitution of a rewrite rule is the string which is substituted for (or replaces) the original URL which Pattern matched. In addition to plain text, it can include&lt;/p&gt;

&lt;p&gt;back-references ($N) to the RewriteRule pattern
back-references (%N) to the last matched RewriteCond pattern
server-variables as in rule condition test-strings (%{VARNAME})
mapping-function calls (${mapname:key|default})
Back-references are identifiers of the form $N (N=0..9), which will be replaced by the contents of the Nth group of the matched Pattern. The server-variables are the same as for the TestString of a RewriteCond directive. The mapping-functions come from the RewriteMap directive and are explained there. These three types of variables are expanded in the order above.&lt;/p&gt;

&lt;p&gt;As already mentioned, all rewrite rules are applied to the Substitution (in the order in which they are defined in the config file). The URL is completely replaced by the Substitution and the rewriting process continues until all rules have been applied, or it is explicitly terminated by a flag.&lt;/p&gt;

&lt;p&gt;There is a special substitution string named &amp;lsquo;-&amp;rsquo; which means: NO substitution! This is useful in providing rewriting rules which only match URLs but do not substitute anything for them. It is commonly used in conjunction with the C (chain) flag, in order to apply more than one pattern before substitution occurs.&lt;/p&gt;

&lt;p&gt;Additionally you can set special flags for Substitution by appending [flags] as the third argument to the RewriteRule directive. Flags is a comma-separated list of any of the following flags:&lt;/p&gt;

&lt;p&gt;&amp;lsquo;chain|C&amp;rsquo; (chained with next rule)
This flag chains the current rule with the next rule (which itself can be chained with the following rule, and so on). This has the following effect: if a rule matches, then processing continues as usual - the flag has no effect. If the rule does not match, then all following chained rules are skipped. For instance, it can be used to remove the &lt;code&gt;.www&#39;&#39; part, inside a per-directory rule set, when you let an external redirect happen (where the&lt;/code&gt;.www&amp;rdquo; part should not occur!).
&amp;lsquo;cookie|CO=NAME:VAL:domain[:lifetime[:path]]&amp;rsquo; (set cookie)
This sets a cookie in the client&amp;rsquo;s browser. The cookie&amp;rsquo;s name is specified by NAME and the value is VAL. The domain field is the domain of the cookie, such as &amp;lsquo;.apache.org&amp;rsquo;, the optional lifetime is the lifetime of the cookie in minutes, and the optional path is the path of the cookie
&amp;lsquo;env|E=VAR:VAL&amp;rsquo; (set environment variable)
This forces an environment variable named VAR to be set to the value VAL, where VAL can contain regexp backreferences ($N and %N) which will be expanded. You can use this flag more than once, to set more than one variable. The variables can later be dereferenced in many situations, most commonly from within XSSI (via &amp;lt;!&amp;ndash;#echo var=&amp;ldquo;VAR&amp;rdquo;&amp;ndash;&amp;gt;) or CGI ($ENV{&amp;lsquo;VAR&amp;rsquo;}). You can also dereference the variable in a later RewriteCond pattern, using %{ENV:VAR}. Use this to strip information from URLs, while maintaining a record of that information.
&amp;lsquo;forbidden|F&amp;rsquo; (force URL to be forbidden)
This forces the current URL to be forbidden - it immediately sends back a HTTP response of 403 (FORBIDDEN). Use this flag in conjunction with appropriate RewriteConds to conditionally block some URLs.
&amp;lsquo;gone|G&amp;rsquo; (force URL to be gone)
This forces the current URL to be gone - it immediately sends back a HTTP response of 410 (GONE). Use this flag to mark pages which no longer exist as gone.
&amp;lsquo;host|H=Host&amp;rsquo; (apply rewriting to host)
Rather that rewrite the URL, the virtual host will be rewritten.
&amp;lsquo;last|L&amp;rsquo; (last rule)
Stop the rewriting process here and don&amp;rsquo;t apply any more rewrite rules. This corresponds to the Perl last command or the break command in C. Use this flag to prevent the currently rewritten URL from being rewritten further by following rules. For example, use it to rewrite the root-path URL (&amp;lsquo;/&amp;rsquo;) to a real one, e.g., &amp;lsquo;/e/www/&amp;rsquo;.
&amp;lsquo;next|N&amp;rsquo; (next round)
Re-run the rewriting process (starting again with the first rewriting rule). This time, the URL to match is no longer the original URL, but rather the URL returned by the last rewriting rule. This corresponds to the Perl next command or the continue command in C. Use this flag to restart the rewriting process - to immediately go to the top of the loop.
Be careful not to create an infinite loop!
&amp;lsquo;nocase|NC&amp;rsquo; (no case)
This makes the Pattern case-insensitive, ignoring difference between &amp;lsquo;A-Z&amp;rsquo; and &amp;lsquo;a-z&amp;rsquo; when Pattern is matched against the current URL.
&amp;lsquo;noescape|NE&amp;rsquo; (no URI escaping of output)
This flag prevents the rewrite valve from applying the usual URI escaping rules to the result of a rewrite. Ordinarily, special characters (such as &amp;lsquo;%&amp;rsquo;, &amp;lsquo;$&amp;rsquo;, &amp;lsquo;;&amp;rsquo;, and so on) will be escaped into their hexcode equivalents (&amp;lsquo;%25&amp;rsquo;, &amp;lsquo;%24&amp;rsquo;, and &amp;lsquo;%3B&amp;rsquo;, respectively); this flag prevents this from happening. This allows percent symbols to appear in the output, as in RewriteRule /foo/(.*) /bar?arg=P1%3d$1 [R,NE] which would turn &amp;lsquo;/foo/zed&amp;rsquo; into a safe request for &amp;lsquo;/bar?arg=P1=zed&amp;rsquo;.
&amp;lsquo;qsappend|QSA&amp;rsquo; (query string append)
This flag forces the rewrite engine to append a query string part of the substitution string to the existing string, instead of replacing it. Use this when you want to add more data to the query string via a rewrite rule.
&amp;lsquo;redirect|R [=code]&amp;rsquo; (force redirect)
Prefix Substitution with &lt;a href=&#34;http://thishost[:thisport]/&#34;&gt;http://thishost[:thisport]/&lt;/a&gt; (which makes the new URL a URI) to force a external redirection. If no code is given, a HTTP response of 302 (MOVED TEMPORARILY) will be returned. If you want to use other response codes in the range 300-400, simply specify the appropriate number or use one of the following symbolic names: temp (default), permanent, seeother. Use this for rules to canonicalize the URL and return it to the client - to translate &lt;code&gt;/~&#39;&#39; into&lt;/code&gt;/u/&amp;ldquo;, or to always append a slash to /u/user, etc.
Note: When you use this flag, make sure that the substitution field is a valid URL! Otherwise, you will be redirecting to an invalid location. Remember that this flag on its own will only prepend &lt;a href=&#34;http://thishost[:thisport]/&#34;&gt;http://thishost[:thisport]/&lt;/a&gt; to the URL, and rewriting will continue. Usually, you will want to stop rewriting at this point, and redirect immediately. To stop rewriting, you should add the &amp;lsquo;L&amp;rsquo; flag.
&amp;lsquo;skip|S=num&amp;rsquo; (skip next rule(s))
This flag forces the rewriting engine to skip the next num rules in sequence, if the current rule matches. Use this to make pseudo if-then-else constructs: The last rule of the then-clause becomes skip=N, where N is the number of rules in the else-clause. (This is not the same as the &amp;lsquo;chain|C&amp;rsquo; flag!)
&amp;lsquo;type|T=MIME-type&amp;rsquo; (force MIME type)
Force the MIME-type of the target file to be MIME-type. This can be used to set up the content-type based on some conditions. For example, the following snippet allows .php files to be displayed by mod_php if they are called with the .phps extension: RewriteRule ^(.+.php)s$ $1 [T=application/x-httpd-php-source]&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&#34;http://www.jboss.org/file-access/default/members/jbossweb/freezone/modules/rewrite/index.html&#34; target=&#34;_blank&#34;&gt;http://www.jboss.org/file-access/default/members/jbossweb/freezone/modules/rewrite/index.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>MySQL Query Cache</title>
      <link>http://blog.prosight.me/blogs/618</link>
      <pubDate>2010-07-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;顾名思义，MySQL Query Cache 就是用来缓存和 Query 相关的数据的。具体来说，Query Cache 缓存了我们客户端提交给 MySQL 的 SELECT 语句以及该语句的结果集。大概来讲，就是将 SELECT 语句和语句的结果做了一个 HASH 映射关系然后保存在一定的内存区域中。&lt;/p&gt;

&lt;p&gt;在大部分的 MySQL 分发版本中，Query Cache 功能默认都是打开的，我们可以通过调整 MySQL Server 的参数选项打开该功能。主要由以下5个参数构成：&lt;/p&gt;

&lt;p&gt;query_cache_limit：允许 Cache 的单条 Query 结果集的最大容量，默认是1MB，超过此参数设置的 Query 结果集将不会被 Cache
query_cache_min_res_unit：设置 Query Cache 中每次分配内存的最小空间大小，也就是每个 Query 的 Cache 最小占用的内存空间大小
query_cache_size：设置 Query Cache 所使用的内存大小，默认值为0，大小必须是1024的整数倍，如果不是整数倍，MySQL 会自动调整降低最小量以达到1024的倍数
query_cache_type：控制 Query Cache 功能的开关，可以设置为0(OFF),1(ON)和2(DEMAND)三种，意义分别如下：
0(OFF)：关闭 Query Cache 功能，任何情况下都不会使用 Query Cache
1(ON)：开启 Query Cache 功能，但是当 SELECT 语句中使用的 SQL_NO_CACHE 提示后，将不使用Query Cache
2(DEMAND)：开启 Query Cache 功能，但是只有当 SELECT 语句中使用了 SQL_CACHE 提示后，才使用 Query Cache
query_cache_wlock_invalidate：控制当有写锁定发生在表上的时刻是否先失效该表相关的 Query Cache，如果设置为 1(TRUE)，则在写锁定的同时将失效该表相关的所有 Query Cache，如果设置为0(FALSE)则在锁定时刻仍然允许读取该表相关的 Query Cache。
Query Cache 如何处理子查询的？
这是我遇到的最为常见的一个问题。其实 Query Cache 是以客户端请求提交的 Query 为对象来处理的，只要客户端请求的是一个 Query，无论这个 Query 是一个简单的单表查询还是多表 Join，亦或者是带有子查询的复杂 SQL，都被当作成一个 Query，不会被分拆成多个 Query 来进行 Cache。所以，存在子查询的复杂 Query 也只会产生一个Cache对象，子查询不会产生单独的Cache内容。UNION[ALL] 类型的语句也同样如此。&lt;/p&gt;

&lt;p&gt;Query Cache 是以 block 的方式存储的数据块吗？
不是，Query Cache 中缓存的内容仅仅只包含该 Query 所需要的结果数据，是结果集。当然，并不仅仅只是结果数据，还包含与该结果相关的其他信息，比如产生该 Cache 的客户端连接的字符集，数据的字符集，客户端连接的 Default Database等。&lt;/p&gt;

&lt;p&gt;Query Cache 为什么效率会非常高，即使所有数据都可以 Cache 进内存的情况下，有些时候也不如使用 Query Cache 的效率高？
Query Cache 的查找，是在 MySQL 接受到客户端请求后在对 Query 进行权限验证之后，SQL 解析之前。也就是说，当 MySQL 接受到客户端的SQL后，仅仅只需要对其进行相应的权限验证后就会通过 Query Cache 来查找结果，甚至都不需要经过 Optimizer 模块进行执行计划的分析优化，更不许要发生任何存储引擎的交互，减少了大量的磁盘 IO 和 CPU 运算，所以效率非常高。&lt;/p&gt;

&lt;p&gt;客户端提交的 SQL 语句大小写对 Query Cache 有影响吗？
有，由于 Query Cache 在内存中是以 HASH 结构来进行映射，HASH 算法基础就是组成 SQL 语句的字符，所以必须要整个 SQL 语句在字符级别完全一致，才能在 Query Cache 中命中，即使多一个空格也不行。&lt;/p&gt;

&lt;p&gt;一个 SQL 语句在 Query Cache 中的内容，在什么情况下会失效？
为了保证 Query Cache 中的内容与是实际数据绝对一致，当表中的数据有任何变化，包括新增，修改，删除等，都会使所有引用到该表的 SQL 的 Query Cache 失效。&lt;/p&gt;

&lt;p&gt;为什么我的系统在开启了 Query Cache 之后整体性能反而下降了？
当开启了 Query Cache 之后，尤其是当我们的 query_cache_type 参数设置为 1 以后，MySQL 会对每个 SELECT 语句都进行 Query Cache 查找，查找操作虽然比较简单，但仍然也是要消耗一些 CPU 运算资源的。而由于 Query Cache 的失效机制的特性，可能由于表上的数据变化比较频繁，大量的 Query Cache 频繁的被失效，所以 Query Cache 的命中率就可能比较低下。所以有些场景下，Query Cache 不仅不能提高效率，反而可能造成负面影响。&lt;/p&gt;

&lt;p&gt;如何确认一个系统的 Query Cache 的运行是否健康，命中率如何，设置量是否足够？
MySQL 提供了一系列的 Global Status 来记录 Query Cache 的当前状态，具体如下：&lt;/p&gt;

&lt;p&gt;Qcache_free_blocks：目前还处于空闲状态的 Query Cache 中内存 Block 数目
Qcache_free_memory：目前还处于空闲状态的 Query Cache 内存总量
Qcache_hits：Query Cache 命中次数
Qcache_inserts：向 Query Cache 中插入新的 Query Cache 的次数，也就是没有命中的次数
Qcache_lowmem_prunes：当 Query Cache 内存容量不够，需要从中删除老的 Query Cache 以给新的 Cache 对象使用的次数
Qcache_not_cached：没有被 Cache 的 SQL 数，包括无法被 Cache 的 SQL 以及由于 query_cache_type 设置的不会被 Cache 的 SQL
Qcache_queries_in_cache：目前在 Query Cache 中的 SQL 数量
Qcache_total_blocks：Query Cache 中总的 Block 数量
可以根据这几个状态计算出 Cache 命中率，计算出 Query Cache 大小设置是否足够，总的来说，我个人不建议将 Query Cache 的大小设置超过256MB，这也是业界比较常用的做法。&lt;/p&gt;

&lt;p&gt;MySQL Cluster 是否可以使用 Query Cache？
其实在我们的生产环境中也没有使用 MySQL Cluster，所以我也没有在 MySQL Cluster 环境中使用 Query Cache 的实际经验，只是 MySQL 文档中说明确实可以在 MySQL Cluster 中使用 Query Cache。从 MySQL Cluster 的原理来分析，也觉得应该可以使用，毕竟 SQL 节点和数据节点比较独立，各司其职，只是 Cache 的失效机制会要稍微复杂一点。&lt;/p&gt;

&lt;p&gt;引自:http://www.javaeye.com/news/16744-mysql-query-cache-summary&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone 3GS升级iOS4.0并越狱</title>
      <link>http://blog.prosight.me/blogs/616</link>
      <pubDate>2010-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;手上有一部港行的iPhone 3GS，虽然是41周前的，但是因为之前用了Spirit,所以无法直接使用自制固件了。&lt;/p&gt;

&lt;p&gt;今天发现一个Cydia上的软件，可以解决这个问题。&lt;/p&gt;

&lt;p&gt;前提就是您必须在iPhone 3GS的（旧的bootrom）和Spirit 越狱3.1.3&lt;/p&gt;

&lt;p&gt;*打开cydia，并添加源 - &amp;gt; &lt;a href=&#34;http://repo.woowiz.net&#34;&gt;http://repo.woowiz.net&lt;/a&gt;
*现在搜索 - &amp;gt; Spirit2Pwn。
*安装Spirit2Pwn和重新启动设备。
&lt;img alt=&#34;&#34; src=&#34;http://images.weiphone.com/attachments/Day_100703/156_38868_d5af6234a1b1653.jpg&#34; title=&#34;Spirtit2Pwn&#34; class=&#34;alignnone&#34; width=&#34;208&#34; height=&#34;308&#34; /&gt;&lt;/p&gt;

&lt;p&gt;现在，Spirits越狱的机器可以接受任何自制4.0固件了.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何使用SHA1或者MD5校验文件完整性</title>
      <link>http://blog.prosight.me/blogs/614</link>
      <pubDate>2010-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候当你下载了一个大的文件，但是不知道这个文件是否完整的时候，可以使用提供下载者公布的md5或者sha1码来校验你所下载的文件是否跟下载提供着提供的文件完全一致。&lt;/p&gt;

&lt;p&gt;如果你使用的是Mac OSX,UNIX或者Linux，可以使用以下命令来做这个工作：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
 /usr/bin/openssl sha1 [full path to file]
 /usr/bin/openssl md5 [full path to file]
&lt;/pre&gt;

&lt;p&gt;第一条命令是使用sha1来校验文件，第二条是使用md5来校验。 校验后会得到类似于如下的结果：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
 /usr/bin/openssl md5 sample.iso
MD5(sample.iso)= 3be75df53e0cfb3905af0b4f4471c9f3
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;等号后面的就是对应的MD5的值，你可以跟下载提供着公布的MD5值进行比对，如果完全一致，那么恭喜你，你所下载的文件跟下载提供者的文件一模一样。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何配置iAd</title>
      <link>http://blog.prosight.me/blogs/612</link>
      <pubDate>2010-06-29 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;导入iAd.framework
2.选择要定制iAd的TabViewController.h ， 添加代码&lt;/li&gt;
&lt;/ol&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &lt;UIKit/UIKit.h&gt;
#import &lt;iAd/ADBannerView.h&gt;
@interface TabViewController : UIViewController&lt;ADBannerViewDelegate&gt; {
    ADBannerView *adView;
    UILabel *adStatus;  
}
- (void)bannerViewDidLoadAd:(ADBannerView *)banner;
- (BOOL)bannerViewActionShouldBegin:(ADBannerView *)banner willLeaveApplication:(BOOL)willLeave;
- (void)bannerViewActionDidFinish:(ADBannerView *)banner;
- (void)bannerView:(ADBannerView *) didFailToReceiveAdWithError:(NSError *)error;
- (void)adAvailabilityDidChange;
@property (nonatomic, retain) ADBannerView *adView;
@property (nonatomic, retain) UILabel *adStatus;
@end
&lt;/pre&gt;

&lt;p&gt;3.对应的TabViewController.m
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &amp;ldquo;TabViewController.h&amp;rdquo;
@implementation TabViewController
@synthesize adStatus;
@synthesize adView;
// Implement viewDidLoad to do additional setup after loading the view, typically from a nib.
- (void)viewDidLoad {
    [super viewDidLoad];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;adView = [[ADBannerView alloc] initWithFrame:CGRectMake(0, 250, 320, 50)];
self.adView.delegate = self;
self.adView.backgroundColor = [UIColor whiteColor];
[self.view addSubview:adView];

adStatus = [[UILabel alloc] initWithFrame:CGRectMake(10, 20, 200, 30)];
[self.view addSubview:adStatus];

NSLog(@&amp;quot;Trying to change the ad status&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
- (void)adAvailabilityDidChange {
    NSLog(@&amp;rdquo;[iAd]: Ads are available! Let&amp;rsquo;s display one!&amp;ldquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//    if([ADManager sharedAdManager].canPresentModalAd == YES)
//        [[ADManager sharedAdManager] presentModalAdFromViewController:self];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
- (void)cancelBannerViewAction {
    NSLog(@&amp;ldquo;Banner was cancelled!&amp;rdquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.adStatus.text = @&amp;quot;[iAd]: Bannes was closed.&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
- (void)bannerViewDidLoadAd:(ADBannerView *)banner {
    NSLog(@&amp;rdquo;[iAd]: Ad did load.&amp;ldquo;);
    self.adStatus.text = @&amp;rdquo;[iAd]: Ad did load.&amp;ldquo;;
}
- (BOOL)bannerViewActionShouldBegin:(ADBannerView *)banner willLeaveApplication:(BOOL)willLeave {
    NSLog(@&amp;rdquo;[iAd]: An action was started from the banner. Application will quit: %d&amp;rdquo;, willLeave);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.adStatus.text = @&amp;quot;[iAd]: An action was started from the banner. Application will quit: %d&amp;quot;, willLeave;

return YES;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
- (void)bannerViewActionDidFinish:(ADBannerView *)banner {
    NSLog(@&amp;rdquo;[iAd]: Action finished.&amp;ldquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.adStatus.text = @&amp;quot;[iAd]: Action finished.&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
- (void)bannerView:(ADBannerView *) didFailToReceiveAdWithError:(NSError *)error {
    NSLog(@&amp;rdquo;[iAd]: Faild to load the banner: %@&amp;ldquo;, error);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;self.adStatus.text = @&amp;quot;[iAd]: Faild to load the banner: %@&amp;quot;, error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
- (void)didReceiveMemoryWarning {
    // Releases the view if it doesn&amp;rsquo;t have a superview.
    [super didReceiveMemoryWarning];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// Release any cached data, images, etc that aren&#39;t in use.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
- (void)viewDidUnload {
    // Release any retained subviews of the main view.
    // e.g. self.myOutlet = nil;
}
- (void)dealloc {
    [super dealloc];
}
@end
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>理解iPhone项目的BaseSDK和DeploymentTarget含义</title>
      <link>http://blog.prosight.me/blogs/610</link>
      <pubDate>2010-06-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;iPhone OS的版本众多，很多用户由于各种各样的原因没有升级到最新版，这就给我们开发者带了麻烦。作为开发者，我们都希望软件的受众越多越好。怎么样让软件尽量适应最多的iPhone OS？这里我们就应该了解iPhone项目的Base SDK和iPhone OS Deployment Target。&lt;/p&gt;

&lt;p&gt;Base SDK指的是当前编译用的SDK版本。iPhone OS Deployment Target指的是编译出的程序将在哪个系统版本上运行。&lt;/p&gt;

&lt;p&gt;用更简单实用的语句描述如下：&lt;/p&gt;

&lt;p&gt;Base SDK设置为当前xcode所支持的最高的sdk版本，比如&amp;rdquo;iphone Device 4.0&amp;rdquo;。iPhone OS Deployment Target设置为你所支持的最低的iPhone OS版本，比如&amp;rdquo;iPhone OS 3.0&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;这样设置之后，你的程序就可以运行于从iPhone OS 3.0 到 4.0的设备之上。当然，前提是，你没有用到4.0新加的API。&lt;/p&gt;

&lt;p&gt;那么如果需要使用到新的API怎么办呢？请参考官方Sample MailComposer &lt;a href=&#34;http://developer.apple.com/iphone/library/samplecode/MailComposer/index.html&#34; target=&#34;_blank&#34;&gt;http://developer.apple.com/iphone/library/samplecode/MailComposer/index.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;转载自http://www.cnblogs.com/vinceoniphone/archive/&lt;sup&gt;2010&lt;/sup&gt;&amp;frasl;&lt;sub&gt;06&lt;/sub&gt;/&lt;sup&gt;13&lt;/sup&gt;&amp;frasl;&lt;sub&gt;1757743&lt;/sub&gt;.html&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Tomcat 设计模式分析</title>
      <link>http://blog.prosight.me/blogs/605</link>
      <pubDate>2010-05-29 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;门面设计模式&lt;/h2&gt;

&lt;p&gt;门面设计模式在 Tomcat 中有多处使用，在 Request 和 Response 对象封装中、Standard Wrapper 到 ServletConfig 封装中、ApplicationContext 到 ServletContext 封装中等都用到了这种设计模式。&lt;/p&gt;

&lt;p&gt;门面设计模式的原理
这么多场合都用到了这种设计模式，那这种设计模式究竟能有什么作用呢？顾名思义，就是将一个东西封装成一个门面好与人家更容易进行交流，就像一个国家的外交部一样。
这种设计模式主要用在一个大的系统中有多个子系统组成时，这多个子系统肯定要涉及到相互通信，但是每个子系统又不能将自己的内部数据过多的暴露给其它系统，不然就没有必要划分子系统了。每个子系统都会设计一个门面，把别的系统感兴趣的数据封装起来，通过这个门面来进行访问。这就是门面设计模式存在的意义。&lt;/p&gt;

&lt;p&gt;门面设计模式示意图如下：&lt;/p&gt;

&lt;p&gt;图 1. 门面示意图
 &lt;img alt=&#34;门面模式&#34; src=&#34;http://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/image001.jpg&#34; title=&#34;门面模式&#34; class=&#34;alignnone&#34; width=&#34;365&#34; height=&#34;213&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Client 只能访问到 Façade 中提供的数据是门面设计模式的关键，至于 Client 如何访问 Façade 和 Subsystem 如何提供 Façade 门面设计模式并没有规定死。
Tomcat 的门面设计模式示例
Tomcat 中门面设计模式使用的很多，因为 Tomcat 中有很多不同组件，每个组件要相互交互数据，用门面模式隔离数据是个很好的方法。
下面是 Request 上使用的门面设计模式：&lt;/p&gt;

&lt;p&gt;图 2. Request 的门面设计模式类图
&lt;img alt=&#34;Request的门面设计模式类图&#34; src=&#34;http://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/image002.png&#34; title=&#34;Request的门面设计模式类图&#34; class=&#34;alignnone&#34; width=&#34;572&#34; height=&#34;497&#34; /&gt;&lt;/p&gt;

&lt;p&gt;从图中可以看出 HttpRequestFacade 类封装了 HttpRequest 接口能够提供数据，通过 HttpRequestFacade 访问到的数据都被代理到 HttpRequest 中，通常被封装的对象都被设为 Private 或者 Protected 访问修饰，以防止在 Façade 中被直接访问。&lt;/p&gt;

&lt;h2&gt;观察者设计模式&lt;/h2&gt;

&lt;p&gt;这种设计模式也是常用的设计方法通常也叫发布 - 订阅模式，也就是事件监听机制，通常在某个事件发生的前后会触发一些操作。&lt;/p&gt;

&lt;p&gt;观察者模式的原理
观察者模式原理也很简单，就是你在做事的时候旁边总有一个人在盯着你，当你做的事情是它感兴趣的时候，它就会跟着做另外一些事情。但是盯着你的人必须要到你那去登记，不然你无法通知它。观察者模式通常包含下面这几个角色：
Subject 就是抽象主题：它负责管理所有观察者的引用，同时定义主要的事件操作。
ConcreteSubject 具体主题：它实现了抽象主题的所有定义的接口，当自己发生变化时，会通知所有观察者。
Observer 观察者：监听主题发生变化相应的操作接口。
Tomcat 的观察者模式示例
Tomcat 中观察者模式也有多处使用，前面讲的控制组件生命周期的 Lifecycle 就是这种模式的体现，还有对 Servlet 实例的创建、Session 的管理、Container 等都是同样的原理。下面主要看一下 Lifecycle 的具体实现。&lt;/p&gt;

&lt;p&gt;Lifecycle 的观察者模式结构图：&lt;/p&gt;

&lt;p&gt;图 3. Lifecycle 的观察者模式结构图
&lt;img alt=&#34;Lifecycel的观察者模式结构图&#34; src=&#34;http://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/image003.png&#34; title=&#34;Lifecycel的观察者模式结构图&#34; class=&#34;alignnone&#34; width=&#34;531&#34; height=&#34;506&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上面的结构图中，LifecycleListener 代表的是抽象观察者，它定义一个 lifecycleEvent 方法，这个方法就是当主题变化时要执行的方法。 ServerLifecycleListener 代表的是具体的观察者，它实现了 LifecycleListener 接口的方法，就是这个具体的观察者具体的实现方式。Lifecycle 接口代表的是抽象主题，它定义了管理观察者的方法和它要所做的其它方法。而 StandardServer 代表的是具体主题，它实现了抽象主题的所有方法。这里 Tomcat 对观察者做了扩展，增加了另外两个类：LifecycleSupport、LifecycleEvent，它们作为辅助类扩展了观察者的功能。LifecycleEvent 使得可以定义事件类别，不同的事件可区别处理，更加灵活。LifecycleSupport 类代理了主题对多观察者的管理，将这个管理抽出来统一实现，以后如果修改只要修改 LifecycleSupport 类就可以了，不需要去修改所有具体主题，因为所有具体主题的对观察者的操作都被代理给 LifecycleSupport 类了。这可以认为是观察者模式的改进版。
LifecycleSupport 调用观察者的方法代码如下：&lt;/p&gt;

&lt;p&gt;清单 1. LifecycleSupport 中的 fireLifecycleEvent 方法
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;br /&gt;
public void fireLifecycleEvent(String type, Object data) {
    LifecycleEvent event = new LifecycleEvent(lifecycle, type, data);
    LifecycleListener interested[] = null;
    synchronized (listeners) {
        interested = (LifecycleListener[]) listeners.clone();
    }
    for (int i = 0; i &amp;lt; interested.length; i++)
        interested[i].lifecycleEvent(event);
}
&lt;/pre&gt;
主题是怎么通知观察者呢？看下面代码：&lt;/p&gt;

&lt;p&gt;清单 2. 容器中的 start 方法
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;br /&gt;
public void start() throws LifecycleException {
    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);
    lifecycle.fireLifecycleEvent(START_EVENT, null);
    started = true;
    synchronized (services) {
        for (int i = 0; i &amp;lt; services.length; i++) {
            if (services[i] instanceof Lifecycle)
                ((Lifecycle) services[i]).start();
            }
        }
    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);
}
&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;命令设计模式&lt;/h2&gt;

&lt;p&gt;前面把 Tomcat 中两个核心组件 Connector 和 Container，比作一对夫妻。男的将接受过来的请求以命令的方式交给女主人。对应到 Connector 和 Container，Connector 也是通过命令模式调用 Container 的。&lt;/p&gt;

&lt;p&gt;命令模式的原理
命令模式主要作用就是封装命令，把发出命令的责任和执行命令的责任分开。也是一种功能的分工。不同的模块可以对同一个命令做出不同解释。
下面是命令模式通常包含下面几个角色：
Client：创建一个命令，并决定接受者
Command 命令：命令接口定义一个抽象方法
ConcreteCommand：具体命令，负责调用接受者的相应操作
Invoker 请求者：负责调用命令对象执行请求
Receiver 接受者：负责具体实施和执行一次请求
Tomcat 中的命令模式的示例
Tomcat 中命令模式在 Connector 和 Container 组件之间有体现，Tomcat 作为一个应用服务器，无疑会接受到很多请求，如何分配和执行这些请求是必须的功能。&lt;/p&gt;

&lt;p&gt;下面看一下 Tomcat 是如何实现命令模式的，下面是 Tomcat 命令模式的结构图：&lt;/p&gt;

&lt;p&gt;图 4. Tomcat 命令模式的结构图
&lt;img alt=&#34;Tomcat命令模式的结构图&#34; src=&#34;http://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/image004.png&#34; title=&#34;Tomcat命令模式的结构图&#34; class=&#34;alignnone&#34; width=&#34;572&#34; height=&#34;376&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Connector 作为抽象请求者，HttpConnector 作为具体请求者。HttpProcessor 作为命令。Container 作为命令的抽象接受者，ContainerBase 作为具体的接受者。客户端就是应用服务器 Server 组件了。Server 首先创建命令请求者 HttpConnector 对象，然后创建命令 HttpProcessor 命令对象。再把命令对象交给命令接受者 ContainerBase 容器来处理命令。命令的最终是被 Tomcat 的 Container 执行的。命令可以以队列的方式进来，Container 也可以以不同的方式来处理请求，如 HTTP1.0 协议和 HTTP1.1 的处理方式就会不同。&lt;/p&gt;

&lt;h2&gt;责任链模式&lt;/h2&gt;

&lt;p&gt;Tomcat 中一个最容易发现的设计模式就是责任链模式，这个设计模式也是 Tomcat 中 Container 设计的基础，整个容器的就是通过一个链连接在一起，这个链一直将请求正确的传递给最终处理请求的那个 Servlet。&lt;/p&gt;

&lt;p&gt;责任链模式的原理
责任链模式，就是很多对象有每个对象对其下家的引用而连接起来形成一条链，请求在这条链上传递，直到链上的某个对象处理此请求，或者每个对象都可以处理请求，并传给下一家，直到最终链上每个对象都处理完。这样可以不影响客户端而能够在链上增加任意的处理节点。
通常责任链模式包含下面几个角色：
Handler（抽象处理者）：定义一个处理请求的接口
ConcreteHandler（具体处理者）：处理请求的具体类，或者传给下家
Tomcat 中责任链模式示例
在 tomcat 中这种设计模式几乎被完整的使用，tomcat 的容器设置就是责任链模式，从 Engine 到 Host 再到 Context 一直到 Wrapper 都是通过一个链传递请求。&lt;/p&gt;

&lt;p&gt;Tomcat 中责任链模式的类结构图如下：&lt;/p&gt;

&lt;p&gt;图 5. Tomcat 责任链模式的结构图
 &lt;img alt=&#34;Tomcat责任链模式的结构图&#34; src=&#34;http://www.ibm.com/developerworks/cn/java/j-lo-tomcat2/image005.jpg&#34; title=&#34;Tomcat责任链模式的结构图&#34; class=&#34;alignnone&#34; width=&#34;512&#34; height=&#34;718&#34; /&gt;&lt;/p&gt;

&lt;p&gt;上图基本描述了四个子容器使用责任链模式的类结构图，对应的责任链模式的角色，Container 扮演抽象处理者角色，具体处理者由 StandardEngine 等子容器扮演。与标准的责任链不同的是，这里引入了 Pipeline 和 Valve 接口。他们有什么作用呢？
实际上 Pipeline 和 Valve 是扩展了这个链的功能，使得在链往下传递过程中，能够接受外界的干预。Pipeline 就是连接每个子容器的管子，里面传递的 Request 和 Response 对象好比管子里流的水，而 Valve 就是这个管子上开的一个个小口子，让你有机会能够接触到里面的水，做一些额外的事情。
为了防止水被引出来而不能流到下一个容器中，每一段管子最后总有一个节点保证它一定能流到下一个子容器，所以每个容器都有一个 StandardXXXValve。只要涉及到这种有链式是处理流程这是一个非常值得借鉴的模式。&lt;/p&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://www.ibm.com/developerworks/cn/&#34;&gt;developerWorks 中国&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>将你的Snow Leopard设置为64位</title>
      <link>http://blog.prosight.me/blogs/603</link>
      <pubDate>2010-03-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;很多人对Snow Leopard的64位还是一头雾水，下面我详细说一下。&lt;/p&gt;

&lt;p&gt;首先，默认情况下，Snow Leopard总是开启32位内核；如果你的CPU是Core 2或者Core i7（的话，系统会在运行程序时自动启动Universal Binary中的64位部分（这里的Universal是32位Intel和64位Intel的Universal，不是指PPC和Intel的），因为默认的32位内核可以运行64位程序。但是，如果你想从内核就变成完全的64位，那么需要你的Mac还具备一个条件，就是你的EFI必须是64位的。EFI是固件用户接口，这里指的是你的固件必须是64位的。&lt;/p&gt;

&lt;p&gt;EFI是否为64位的判别方法是：
打开终端，输入代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ioreg -l -p IODeviceTree | grep &amp;ldquo;firmware-abi&amp;rdquo; | sed -e &amp;rsquo;s/[^0-9A-Z]//g&amp;rsquo;
&lt;/pre&gt;
回车后，如果返回EFI64，则表示是64位的EFI，如果是EFI32则表明是32位的EFI……&lt;/p&gt;

&lt;p&gt;通过Mactracker搜索，得到的分界如下：
MacBook：由于苹果限制，MB均不可开启64位内核。
MacBook Pro：MA895/896/897（Mid 2007）及以前的机型是32位的EFI，之后的机型是64位。
iMac：MA876/877/878（Mid 2007）有一部分是32位的EFI，一部分是64位的EFI，在这之前的都是32位，之后都是64位。
Mac Pro：第一代4核和8核都是32位，以后的都是64位。
注意，以上统计信息不一定准确，如果你在自己的机器上发现与上述写法不符的，请及时提出，我将做出更正！
目前已知MA895（预装Tiger）也具备64位EFI，因此wikipedia所谓预装Tiger是32位EFI的言论已经不靠谱了……&lt;/p&gt;

&lt;p&gt;关于开启64位内核后的检查方法有四种：
1、进入“About This Mac”，点击“More Info”，在弹出的“System Profiler”中选择左边的“Software”，在右侧可以看到“64-bit kernel and extensions”，即可得知是否开启了64位内核。&lt;/p&gt;

&lt;p&gt;2、打开终端，输入“uname -m”即可查看内核构架：&lt;/p&gt;

&lt;p&gt;3、打开终端，输入&amp;rdquo;uname -v&amp;rdquo;即可查看内核发布信息：&lt;/p&gt;

&lt;p&gt;4、打开“活动监视器”，找到进程“kernel_tasks”（PID为0），查看它的构架，它就代表内核。&lt;/p&gt;

&lt;p&gt;最后说明开启64位的方法：
暂时性方法：
开机启动听到“咚”的一声马上按住“6&amp;rdquo;和”4&amp;rdquo;直到启动完成。建议先用这种方法查看开启64位内核是否有问题，我曾经在一台机器上面尝试开启64位后键盘失灵了。
永久性方法：
打开终端，拷贝下面的命令，回车运行：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo /Applications/TextEdit.app/Contents/MacOS/TextEdit /Library/Preferences/SystemConfiguration/com.apple.Boot.plist
&lt;/pre&gt;
在弹出的文本编辑器中，找到kernel_flag下面的&lt;string&gt;&lt;/string&gt;，并把它改写成&lt;string&gt;arch=x86_64&lt;/string&gt;.
也就是说，改好的文件应该是这个样子：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
    &amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&amp;gt;
    &amp;lt;!DOCTYPE plist PUBLIC &amp;ldquo;-//Apple Computer//DTD PLIST 1.0//EN&amp;rdquo; &amp;ldquo;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;rdquo;&amp;gt;
    &lt;plist version=&#34;1.0&#34;&gt;
        &lt;dict&gt;
                &lt;key&gt;Kernel&lt;/key&gt;
                &lt;string&gt;mach_kernel&lt;/string&gt;
                &lt;key&gt;Kernel Flags&lt;/key&gt;
                &lt;string&gt;arch=x86_64&lt;/string&gt;
        &lt;/dict&gt;
    &lt;/plist&gt;
&lt;/pre&gt;
改完之后保存退出就可以了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在XCode中编辑公司名称</title>
      <link>http://blog.prosight.me/blogs/596</link>
      <pubDate>2010-03-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用XCode开发Objective-C的应用的时候，XCode的模板会自动帮你在每个文件头部加入一段注释，里面包括了公司的名称。如：&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2010/03/1.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2010/03/1.png&#34; alt=&#34;&#34; title=&#34;Prosight&#34; width=&#34;358&#34; height=&#34;34&#34; class=&#34;alignnone size-full wp-image-598&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;之前只能通过命令行方式来更改，但是在XCode 3.2之后，可以直接在XCode中来更新这个信息。&lt;/p&gt;

&lt;p&gt;首选选择项目名称，然后右键点击，选择Get Info。&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://iphonedevelopertips.com/wp-content/uploads/2010/03/comp1.png&#34; title=&#34;Get Info.&#34; class=&#34;alignnone&#34; width=&#34;302&#34; height=&#34;212&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在General Settings标签中，在Organization Name字段中填入你的公司的名字。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2010/03/2.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2010/03/2.png&#34; alt=&#34;&#34; title=&#34;2&#34; width=&#34;352&#34; height=&#34;41&#34; class=&#34;alignnone size-full wp-image-600&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>利用CSS3实现文字内阴影效果</title>
      <link>http://blog.prosight.me/blogs/590</link>
      <pubDate>2010-03-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最终效果
&lt;img alt=&#34;&#34; src=&#34;http://images.sixrevisions.com/2010/03/22-04_firefox_inset_typography_screenshot.png&#34; title=&#34;最终效果&#34; class=&#34;alignnone&#34; width=&#34;550&#34; height=&#34;100&#34; /&gt;&lt;/p&gt;

&lt;p&gt;在没有CSS3之前，要做到这种文字效果只能借助于Photoshop之类的图片处理软件。 现在很多浏览器已经支持CSS3了（除了该死的IE）。下面将教您如何使用CSS3完成上述效果
Step 1: HTML标签&lt;/p&gt;

&lt;p&gt;下面是很简单的HTML标签，用以后面加上CSS特效
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;div id=&#34;insetBgd&#34;&gt;
    &lt;h1 class=&#34;insetType&#34;&gt;Inset Typography&lt;/h1&gt;
&lt;/div&gt;
&lt;/pre&gt;
Step 2: 背景&lt;/p&gt;

&lt;p&gt;我们想给文字加一个渐变的背景，从#003471 过渡到 #448CCB.
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#insetBgd {
 width: 550px;
 height: 100px;
 background: -moz-linear-gradient(-90deg, #003471, #448CCB);
 background: -webkit-gradient(linear, left top, left bottom, from(#003471), to(#448CCB));
}
&lt;/pre&gt;
&lt;img alt=&#34;&#34; src=&#34;http://images.sixrevisions.com/2010/03/22-02_css_background.jpg&#34; title=&#34;文字背景&#34; class=&#34;alignnone&#34; width=&#34;550&#34; height=&#34;100&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Step 3: 定义文字的样式&lt;/p&gt;

&lt;p&gt;首先定义文字的字体，大小和颜色。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
h1.insetType {
  font-family: Rockwell, Georgia, &amp;ldquo;Times New Roman&amp;rdquo;, Times, serif;
  font-size: 50px;
  color: #0D4383;
}
&lt;/pre&gt;
Step 4: 实现内阴影效果&lt;/p&gt;

&lt;p&gt;这是最关键的一步，也是最后一步。用来实现类似于photoshop的“inner shadow”效果。但是CSS的text-shadow并没有这个效果，我们不得不使用多个黑色和白色的阴影来实现这个效果：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
  text-shadow: rgba(0,0,0,0.5) -1px 0, rgba(0,0,0,0.3) 0 -1px, rgba(255,255,255,0.5) 0 1px, rgba(0,0,0,0.3) -1px -2px;
&lt;/pre&gt;
下面是完整代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#insetBgd {
  width: 550px;
  height: 100px;
  background: -moz-linear-gradient(-90deg,#003471,#448CCB);
  background: -webkit-gradient(linear, left top, left bottom, from(#003471), to(#448CCB));
}&lt;/p&gt;

&lt;p&gt;h1.insetType {
  padding-left: 50px; /* The padding is just there to move the h1 element to the center of the div */
  padding-top: 17px;
  font-family: Rockwell, Georgia, &amp;ldquo;Times New Roman&amp;rdquo;, Times, serif;
  font-size: 50px;
  color: #0D4383;
  text-shadow: rgba(0,0,0,0.5) -1px 0, rgba(0,0,0,0.3) 0 -1px, rgba(255,255,255,0.5) 0 1px, rgba(0,0,0,0.3) -1px -2px;
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;最终效果
&lt;img alt=&#34;&#34; src=&#34;http://images.sixrevisions.com/2010/03/22-04_firefox_inset_typography_screenshot.png&#34; title=&#34;最终效果&#34; class=&#34;alignnone&#34; width=&#34;550&#34; height=&#34;100&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Ruby on Rails: RubyGem version error: rack(1.0.0 not ~&gt; 1.0.1) (RuntimeError)</title>
      <link>http://blog.prosight.me/blogs/588</link>
      <pubDate>2010-03-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;当你升级了rails后，有时候会出现rack版本跟rails版本不匹配的情况。 当你执行./script/generate命令的时候，会出现以下错误信息：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/Library/Ruby/Gems/1.8/gems/rails-2.3.5/lib/initializer.rb:271:in `require_frameworks&#39;: RubyGem version error: rack(1.0.0 not ~&gt; 1.0.1) (RuntimeError)
    from /Library/Ruby/Gems/1.8/gems/rails-2.3.5/lib/initializer.rb:134:in `process&#39;
    from /Library/Ruby/Gems/1.8/gems/rails-2.3.5/lib/initializer.rb:113:in `send&#39;
    from /Library/Ruby/Gems/1.8/gems/rails-2.3.5/lib/initializer.rb:113:in `run&#39;
    from /Volumes/Data/study/ruby/blog/config/environment.rb:9
    from /Library/Ruby/Site/1.8/rubygems/custom_require.rb:31:in `gem_original_require&#39;
    from /Library/Ruby/Site/1.8/rubygems/custom_require.rb:31:in `require&#39;
    from /Library/Ruby/Gems/1.8/gems/rails-2.3.5/lib/commands/generate.rb:1
    from /Library/Ruby/Site/1.8/rubygems/custom_require.rb:31:in `gem_original_require&#39;
    from /Library/Ruby/Site/1.8/rubygems/custom_require.rb:31:in `require&#39;
    from ./script/generate:3
&lt;/pre&gt;

&lt;p&gt;解决方案：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo gem uninstall rack&lt;/p&gt;

&lt;p&gt;Select gem to uninstall:
 1. rack-1.0.0
 2. rack-1.1.0
 3. All versions
&amp;gt; 1&lt;/p&gt;

&lt;p&gt;You have requested to uninstall the gem:
    rack-1.0.0
actionpack-2.3.5 depends on [rack (~&amp;gt; 1.0.0)]
actionpack-2.3.4 depends on [rack (~&amp;gt; 1.0.0)]
If you remove this gems, one or more dependencies will not be met.
Continue with Uninstall? [Yn]  y
Successfully uninstalled rack-1.0.0
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;然后再执行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo gem install -v=2.3.5 rails&lt;/p&gt;

&lt;p&gt;Successfully installed rack-1.0.1
1 gem installed
Installing ri documentation for rack-1.0.1&amp;hellip;
Installing RDoc documentation for rack-1.0.1&amp;hellip;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;问题解决&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何使用Objective-C解析HTML和XML</title>
      <link>http://blog.prosight.me/blogs/586</link>
      <pubDate>2010-02-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用Objective-C解析HTML或者XML，系统自带有两种方式一个是通过libxml，一个是通过NSXMLParser。不过这两种方式都需要自己写很多编码来处理抓取下来的内容，而且不是很直观。&lt;/p&gt;

&lt;p&gt;有一个比较好的类库&lt;a href=&#34;http://github.com/topfunky/hpple&#34; target=&#34;_blank&#34;&gt;hpple&lt;/a&gt;，它是一个轻量级的包装框架，可以很好的解决这个问题。它是用XPath来定位和解析HTML或者XML。&lt;/p&gt;

&lt;p&gt;安装步骤：
-加入 libxml2 到你的项目中
Menu Project-&amp;gt;Edit Project Settings
搜索 &amp;ldquo;Header Search Paths&amp;rdquo;
添加新的 search path &amp;ldquo;${SDKROOT}/usr/include/libxml2&amp;rdquo;
Enable recursive option&lt;/p&gt;

&lt;p&gt;-加入 libxml2 library 到你的项目
Menu Project-&amp;gt;Edit Project Settings
搜索 &amp;ldquo;Other Linker Flags&amp;rdquo;
添加新的 search flag &amp;ldquo;-lxml2&amp;rdquo;&lt;/p&gt;

&lt;p&gt;-将下面hpple的源代码加入到你的项目中:
HTFpple.h
HTFpple.m
HTFppleElement.h
HTFppleElement.m
XPathQuery.h
XPathQuery.m&lt;/p&gt;

&lt;p&gt;-XPath学习地址&lt;a href=&#34;http://www.w3schools.com/XPath/default.asp&#34; target=&#34;_path&#34;&gt;http://www.w3schools.com/XPath/default.asp&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;示例代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &amp;ldquo;TFHpple.h&amp;rdquo;&lt;/p&gt;

&lt;p&gt;NSData *data = [[NSData alloc] initWithContentsOfFile:@&amp;ldquo;example.html&amp;rdquo;];&lt;/p&gt;

&lt;p&gt;// Create parser
xpathParser = [[TFHpple alloc] initWithHTMLData:data];&lt;/p&gt;

&lt;p&gt;//Get all the cells of the 2nd row of the 3rd table
NSArray *elements  = [xpathParser search:@&amp;ldquo;//table[3]/tr[2]/td&amp;rdquo;];&lt;/p&gt;

&lt;p&gt;// Access the first cell
TFHppleElement *element = [elements objectAtIndex:0];&lt;/p&gt;

&lt;p&gt;// Get the text within the cell tag
NSString *content = [element content];&lt;/p&gt;

&lt;p&gt;[xpathParser release];
[data release];
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;另外，还有一个类似的解决方案可以参考
ElementParser &lt;a href=&#34;http://github.com/Objective3/ElementParser&#34; target=&#34;_blank&#34;&gt;http://github.com/Objective3/ElementParser&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何在iPhone图标上加提示符(badge)</title>
      <link>http://blog.prosight.me/blogs/584</link>
      <pubDate>2010-02-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果你使用Apple iPhone自带的Mail程序，你会注意到，当有新邮件的时候，在这个程序的图标(icon)上会显示对应的新邮件的数字。 如果你的应用程序也想有类似的功能，其实很简单：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)applicationDidFinishLaunching:(UIApplication *)application {
    //&amp;hellip;
    [application setApplicationIconBadgeNumber:123];
}
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>将Array、Dictionary等集合类的序列化和反序列化</title>
      <link>http://blog.prosight.me/blogs/582</link>
      <pubDate>2010-02-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Objective-C的集合类序列化到文件中或者从文件中反序列化其实很简单，请看下面的示例代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSArray *array = [NSArray arrayWithObjects:
    @&amp;ldquo;Hefeweizen&amp;rdquo;, @&amp;ldquo;IPA&amp;rdquo;, @&amp;ldquo;Pilsner&amp;rdquo;, @&amp;ldquo;Stout&amp;rdquo;, nil];&lt;/p&gt;

&lt;p&gt;NSDictionary *dictionary = [NSDictionary dictionaryWithObjectsAndKeys:
  array, @&amp;ldquo;array&amp;rdquo;, @&amp;ldquo;Stout&amp;rdquo;, @&amp;ldquo;dark&amp;rdquo;, @&amp;ldquo;Hefeweizen&amp;rdquo;, @&amp;ldquo;wheat&amp;rdquo;, @&amp;ldquo;IPA&amp;rdquo;,
  @&amp;ldquo;hoppy&amp;rdquo;, nil];&lt;/p&gt;

&lt;p&gt;// 得到documents directory的路径
NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,
  NSUserDomainMask, YES);
if ([paths count] &amp;gt; 0)
{
  // Array的保存路径
  NSString  *arrayPath = [[paths objectAtIndex:0]
      stringByAppendingPathComponent:@&amp;ldquo;array.out&amp;rdquo;];&lt;/p&gt;

&lt;p&gt;// dictionary的保存路径
  NSString  *dictPath = [[paths objectAtIndex:0]
      stringByAppendingPathComponent:@&amp;ldquo;dict.out&amp;rdquo;];&lt;/p&gt;

&lt;p&gt;// 保存array
  [array writeToFile:arrayPath atomically:YES];&lt;/p&gt;

&lt;p&gt;// 保存dictionary
  [dictionary writeToFile:dictPath atomically:YES];&lt;/p&gt;

&lt;p&gt;// 从文件中读取回来
  NSArray *arrayFromFile = [NSArray arrayWithContentsOfFile:arrayPath];
  NSDictionary *dictFromFile = [NSDictionary dictionaryWithContentsOfFile:dictPath];&lt;/p&gt;

&lt;p&gt;for (NSString *element in arrayFromFile)
    NSLog(@&amp;ldquo;Beer: %@&amp;ldquo;, element);&lt;/p&gt;

&lt;p&gt;for (NSString *key in dictFromFile)
    NSLog(@&amp;ldquo;%@ Style: %@&amp;ldquo;, key, [dictionary valueForKey:key]);
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;输出如下：
&lt;img alt=&#34;&#34; src=&#34;http://iphonedevelopertips.com/wp-content/uploads/2010/02/screen.png&#34; title=&#34;output&#34; class=&#34;alignnone&#34; width=&#34;512&#34; height=&#34;227&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>创建没有按钮的UIAlertView</title>
      <link>http://blog.prosight.me/blogs/580</link>
      <pubDate>2010-02-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;默认的，UIAlertView都有一个或者多个按钮，如果你想创建没有按钮的UIAlertView，可以使用以下的方法：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
UIAlertView *alert;
 
...
 
alert = [[[UIAlertView alloc] initWithTitle:@&#34;Configuring PreferencesnPlease Wait...&#34; 
  message:nil delegate:self cancelButtonTitle:nil otherButtonTitles: nil] autorelease];
 
[alert show];
&lt;/pre&gt;
&lt;img alt=&#34;&#34; src=&#34;http://iphonedevelopertips.com/wp-content/uploads/2010/02/alert1-206x300.png&#34; title=&#34;UIAlertView&#34; class=&#34;alignnone&#34; width=&#34;206&#34; height=&#34;300&#34; /&gt;

上面的标题可能有些靠上，可以用过给标题增加回车的方式，使标题居中：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
UIAlertView *alert;
 
...

alert = [[[UIAlertView alloc] initWithTitle:@&#34;nnConfiguring PreferencesnPlease Wait...&#34; 
  message:nil delegate:self cancelButtonTitle:nil otherButtonTitles: nil] autorelease];
 
[alert show];
&lt;/pre&gt;
&lt;img alt=&#34;&#34; src=&#34;http://iphonedevelopertips.com/wp-content/uploads/2010/02/alert2-204x300.png&#34; title=&#34;UIAlertView&#34; class=&#34;alignnone&#34; width=&#34;204&#34; height=&#34;300&#34; /&gt;

如果你还想给UIAlertView添加一个等待提示符，则可以这么做：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
UIAlertView *alert;
 
...
 
alert = [[[UIAlertView alloc] initWithTitle:@&#34;Configuring PreferencesnPlease Wait...&#34; message:nil delegate:self cancelButtonTitle:nil otherButtonTitles: nil] autorelease];
[alert show];
 
UIActivityIndicatorView *indicator = [[UIActivityIndicatorView alloc] initWithActivityIndicatorStyle:UIActivityIndicatorViewStyleWhiteLarge];
 
// Adjust the indicator so it is up a few pixels from the bottom of the alert
indicator.center = CGPointMake(alert.bounds.size.width / 2, alert.bounds.size.height - 50);
[indicator startAnimating];
[alert addSubview:indicator];
[indicator release];
&lt;/pre&gt;
&lt;img alt=&#34;&#34; src=&#34;http://iphonedevelopertips.com/wp-content/uploads/2010/02/alert3-204x300.png&#34; title=&#34;UIAlertView&#34; class=&#34;alignnone&#34; width=&#34;204&#34; height=&#34;300&#34; /&gt;

解除UIAlertView的显示
因为这个AlertView没有按钮，所以就不能通过点击按钮将这个提示框去掉。可以通过程序的方式，将这个窗口关掉。
&lt;pre=&#34;objc&#34;&gt;
[alert dismissWithClickedButtonIndex:0 animated:YES];
&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>Three20中给TTPhotoViewController添加播放按钮</title>
      <link>http://blog.prosight.me/blogs/574</link>
      <pubDate>2010-02-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://github.com/facebook/three20&#34; target=&#34;_blank&#34;&gt;Three20&lt;/a&gt;是一个很不错的iPhone类库，是facebook共享出来的框架。利用TTThumbsViewController可以很容易的制作出类似flickr的应用,实现缩略图和图片查看功能。&lt;/p&gt;

&lt;p&gt;但是默认的TTThumbsViewController，点击一个图片的时候，下面的button只有上一个和下一个，并没有播放按钮。 之前以为Three20没有相应的播放功能。但是经过查看代码，发现在TTPhotoViewController中，其实有相关的方法，只是没有把播放按钮显示出来而已。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
UIBarButtonItem* playButton = [[[UIBarButtonItem alloc] initWithBarButtonSystemItem:
    UIBarButtonSystemItemPlay target:self action:@selector(playAction)] autorelease];
  playButton.tag = 1;
&lt;/pre&gt;

&lt;p&gt;通过修改TTPhotoViewController大致在400行左右，添加playButton这个变量
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
 _toolbar.items = [NSArray arrayWithObjects:
                   space, _previousButton, space, playButton, space, _nextButton, space, nil];
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这样重新编译后，就可以看到播放按钮了。&lt;/p&gt;

&lt;p&gt;Three20这个库其实还是很实用的，只是文档比较欠缺，没办法，只能直接看源码了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>给TableView加背景</title>
      <link>http://blog.prosight.me/blogs/572</link>
      <pubDate>2010-02-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;iPhone默认的表格背景很单调，你可以通过加背景图片的方式来给你的应用增添点亮点。可以通过以下方法来给表格添加背景。
你可以在你的delegate类里面添加如下代码：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
UIView *backgroundView = [[UIView alloc] initWithFrame: window.frame];
backgroundView.backgroundColor = [UIColor colorWithPatternImage:[UIImage imageNamed:@&#34;TableViewBackground.png&#34;]];
[window addSubview:backgroundView];
[backgroundView release];

yourTableViewController = [[ATableViewController alloc] initWithStyle:UITableViewStyleGrouped];
yourTableViewController.view.backgroundColor = [UIColor clearColor];
[window addSubview:yourTableViewController.view];

[window makeKeyAndVisible];
&lt;/pre&gt;

&lt;p&gt;ATableViewController是UITableViewController的一个子类
&lt;img alt=&#34;&#34; src=&#34;http://howtomakeiphoneapps.com/wp-content/uploads/2009/03/bg-noartifact1.png&#34; title=&#34;Background&#34; class=&#34;alignnone&#34; width=&#34;386&#34; height=&#34;742&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何使用MyFace快速构建基于JSF的应用</title>
      <link>http://blog.prosight.me/blogs/570</link>
      <pubDate>2010-02-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果大家使用Apache MyFace的JSF实现来搭建JSF应用，可以利用Apache提供的便捷maven方法来快速搭建一个初始的应用。&lt;/p&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;
mvn archetype:generate -DarchetypeCatalog=http://myfaces.apache.org
……
Choose archetype:
1: &lt;a href=&#34;http://myfaces.apache.org&#34;&gt;http://myfaces.apache.org&lt;/a&gt; -&amp;gt; myfaces-archetype-helloworld (Simple Web application using Apache Myfaces)
2: &lt;a href=&#34;http://myfaces.apache.org&#34;&gt;http://myfaces.apache.org&lt;/a&gt; -&amp;gt; myfaces-archetype-helloworld-facelets (Simple Web application using Apache Myfaces and Facelets)
3: &lt;a href=&#34;http://myfaces.apache.org&#34;&gt;http://myfaces.apache.org&lt;/a&gt; -&amp;gt; myfaces-archetype-helloworld-portlets (Simple Web application using Apache Myfaces and Portlets)
4: &lt;a href=&#34;http://myfaces.apache.org&#34;&gt;http://myfaces.apache.org&lt;/a&gt; -&amp;gt; myfaces-archetype-jsfcomponents (Simple JSF Component using Apache Myfaces)
5: &lt;a href=&#34;http://myfaces.apache.org&#34;&gt;http://myfaces.apache.org&lt;/a&gt; -&amp;gt; myfaces-archetype-trinidad (Simple Web application using Apache Myfaces and Trinidad)
Choose a number:  (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;/&lt;sup&gt;3&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt;/5):
……
&lt;/pre&gt;
可以看到它提供了你5个初始项目进行选择，你可以根据你的需要选择响应的选项。之后填写响应的参数后，你的应用程序框架就生成了。&lt;/p&gt;

&lt;p&gt;然后再使用以下命令，来下载必要的依赖包，假设你的groupId=myAppId，artifactId=yourapp
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd yourapp
mvn package
&lt;/pre&gt;
之后你就搭建了一个初始框架，你可以继续使用maven来操作这个框架。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>千万别study English，应学会learn Englis——英语学习方法强烈推荐</title>
      <link>http://blog.prosight.me/blogs/568</link>
      <pubDate>2010-01-29 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;l     开始第一阶段：“打通”耳朵，完全听清&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  要领：

  第一，   选择1盘（再次强调是1盘而非一套）适合自身英语水平的磁带；（磁带我选用的是李阳的疯狂英语，电驴有很多资源的，也可用新东方的或者BBC）

  第二，   每天集中精力把A面和B面连续听两遍

  第三，   要坚持天天听，但每隔6天要休息一天

  第四，   直到听清磁带中的所有内容
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2    完成第二阶段：听读并举，掌握语法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  要领：

  第一，   把已经能完全听清的磁带中的第1盘磁带再找出来。

  第二，   听写这盘磁带的内容。

  第三，   做听写练习时，一句一句地听。即：听完一句后，先按暂停，把刚才听到的写下来，反复听，直到完全听清这句为止。不会的单词根据发音大致拼写出来即可。

  第四，   听写完整盘磁带的所有内容后，用英英词典确认不会的单词拼写是否正确（知道其意当然好，不知道也不要紧）。

  第五，   按这种方法听写完整盘磁带的内容后，尽量模仿磁带的发音和语调，从头到尾大声朗读（不满意的部分要再听一遍磁带重新朗读）

  第六，   感觉到所有的句子都已经能朗朗上口以后，便结束这一阶段。

  第七，   整个过程中，每个星期要有1天与英语完全隔绝。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3    突破第三阶段：跃跃欲说，出口成章&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  要领：

  第一，   用英英词典查以前做听写练习不懂的单词。（英英词典，我使用的是《朗文当代英语辞典(第4版)(精装)》，因原来听新东方的视频，新东方老师推荐使用朗文的英英字典）

  第二，   把单词的解释和例句记下来，若这其中还有不懂的单词话，继续查单词。

  第三，   查词典要坚持查到没有不懂的单词为止。

  第四，   大约查1个小时后，暂停查词典，并大声朗读通过查词典整理出的内容。

  第五，   朗读约1个小时后结束。

  第六，   每周要隔1天。

  第七，   查在原文和单词解释中出现的所有不懂的单词、并一直朗读到完全吃透解释和例句为止。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4    征服第四阶段：自我领悟，无典自通&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  要领：

  第一，   准备1盘录像带。（我打算使用MIT的《算法导论》视频）

  第二，   带上耳机，每天看1遍。

  第三，   能够完全听清之后，便开始听写，朗读。

  第四，   将不清楚的单词，利用英英词典查找并朗读。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5    攀登第五阶段：文化融通，渐入佳境&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  要领：

  第一，   准备1张最近的英文原版报纸（在美国发行的报纸）。

  第二，   从社会版面挑选一篇短文章（1~2分钟就能念完的），然后大声朗读。必须坚持到完全消化为止，就好像自己成了新闻主持人一样。

  第三，   当确信自己不看原文也可以记住文章内容时，把它像讲一个故事一样绘声绘色地复述。

  第四，   能够流利地朗读，再选第二篇文章，重复上面所讲的方法。

  第五，   看完一个版面后，就像第三阶段那样处理不认识的单词。

  第六，   把报纸上广告、名人访谈、漫画等所有内容，都按上述方法加以学习。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;下面是书上关于这个英语学习的阐述与分析：
      1、分析第一阶段：打通耳朵，完全听清
      2、分析第二阶段：听读并举，掌握语法
      3、分析第三阶段：跃跃欲说，出口成章
      4、分析第四阶段：自我领悟，无典自通
      5、分析第五阶段：文化融通，渐入佳境&lt;/p&gt;
</description>
    </item>
    <item>
      <title>去掉iPhone应用图标上的弧形高光</title>
      <link>http://blog.prosight.me/blogs/566</link>
      <pubDate>2010-01-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候我们的应用程序不需要在图标上加上默认的高光，可以在你的应用的Info.plist中加入：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
UIPrerenderedIcon，让它等于YES即可
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>让你的iPhone应用的URL更加友好易记</title>
      <link>http://blog.prosight.me/blogs/562</link>
      <pubDate>2010-01-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在你的应用程序上线后，经常要做对外推广的工作，经常会把你的应用程序的url贴在各处。 默认的iTunes链接的样子如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;http://itunes.apple.com/us/app/china-charming-girl/id348850577?mt=8&lt;/pre&gt;
比较长，而且对搜索引擎不是很友好。 其实iTunes的url可以有很三种方式：&lt;/p&gt;

&lt;p&gt;公司名字
&lt;a href=&#34;http://itunes.com/apps/&#34;&gt;http://itunes.com/apps/&lt;/a&gt; (例如, &lt;a href=&#34;http://itunes.com/apps/prosight&#34;&gt;http://itunes.com/apps/prosight&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;应用程序名字
&lt;a href=&#34;http://itunes.com/apps/&#34;&gt;http://itunes.com/apps/&lt;/a&gt; (例如, &lt;a href=&#34;http://itunes.com/apps/crazyfart&#34;&gt;http://itunes.com/apps/crazyfart&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;应用程序名加公司名
&lt;a href=&#34;http://itunes.com/apps//&#34;&gt;http://itunes.com/apps//&lt;/a&gt; (例如, &lt;a href=&#34;http://itunes.com/apps/prosight/crazyfart&#34;&gt;http://itunes.com/apps/prosight/crazyfart&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;生成这个url有如下规则：
&lt;ul&gt;
    &lt;li&gt; 移除所有的空格&lt;/li&gt;
    &lt;li&gt; 移除所有的copyright (©), trademark (™) 和registered mark (®) 符号&lt;/li&gt;
    &lt;li&gt; 替换&amp;rdquo;&amp;amp;&amp;rdquo; 成 &amp;ldquo;and&amp;rdquo;&lt;/li&gt;
    &lt;li&gt; 移除所有非法字符（见下）&lt;/li&gt;
    &lt;li&gt;替换所有非英语字符(ü, å, etc.) 为英文字符 (u, a, etc.)&lt;/li&gt;
    &lt;li&gt; 保留所有其他的字符&lt;/li&gt;
&lt;/ul&gt;
非法字符：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;!¡&amp;rdquo;#$%&amp;lsquo;()*+,-./:;&amp;lt;=&amp;gt;¿?@[]^_{|}~&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>It appears the JSP version of the container is older than 2.1 and unable to locate the EL RI expression factory, com.sun.el.ExpressionFactoryImpl.  </title>
      <link>http://blog.prosight.me/blogs/560</link>
      <pubDate>2010-01-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天调试一个jboss应用的时候发现这个错误。&lt;/p&gt;

&lt;blockquote&gt;严重: Unable to instantiate ExpressionFactory &#39;com.sun.el.ExpressionFactoryImpl&#39; 
2008-9-12 11:36:47 org.apache.catalina.core.StandardContext listenerStart 
严重: Exception sending context initialized event to listener instance of class com.sun.faces.config.ConfigureListener 
com.sun.faces.config.ConfigurationException: It appears the JSP version of the container is older than 2.1 and unable to locate the EL RI expression factory, com.sun.el.ExpressionFactoryImpl.  If not using JSP or the EL RI, make sure the context initialization parameter, com.sun.faces.expressionFactory, is properly set. 
at com.sun.faces.config.ConfigureListener.registerELResolverAndListenerWithJsp(ConfigureListener.java:545) 
at com.sun.faces.config.ConfigureListener.contextInitialized(ConfigureListener.java:211) 
at org.apache.catalina.core.StandardContext.listenerStart(StandardContext.java:3692) 
at org.apache.catalina.core.StandardContext.start(StandardContext.java:4127) 
at org.apache.catalina.core.ContainerBase.addChildInternal(ContainerBase.java:759) 
at org.apache.catalina.core.ContainerBase.addChild(ContainerBase.java:739) 
at org.apache.catalina.core.StandardHost.addChild(StandardHost.java:524) 
at org.apache.catalina.startup.HostConfig.deployDescriptor(HostConfig.java:603) 
at org.apache.catalina.startup.HostConfig.deployDescriptors(HostConfig.java:535) 
at org.apache.catalina.startup.HostConfig.deployApps(HostConfig.java:470) 
at org.apache.catalina.startup.HostConfig.start(HostConfig.java:1118) 
at org.apache.catalina.startup.HostConfig.lifecycleEvent(HostConfig.java:310) 
at org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent(LifecycleSupport.java:119) 
at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1020) 
at org.apache.catalina.core.StandardHost.start(StandardHost.java:718) 
at org.apache.catalina.core.ContainerBase.start(ContainerBase.java:1012) 
at org.apache.catalina.core.StandardEngine.start(StandardEngine.java:442) 
at org.apache.catalina.core.StandardService.start(StandardService.java:450) 
at org.apache.catalina.core.StandardServer.start(StandardServer.java:680) 
at org.apache.catalina.startup.Catalina.start(Catalina.java:540) 
at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) 
at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:39) 
at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25) 
at java.lang.reflect.Method.invoke(Method.java:585) 
at org.apache.catalina.startup.Bootstrap.start(Bootstrap.java:271) 
at org.apache.catalina.startup.Bootstrap.main(Bootstrap.java:409) &lt;/blockquote&gt;

&lt;p&gt;看提示是说jsp的版本有问题，其实是缺少了一个jar包
el-ri.jar&lt;/p&gt;

&lt;p&gt;可以在这里下载：&lt;a href=&#34;http://code.google.com/p/seam-forum/downloads/detail?name=el-ri.jar&amp;can=2&amp;q=&#34; target&#34;_blank&#34;&gt;http://code.google.com/p/seam-forum/downloads/detail?name=el-ri.jar&amp;amp;can=2&amp;amp;q=&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;将这个包放在jbosshome/server/default/lib中&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在JBOSS服务器上使用Myfaces的JSF实现</title>
      <link>http://blog.prosight.me/blogs/558</link>
      <pubDate>2010-01-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;JBOSS AS服务器默认使用的JSF实现是SUN的RI，要把他替换成Myfaces需要：&lt;/p&gt;

&lt;p&gt;1.移除JBoss服务器的现有的JSF实现RI&lt;/p&gt;

&lt;p&gt;修改JBOSS_HOME下的server&amp;lt; config-name&amp;gt;deployjboss-web.deployerconfweb.xml文件，把JSF的监听器注掉，并删除jboss-web.deployer 目录下的jsf-libs文件夹
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&amp;lt;!&amp;ndash;
&lt;context-param&gt;
    &lt;param-name&gt;com.sun.faces.injectionProvider&lt;/param-name&gt;
    &lt;param-value&gt;org.jboss.web.jsf.integration.injection.JBossInjectionProvider&lt;/param-value&gt;
  &lt;/context-param&gt;
&amp;ndash;&amp;gt;
&amp;lt;!&amp;ndash; Comment/Remove this &amp;ndash;&amp;gt;&lt;br /&gt;
&amp;lt;!&amp;ndash; Configures JSF for a web application if the javax.faces.webapp.FacesServlet is declared &amp;ndash;&amp;gt;&lt;br /&gt;
&amp;lt;!&amp;ndash; in web.xml.                                                                             &amp;ndash;&amp;gt;&lt;br /&gt;
&amp;lt;!&amp;ndash;&lt;br /&gt;
&lt;listener&gt;&lt;br /&gt;
  &lt;listener-class&gt;org.jboss.web.jsf.integration.config.JBossJSFConfigureListener&lt;/listener-class&gt;&lt;br /&gt;
&lt;/listener&gt;&lt;br /&gt;
&amp;ndash;&amp;gt;&lt;br /&gt;
&amp;lt;!&amp;ndash; Comment/Remove this &amp;ndash;&amp;gt;&lt;br /&gt;
&amp;lt;!&amp;ndash; Listens to all web app lifecycle events so that @PreDestroy can be called on &amp;ndash;&amp;gt;&lt;br /&gt;
&amp;lt;!&amp;ndash; JSF managed beans that go out of scope.  You can comment this out if you     &amp;ndash;&amp;gt;&lt;br /&gt;
&amp;lt;!&amp;ndash; don&amp;rsquo;t use JSF or you don&amp;rsquo;t use annotations on your managed beans.            &amp;ndash;&amp;gt;&lt;br /&gt;
&amp;lt;!&amp;ndash;&lt;br /&gt;
&lt;listener&gt;&lt;br /&gt;
  &lt;listener-class&gt;com.sun.faces.application.WebappLifecycleListener&lt;/listener-class&gt;&lt;br /&gt;
&lt;/listener&gt;&lt;br /&gt;
&amp;ndash;&amp;gt;&lt;br /&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;2.安装Myfaces的JSF实现&lt;/p&gt;

&lt;p&gt;在jboss-web.deployer 目录下新建myfaces-libs文件夹，并把myfaces的实现jar包拷贝到里面
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
commons-beanutils.jar&lt;br /&gt;
commons-digester-1.6.jar&lt;br /&gt;
commons-el.jar&lt;br /&gt;
commons-lang-2.1.jar&lt;br /&gt;
myfaces-api.jar&lt;br /&gt;
myfaces-impl.jar
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在jboss-web.deployerconfweb.xml中添加myfaces的监听器
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;listener&gt;&lt;br /&gt;
  &lt;listener-class&gt;org.apache.myfaces.webapp.StartupServletContextListener&lt;/listener-class&gt;&lt;br /&gt;
&lt;/listener&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;3.修改jboss-web.deployerconfweb.xml中JSF相关的init-param参数，替换
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;init-param&gt;&lt;br /&gt;
  &lt;description&gt;JSF standard tlds&lt;/description&gt;&lt;br /&gt;
  &lt;param-name&gt;tagLibJar0&lt;/param-name&gt;&lt;br /&gt;
  &lt;param-value&gt;jsf-libs/jsf-impl.jar&lt;/param-value&gt;&lt;br /&gt;
&lt;/init-param&gt;&lt;br /&gt;
&lt;init-param&gt;&lt;br /&gt;
  &lt;description&gt;JSTL standard tlds&lt;/description&gt;&lt;br /&gt;
  &lt;param-name&gt;tagLibJar1&lt;/param-name&gt;&lt;br /&gt;
  &lt;param-value&gt;jstl.jar&lt;/param-value&gt;&lt;br /&gt;
&lt;/init-param&gt;
&lt;/pre&gt;
为
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;init-param&gt;&lt;br /&gt;
 &lt;description&gt;MyFaces tlds&lt;/description&gt;&lt;br /&gt;
 &lt;param-name&gt;tagLibJar0&lt;/param-name&gt;&lt;br /&gt;
 &lt;param-value&gt;myfaces-libs/myfaces-impl.jar&lt;/param-value&gt;&lt;br /&gt;
&lt;/init-param&gt;
&lt;/pre&gt;
现在启动JBOSS AS就可以看到加载的已经加载了Myfaces的JSF。可以在JBOSS服务器上使用Myfaces的JSF实现了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Oracle导入数据</title>
      <link>http://blog.prosight.me/blogs/556</link>
      <pubDate>2010-01-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;strong&gt;导入sql表结构&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;• 用sqlplus命令登录Oracle
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sqlplus system/password@orcl
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;• 使用@命令导入sql文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
SQL&amp;gt; @/path/to/file/sample.sql
&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;导入数据
• 导入ctl文件
在命令行中，执行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sqlldr userid=username/password control=sample.ctl
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>Oracle数据库建立表空间、用户以及授权</title>
      <link>http://blog.prosight.me/blogs/544</link>
      <pubDate>2010-01-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;• 用system用户登录。system用户默认就有DBA的权限
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sqlplus system/password@orcl
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;• 查看数据文件存放位置
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select file_name from dba_data_files;&lt;/p&gt;

&lt;h2&gt;FILE_NAME&lt;/h2&gt;

&lt;p&gt;/Users/oracle/oradata/orcl/users01.dbf
/Users/oracle/oradata/orcl/sysaux01.dbf
/Users/oracle/oradata/orcl/undotbs01.dbf
/Users/oracle/oradata/orcl/system01.dbf
/Users/oracle/oradata/orcl/example01.dbf
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;• 建立临时表空间
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
create temporary tablespace decernis_temp
tempfile &amp;lsquo;/Users/oracle/oradata/orcl/decernis_temp01.dbf&amp;rsquo;
size 32m
autoextend on
next 32m maxsize 2048m
extent management local;&lt;/p&gt;

&lt;p&gt;Tablespace created.
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;• 建立用户数据表空间
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
create tablespace decernis_data
logging
datafile &amp;lsquo;/Users/oracle/oradata/orcl/decernis_data01.dbf&amp;rsquo;
size 32m
autoextend on
next 32m maxsize 2048m
extent management local;&lt;/p&gt;

&lt;p&gt;Tablespace created.
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;• 创建用户
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
create user decernis identified by password
default tablespace decernis_data
temporary tablespace decernis_temp;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;• 授予权限
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
grant dba,connect,resource to decernis;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;注意，上面语句中，制定数据文件路径的时候，一定要使用单引号，否则会出现“ORA-00972: identifier is too long”的错误。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;如果最后一行不添加，则用户没有表空间分配EXTENT的权限，将会会出现“ORA-01950: no privileges on tablespace &lt;tablespace&gt;”的错误。&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;以后，这个用户所操作的表，就自动分配到这个表空间了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Oracle数据库列出所有表</title>
      <link>http://blog.prosight.me/blogs/551</link>
      <pubDate>2010-01-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;可以使用下面的命令来列出当前用户所有的表
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select * from tab;
select table_name from user_tables;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如果想列出所有的表，可以使用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select table_name from all_tables;
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用Google Analytics跟踪你的手机应用</title>
      <link>http://blog.prosight.me/blogs/540</link>
      <pubDate>2010-01-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;大家都知道Google Analytics可以跟踪网站的浏览情况。 其实Google Analytics提供了一个iPhone的本地类库，也可以帮助你跟踪你的手机应用，帮助你分析你的手机应用的用户使用习惯。&lt;/p&gt;

&lt;p&gt;加入Google Analytics的方法很简单：
&lt;ol&gt;
    &lt;li&gt;在&lt;a href=&#34;http://code.google.com/intl/zh-CN/apis/analytics/docs/tracking/mobileAppsTracking.html&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;下载类库。（在页面下面Supported Development Environments部分有下载链接）&lt;/li&gt;
    &lt;li&gt;加入libGoogleAnalytics.a静态类库和GANTracker.h头文件到你的项目中。&lt;/li&gt;
    &lt;li&gt;加入Google Analytics需要的其他类库（CFNetwork framework和libsqlite3.0.dylib。&lt;/li&gt;
    &lt;li&gt;在你的项目中加入几行初始化代码，然后添加跟踪页面或者事件的代码。见下面的示例程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &#34;BasicExampleAppDelegate.h&#34;

#import &#34;GANTracker.h&#34;

// Dispatch period in seconds
 static const NSInteger kGANDispatchPeriodSec = 10;

 @implementation BasicExampleAppDelegate
 
 @synthesize window = window_;
 
 - (void)applicationDidFinishLaunching:(UIApplication *)application {
   // **************************************************************************
   // PLEASE REPLACE WITH YOUR ACCOUNT DETAILS.
   // **************************************************************************
    [[GANTracker sharedTracker] startTrackerWithAccountID:@&#34;UA-0000000-1&#34;
                                          dispatchPeriod:kGANDispatchPeriodSec
                                                delegate:nil];
   NSError *error;
   if (![[GANTracker sharedTracker] trackEvent:@&#34;my_category&#34;
                                        action:@&#34;my_action&#34;
                                         label:@&#34;my_label&#34;
                                         value:-1
                                     withError:&amp;error]) {
     // Handle error here
   }
 
   if (![[GANTracker sharedTracker] trackPageview:@&#34;/app_entry_point&#34;
                                        withError:&amp;error]) {
     // Handle error here
   }
 
   [window_ makeKeyAndVisible];
 }
 
 - (void)dealloc {
   [[GANTracker sharedTracker] stopTracker];
   [window_ release];
   [super dealloc];
 }
 
 @end
&lt;/pre&gt;

&lt;p&gt;Google Analytics的统计也支持Andorid平台，详情请参考&lt;a href=&#34;http://code.google.com/intl/zh-CN/apis/analytics/docs/tracking/mobileAppsTracking.html&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;当然因为这个类库目前只是0.7版本，可能还不够稳定。 类似的类库还有&lt;a href=&#34;http://www.pinchmedia.com/&#34; target=&#34;_blank&#34;&gt;Pinch Media&lt;/a&gt;, &lt;a href=&#34;http://medialets.com/publishers/medialytics.php/&#34; target=&#34;_blank&#34;&gt;Medialets&lt;/a&gt;, &lt;a href=&#34;http://www.mobclix.com/developer/analytics&#34; target=&#34;_blank&#34;&gt;Mobclix&lt;/a&gt;，你可以进行参考。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>从一个url中获得文本信息</title>
      <link>http://blog.prosight.me/blogs/538</link>
      <pubDate>2010-01-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候你可能需要从一个url中获取一个文本文件中的信息。 下面的例子会从我的博客页面下载大量的html信息。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-(void) readFromURL{
    NSError *error;
    NSURL *url = [NSURL URLWithString:@&amp;ldquo;https://blog.prosight.me/&amp;ldquo;];
    NSString *content = [NSString stringWithContentsOfURL: url
                     encoding:NSUTF8StringEncoding
                     error:&amp;amp;error];
}
&lt;/pre&gt;
主要是应用NSString的类方法：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
+ (id)stringWithContentsOfURL:(NSURL *)url encoding:(NSStringEncoding)enc error:(NSError **)error
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;encoding可以为以下这些中的一种
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
enum {
   NSASCIIStringEncoding = 1,
   NSNEXTSTEPStringEncoding = 2,
   NSJapaneseEUCStringEncoding = 3,
   NSUTF8StringEncoding = 4,
   NSISOLatin1StringEncoding = 5,
   NSSymbolStringEncoding = 6,
   NSNonLossyASCIIStringEncoding = 7,
   NSShiftJISStringEncoding = 8,
   NSISOLatin2StringEncoding = 9,
   NSUnicodeStringEncoding = 10,
   NSWindowsCP1251StringEncoding = 11,
   NSWindowsCP1252StringEncoding = 12,
   NSWindowsCP1253StringEncoding = 13,
   NSWindowsCP1254StringEncoding = 14,
   NSWindowsCP1250StringEncoding = 15,
   NSISO2022JPStringEncoding = 21,
   NSMacOSRomanStringEncoding = 30,
   NSUTF16StringEncoding = NSUnicodeStringEncoding,
   NSUTF16BigEndianStringEncoding = 0x90000100,
   NSUTF16LittleEndianStringEncoding = 0x94000100,
   NSUTF32StringEncoding = 0x8c000100,
   NSUTF32BigEndianStringEncoding = 0x98000100,
   NSUTF32LittleEndianStringEncoding = 0x9c000100,
};
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>NSRange 和 NSString</title>
      <link>http://blog.prosight.me/blogs/536</link>
      <pubDate>2009-12-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;NSRange的定义
&lt;pre class=&#34;prettyprint linenums&#34;&gt;typedef struct _NSRange
{
  NSUInteger location;
  NSUInteger length;
} NSRange;
&lt;/pre&gt;
NSRange是一个结构体，其中location是一个以0为开始的index，length是表示对象的长度。他们都是NSUInteger类型。 而NSUInteger类型的定义如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;#if &lt;strong&gt;LP64&lt;/strong&gt; || TARGET_OS_EMBEDDED || TARGET_OS_IPHONE || TARGET_OS_WIN32 || NS_BUILD_32_LIKE_64
typedef unsigned long NSUInteger;
#else
typedef unsigned int NSUInteger;
#endif
&lt;/pre&gt;
例子：
下面这个例子，将输出IPA
&lt;pre class=&#34;prettyprint linenums&#34;&gt;NSString *homebrew = @&amp;ldquo;Imperial India Pale Ale (IPA)&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;// Starting at position 25, get 3 characters
NSRange range = NSMakeRange (25, 3);&lt;/p&gt;

&lt;p&gt;// This would also work:
// NSRange range = {25, 3};&lt;/p&gt;

&lt;p&gt;NSLog (@&amp;ldquo;Beer shortname: %@&amp;ldquo;, [homebrew substringWithRange:range]);
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;搜索字符串：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSString *homebrew = @&amp;ldquo;Imperial India Pale Ale (IPA)&amp;rdquo;;
NSRange range = [homebrew rangeOfString:@&amp;ldquo;IPA&amp;rdquo;];&lt;/p&gt;

&lt;p&gt;// Did we find the string &amp;ldquo;IPA&amp;rdquo; ?
if (range.length &amp;gt; 0)
  NSLog(@&amp;ldquo;Range is: %@&amp;ldquo;, NSStringFromRange(range));
&lt;/pre&gt;
上面的程序将输出Range is: {25, 3}。NSStringFromRange()方法，将一个NSRange返回一个NSString。而另外一个函数NSRangeFromString()则是将NSString转换为NSRange&lt;/p&gt;

&lt;p&gt;下面这个例子将从后向前反向搜索字符串：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSString *homebrew = @&amp;ldquo;Imperial India Pale Ale (IPA)&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;// Search for the &amp;ldquo;ia&amp;rdquo; starting at the end of string
NSRange range = [homebrew rangeOfString:@&amp;ldquo;ia&amp;rdquo; options:NSBackwardsSearch];&lt;/p&gt;

&lt;p&gt;// What did we find
if (range.length &amp;gt; 0)
  NSLog(@&amp;ldquo;Range is: %@&amp;ldquo;, NSStringFromRange(range));
&lt;/pre&gt;
上面的程序将输出：Range is: {12, 2}&lt;/p&gt;

&lt;p&gt;Objective-C中没有正则表达式，如果你想使用更复杂的字符串匹配，可以使用这个类库&lt;a href=&#34;http://regexkit.sourceforge.net/RegexKitLite/index.html&#34; target=&#34;_blank&#34;&gt;RegexKitLite&lt;/a&gt;。它提供了完整的正则表达式实现。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone开发库引用的问题</title>
      <link>http://blog.prosight.me/blogs/534</link>
      <pubDate>2009-12-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;最近的项目用到了著名的Three20界面库， 程序发布完成结果背Apple拒绝，理由是使用了Private APIs， 没话说，肯定是Three20的问题。
于是获取最新代码，编译之后对可执行文件进行扫描确认没有Private APIs被调用了之后再build最终版本以提交App Store， 不知道是哪根筋不对突然觉得是否应该在真机上编译个release版本再提交，不然又要等若干天，万一被打回又得耽误功夫。
果然，一试吓一跳， 无法运行，原因是Three20中的所有对SDK种类的扩展都没被打包编译进来，运行时无法找到相应的selector，当然就crash了
开始是google搜寻答案，屡试之后，静下心来看看Three20的文档， 看到最后才恍然大悟，原来还需要一个 -all_load 连接选项。添加后编译运行，一切顺利， god。
然后翻阅水果文档，才知道 -all_load link option连接选项是告诉编译器将所连接的库全部包含，而不是用到才引入。&lt;/p&gt;

&lt;p&gt;引自：&lt;a href=&#34;http://www.flyblog.info/tag/three20&#34; target=&#34;_blank&#34;&gt;http://www.flyblog.info/tag/three20&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Apple开始允许开发者使用私有API</title>
      <link>http://blog.prosight.me/blogs/532</link>
      <pubDate>2009-12-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在iPhone的程序使用私有API的态度上，Apple的态度似乎有些松动，在Apple官方的开发者论坛中公布了&lt;a href=&#34;https://devforums.apple.com/message/149553&#34; target=&#34;_blank&#34;&gt;允许开发者使用UIGetScreenImage() 这个私有API函数。&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个函数可以让开发者截取用户当前的屏幕。&lt;/p&gt;

&lt;blockquote&gt;After carefully considering the issue, Apple is now allowing applications to use the function UIGetScreenImage() to programmatically capture the current screen contents.&#34; The function prototype is as follows:

CGImageRef UIGetScreenImage();&lt;/blockquote&gt;

&lt;p&gt;并且Apple表态说在今后公布的SDK中，可能会公布跟这个函数等效的公开API函数&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何正确释放Properties变量</title>
      <link>http://blog.prosight.me/blogs/528</link>
      <pubDate>2009-12-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天在看iPhone Development Cookbook 2nd Edition的时候，学习到如何正确释放Properties变量。
例如你有一个Properties变量：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
@property (retain) NSArray *colors;
self.colors = [NSArray arrayWithObjects:@&amp;ldquo;Gray&amp;rdquo;, @&amp;ldquo;Silver&amp;rdquo;, @&amp;ldquo;Black&amp;rdquo;];
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如何正确释放呢？ 正确的方式是
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
self.colors = nil;
&lt;/pre&gt;
这样Objective-c先release原先的colors变量，然后再将nil赋值给colors。&lt;/p&gt;

&lt;p&gt;可能你觉得这样也可以
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[self.colors release];
&lt;/pre&gt;
但是这样可能会导致一个错误出现，因为你现在release了这个变量，减少了它的retain计数，比如从1减为0，当下次再为这个变量进行复制的时候，因为objective-c会先release这个变量，所以就导致两次release，会导致系统崩溃。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>ASIHTTPRequest 一款强大的HTTP包装开源项目 </title>
      <link>http://blog.prosight.me/blogs/526</link>
      <pubDate>2009-12-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;ASIHTTPRequest，是一个直接在CFNetwork上做的开源项目，提供了一个比官方更方便更强大的HTTP网络传输的封装。
特色功能如下：
1，下载的数据直接保存到内存或文件系统里
2，提供直接提交(HTTP POST)文件的API
3，可以直接访问与修改HTTP请求与响应HEADER
4，轻松获取上传与下载的进度信息
5，异步请求与队列，自动管理上传与下载队列管理机
6，认证与授权的支持
7，Cookie
8，请求与响应的GZIP
9，代理请求&lt;/p&gt;

&lt;p&gt;下面来两个小例子：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSURL *url = [NSURL URLWithString:@&amp;ldquo;http://www.baidu.com&amp;rdquo;];
ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];
[request start];
NSError *error = [request error];
if (!error) {
    NSString *response = [request responseString];
}
&lt;/pre&gt;
当你需要添加更多的请求信息时，如，添加个请求Header：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[request addRequestHeader:@&amp;ldquo;name&amp;rdquo; value:@&amp;ldquo;Jory lee&amp;rdquo;];
&lt;/pre&gt;
添加Post请求时的健值:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[request setPostValue:@&amp;ldquo;Ben&amp;rdquo; forKey:@&amp;ldquo;first_name&amp;rdquo;];
[request setPostValue:@&amp;ldquo;Copsey&amp;rdquo; forKey:@&amp;ldquo;last_name&amp;rdquo;];
[request setFile:@&amp;ldquo;/Users/ben/Desktop/ben.jpg&amp;rdquo; forKey:@&amp;ldquo;photo&amp;rdquo;];
&lt;/pre&gt;
设置HTTP的授权帐号：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[request setUsername:@&amp;ldquo;username&amp;rdquo;];
[request setPassword:@&amp;ldquo;password&amp;rdquo;];
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;一个异步请求：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (IBAction)grabURLInBackground:(id)sender
{
NSURL *url = [NSURL URLWithString:@&amp;ldquo;http://allseeing-i.com&amp;rdquo;];
ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];
[request setDelegate:self];
[request startAsynchronous];
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(void)requestFinished:(ASIHTTPRequest *)request
{
// Use when fetching text data
NSString *responseString = [request responseString];&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// Use when fetching binary data
NSData *responseData = [request responseData];
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(void)requestFailed:(ASIHTTPRequest *)request
{
NSError *error = [request error];
}&lt;br /&gt;
&lt;/pre&gt;
在我们数据获取的过程中，如果数据源复杂，一个请求队列是必不可少的：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/li&gt;
&lt;li&gt;(IBAction)grabURLInTheBackground:(id)sender
{
if (![self queue]) {
[self setQueue:[[[NSOperationQueue alloc] init] autorelease]];
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;NSURL *url = [NSURL URLWithString:@&amp;ldquo;http://allseeing-i.com&amp;rdquo;];
ASIHTTPRequest *request = [ASIHTTPRequest requestWithURL:url];
[request setDelegate:self];
[request setDidFinishSelector:@selector(requestDone:)];
[request setDidFailSelector:@selector(requestWentWrong:)];
[[self queue] addOperation:request]; //queue is an NSOperationQueue
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;(void)requestDone:(ASIHTTPRequest *)request
{
NSString *response = [request responseString];
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(void)requestWentWrong:(ASIHTTPRequest *)request
{
NSError *error = [request error];
}&lt;br /&gt;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;援引自：&lt;a href=&#34;http://www.cocoachina.com/bbs/read.php?tid-9455.html&#34; target=&#34;_blank&#34;&gt;http://www.cocoachina.com/bbs/read.php?tid-9455.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>第一个iPhone App成功顺利发布！送促销码！！</title>
      <link>http://blog.prosight.me/blogs/520</link>
      <pubDate>2009-12-10 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;利用工作之余的时间，自己慢慢摸索试着做了一个小的iPhone小程序，开发中也学习了很多前人的经验，收获不少。整个上线发布工作也很顺利，没有遇到任何问题，看来运气还不错:)&lt;/p&gt;

&lt;p&gt;这个程序是我第一个程序，是一个恶搞朋友的娱乐程序。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewSoftware?id=343167143&amp;mt=8&#34; target=&#34;_blank“&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/12/icon.png&#34; alt=&#34;icon&#34; title=&#34;icon&#34; width=&#34;57&#34; height=&#34;57&#34; class=&#34;alignnone size-full wp-image-521&#34; /&gt;&lt;/a&gt;
Crazy Fart 整人放屁精&lt;/p&gt;

&lt;blockquote&gt;
让您的iPhone成为类似放屁垫之类的恶搞工具。它会播放20多种不同的放屁音效！并具有倒计时自动播放功能。

把它放到您的口袋里，您会看到所有人都远离您（特别是在拥挤的地方，比如公车地铁之类的地方）。您也可以设置倒计时功能，然后把您的iPhone放到您朋友的座位边上。 当他开始放屁的时候，看看周围的朋友笑到流出眼泪，想象一下您这位被恶搞朋友的表情吧。
&lt;/blockquote&gt;

&lt;p&gt;应用介绍网站：&lt;a href=&#34;http://apps.prosight.me/crazy-fart/&#34; target=&#34;_blank&#34;&gt;http://apps.prosight.me/crazy-fart/&lt;/a&gt;
iTunes下载链接：&lt;a href=&#34;http://itunes.apple.com/WebObjects/MZStore.woa/wa/viewSoftware?id=343167143&amp;mt=8&#34; target=&#34;_blank&#34;&gt;点击这里下载&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果大家喜欢，可以去&lt;a href=&#34;http://iphoneapp-promocodes.com/App-519-Crazy-Fart.html&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;领取Promotion code后免费下载&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用AVAudioPlayer播放音乐文件</title>
      <link>http://blog.prosight.me/blogs/518</link>
      <pubDate>2009-12-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;AVAudioPlayer 提供了大量的特性，包括暂停播放，调整音量，监控音频的峰值和均值等等。 我们看下面的例子：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
AVAudioPlayer  *player;
NSString       *path;&lt;/p&gt;

&lt;p&gt;// 设置音乐文件路径
path = [[NSBundle mainBundle] pathForResource:@&amp;ldquo;sound-file&amp;rdquo; ofType:@&amp;ldquo;mp3&amp;rdquo;];&lt;/p&gt;

&lt;p&gt;// 判断是否可以访问这个文件
if ([[NSFileManager defaultManager] fileExistsAtPath:path])
{&lt;br /&gt;
  // 设置 player
  player = [[AVAudioPlayer alloc] initWithContentsOfURL:
     [NSURL fileURLWithPath:path] error:&amp;amp;error];&lt;/p&gt;

&lt;p&gt;// 调节音量 (范围从0到1)
  player.volume = 0.4f;&lt;/p&gt;

&lt;p&gt;// 准备buffer，减少播放延时的时间&lt;br /&gt;
  [player prepareToPlay];&lt;/p&gt;

&lt;p&gt;// 设置播放次数，0为播放一次，负数为循环播放
  [player setNumberOfLoops:0];&lt;/p&gt;

&lt;p&gt;[player play];&lt;/p&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;// 清理工作
if (player != nil)
{
  if (player.isPlaying == YES)
    [player stop];
  [player release];
}
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Snow Leopard下，为Rails升级</title>
      <link>http://blog.prosight.me/blogs/515</link>
      <pubDate>2009-12-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Snow Leopard是Apple最新的操作系统，拥有更快的速度并减少了对磁盘的占用。 Snow Leopard自带了ruby 1.8.7，已经可以很好的兼容Rails2.*。 对于Rails的开发者应该注意，如果你是从Leopard升级而来，Snow Leopard默认所有的解释型语言都是64位的(包括Ruby)。所以，如果之前你用的是32位的组建，需要做一些更新。&lt;/p&gt;

&lt;h3&gt;安装Snow Leopard 开发工具&lt;/h3&gt;

&lt;p&gt;在安装光盘上选择 “Optional Installs”, 安装 “Xcode.mpkg”. 使用默认的设置&lt;/p&gt;

&lt;h3&gt;安装Passenger&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo gem install -r passenger
$ sudo passenger-install-apache2-module
&lt;/pre&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cd /etc/apache2
&lt;/pre&gt;
编辑httpd.conf加入一下代码：

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
LoadModule passenger_module /Library/Ruby/Gems/1.8/gems/passenger-2.2.4/ext/apache2/mod_passenger.so
PassengerRoot /Library/Ruby/Gems/1.8/gems/passenger-2.2.4
PassengerRuby /System/Library/Frameworks/Ruby.framework/Versions/1.8/usr/bin/ruby
&lt;/pre&gt;

&lt;h3&gt;安装MySQL&lt;/h3&gt;

&lt;p&gt;为了避免不必要的麻烦，强烈推荐你安装64位版本的MySQL。停止之前版本的MySQL。&lt;/p&gt;

&lt;p&gt;从&lt;a href=&#34;http://dev.mysql.com/downloads/mysql/5.1.html#macosx-dmg&#34;&gt;这里&lt;/a&gt;安装适合Mac OS X 10.5 (x86_64)的MySQL&lt;/p&gt;

&lt;p&gt;下载完成后，打开磁盘镜像，首先安装 “mysql-5.1.37-osx10.5-x86_64.pkg”. 使用默认项即可。&lt;/p&gt;

&lt;p&gt;然后安装 “MySQLStartupItem.pkg”. 作为Mac的启动项.&lt;/p&gt;

&lt;p&gt;最后安装 “MySQL.prefPane”.&lt;/p&gt;

&lt;p&gt;如果之前你安装过32位的MySQL gem，那么你需要重新安装一份适合64位的版本。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo env ARCHFLAGS=&amp;ldquo;-arch x86_64&amp;rdquo; gem install mysql &amp;ndash; &amp;ndash;with-mysql-config=/usr/local/mysql/bin/mysql_config
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;注意，你不需要使用ARCHFLAGS来重新编译其他gem&lt;/p&gt;

&lt;p&gt;原文地址：&lt;a href=&#34;http://weblog.rubyonrails.org/2009/8/30/upgrading-to-snow-leopard&#34; target=&#34;_blank&#34;&gt;http://weblog.rubyonrails.org/&lt;sup&gt;2009&lt;/sup&gt;&amp;frasl;&lt;sub&gt;8&lt;/sub&gt;/30/upgrading-to-snow-leopard&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>struct stat</title>
      <link>http://blog.prosight.me/blogs/510</link>
      <pubDate>2009-12-03 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Unix like的开发如果用stat()函数访问文件的话，会用到struct stat结构体。 其定义如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
struct stat {
        mode_t     st_mode;       //文件对应的模式，文件，目录等
        ino_t      st_ino;       //inode节点号
        dev_t      st_dev;        //设备号码
        dev_t      st_rdev;       //特殊设备号码
        nlink_t    st_nlink;      //文件的连接数
        uid_t      st_uid;        //文件所有者
        gid_t      st_gid;        //文件所有者对应的组
        off_t      st_size;       //普通文件，对应的文件字节数
        time_t     st_atime;      //文件最后被访问的时间
        time_t     st_mtime;      //文件内容最后被修改的时间
        time_t     st_ctime;      //文件状态改变时间
        blksize_t st_blksize;    //文件内容对应的块大小
        blkcnt_t   st_blocks;     //伟建内容对应的块数量
      };
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Linux文件查找命令find,xargs详述</title>
      <link>http://blog.prosight.me/blogs/497</link>
      <pubDate>2009-12-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;前言：关于find命令&lt;/p&gt;

&lt;p&gt;由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。&lt;/p&gt;

&lt;p&gt;在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。&lt;/p&gt;

&lt;p&gt;一、find 命令格式&lt;/p&gt;

&lt;p&gt;1、find命令的一般形式为；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
find pathname -options [-print -exec -ok &amp;hellip;]
&lt;/pre&gt;
2、find命令的参数；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。
-print： find命令将匹配的文件输出到标准输出。
-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&amp;rsquo;command&amp;rsquo; {  } ;，注意{   }和；之间的空格。
-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;3、find命令选项
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-name
按照文件名查找文件。&lt;/p&gt;

&lt;p&gt;-perm
按照文件权限来查找文件。&lt;/p&gt;

&lt;p&gt;-prune
使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。&lt;/p&gt;

&lt;p&gt;-user
按照文件属主来查找文件。&lt;/p&gt;

&lt;p&gt;-group
按照文件所属的组来查找文件。&lt;/p&gt;

&lt;p&gt;-mtime -n +n
按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项。&lt;/p&gt;

&lt;p&gt;-nogroup
查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。&lt;/p&gt;

&lt;p&gt;-nouser
查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。
-newer file1 ! file2&lt;/p&gt;

&lt;p&gt;查找更改时间比文件file1新但比文件file2旧的文件。
-type&lt;/p&gt;

&lt;p&gt;查找某一类型的文件，诸如：&lt;/p&gt;

&lt;p&gt;b - 块设备文件。
d - 目录。
c - 字符设备文件。
p - 管道文件。
l - 符号链接文件。
f - 普通文件。&lt;/p&gt;

&lt;p&gt;-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。
-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。&lt;/p&gt;

&lt;p&gt;-mount：在查找文件时不跨越文件系统mount点。
-follow：如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。
-cpio：对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。
&lt;/pre&gt;
另外,下面三个的区别:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
   -amin n
　　查找系统中最后N分钟访问的文件&lt;/p&gt;

&lt;p&gt;　　-atime n
　　查找系统中最后n*24小时访问的文件&lt;/p&gt;

&lt;p&gt;　　-cmin n
　　查找系统中最后N分钟被改变文件状态的文件&lt;/p&gt;

&lt;p&gt;　　-ctime n
　　查找系统中最后n*24小时被改变文件状态的文件&lt;/p&gt;

&lt;p&gt;　-mmin n
　　查找系统中最后N分钟被改变文件数据的文件&lt;/p&gt;

&lt;p&gt;　　-mtime n
　　查找系统中最后n*24小时被改变文件数据的文件
&lt;/pre&gt;
4、使用exec或ok来执行shell命令&lt;/p&gt;

&lt;p&gt;使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的&lt;/p&gt;

&lt;p&gt;在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。&lt;/p&gt;

&lt;p&gt;exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。&lt;/p&gt;

&lt;p&gt;例如：为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在find命令的-exec选项中
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;find . -type f -exec ls -l {  } ;&lt;/h1&gt;

&lt;p&gt;-rw-r&amp;ndash;r&amp;ndash;    1 root     root        34928 2003-02-25  ./conf/httpd.conf
-rw-r&amp;ndash;r&amp;ndash;    1 root     root        12959 2003-02-25  ./conf/magic
-rw-r&amp;ndash;r&amp;ndash;    1 root     root          180 2003-02-25  ./conf.d/README
&lt;/pre&gt;
上面的例子中，find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。
在/logs目录中查找更改时间在5日以前的文件并删除它们：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find logs -type f -mtime +5 -exec rm {  } ;
&lt;/pre&gt;
记住：在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如mv或rm命令时，可以使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。&lt;/p&gt;

&lt;p&gt;在下面的例子中， find命令在当前目录中查找所有文件名以.LOG结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -name &amp;ldquo;*.conf&amp;rdquo;  -mtime +5 -ok rm {  } ;
&amp;lt; rm &amp;hellip; ./conf/httpd.conf &amp;gt; ? n
&lt;/pre&gt;
按y键删除文件，按n键不删除。&lt;/p&gt;

&lt;p&gt;任何形式的命令都可以在-exec选项中使用。&lt;/p&gt;

&lt;p&gt;在下面的例子中我们使用grep命令。find命令首先匹配所有文件名为“ passwd*”的文件，例如passwd、passwd.old、passwd.bak，然后执行grep命令看看在这些文件中是否存在一个sam用户。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;find /etc -name &amp;ldquo;passwd*&amp;rdquo; -exec grep &amp;ldquo;sam&amp;rdquo; {  } ;&lt;/h1&gt;

&lt;p&gt;sam:x:501:501::/usr/sam:/bin/bash
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;二、find命令的例子；&lt;/p&gt;

&lt;p&gt;1、查找当前用户主目录下的所有文件：&lt;/p&gt;

&lt;p&gt;下面两种方法都可以使用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find $HOME -print
$ find ~ -print
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;2、让当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -type f -perm 644 -exec ls -l {  } ;
&lt;/pre&gt;
3、为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find / -type f -size 0 -exec ls -l {  } ;
&lt;/pre&gt;
4、查找/var/logs目录中更改时间在7日以前的普通文件，并在删除之前询问它们；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /var/logs -type f -mtime +7 -ok rm {  } ;
&lt;/pre&gt;
5、为了查找系统中所有属于root组的文件；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$find . -group root -exec ls -l {  } ;
-rw-r&amp;ndash;r&amp;ndash;    1 root     root          595 10月 31 01:09 ./fie1
&lt;/pre&gt;
6、find命令将删除当目录中访问时间在7日以来、含有数字后缀的admin.log文件。&lt;/p&gt;

&lt;p&gt;该命令只检查三位数字，所以相应文件的后缀不要超过999。先建几个admin.log*的文件 ，才能使用下面这个命令
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -name &amp;ldquo;admin.log[0-9][0-9][0-9]&amp;rdquo; -atime -7  -ok
rm {  } ;
&amp;lt; rm &amp;hellip; ./admin.log001 &amp;gt; ? n
&amp;lt; rm &amp;hellip; ./admin.log002 &amp;gt; ? n
&amp;lt; rm &amp;hellip; ./admin.log042 &amp;gt; ? n
&amp;lt; rm &amp;hellip; ./admin.log942 &amp;gt; ? n
&lt;/pre&gt;
7、为了查找当前文件系统中的所有目录并排序；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -type d | sort
&lt;/pre&gt;
8、为了查找系统中所有的rmt磁带设备；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /dev/rmt -print
&lt;/pre&gt;
三、xargs
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
xargs - build and execute command lines from standard input
&lt;/pre&gt;
在使用find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。&lt;/p&gt;

&lt;p&gt;find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。&lt;/p&gt;

&lt;p&gt;在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；&lt;/p&gt;

&lt;p&gt;而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。&lt;/p&gt;

&lt;p&gt;来看看xargs命令是如何同find命令一起使用的，并给出一些例子。&lt;/p&gt;

&lt;p&gt;下面的例子查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#find . -type f -print | xargs file
./.kde/Autostart/Autorun.desktop: UTF-8 Unicode English text
./.kde/Autostart/.directory:      ISO-8859 text
&amp;hellip;&amp;hellip;
&lt;/pre&gt;
在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find / -name &amp;ldquo;core&amp;rdquo; -print | xargs echo &amp;ldquo;&amp;rdquo; &amp;gt;/tmp/core.log
&lt;/pre&gt;
上面这个执行太慢，我改成在当前目录下查找
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#find . -name &amp;ldquo;file*&amp;rdquo; -print | xargs echo &amp;ldquo;&amp;rdquo; &amp;gt; /temp/core.log&lt;/p&gt;

&lt;h1&gt;cat /temp/core.log&lt;/h1&gt;

&lt;p&gt;./file6
&lt;/pre&gt;
在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;ls -l&lt;/h1&gt;

&lt;p&gt;drwxrwxrwx    2 sam      adm          4096 10月 30 20:14 file6
-rwxrwxrwx    2 sam      adm             0 10月 31 01:01 http3.conf
-rwxrwxrwx    2 sam      adm             0 10月 31 01:01 httpd.conf&lt;/p&gt;

&lt;h1&gt;find . -perm -7 -print | xargs chmod o-w&lt;/h1&gt;

&lt;h1&gt;ls -l&lt;/h1&gt;

&lt;p&gt;drwxrwxr-x    2 sam      adm          4096 10月 30 20:14 file6
-rwxrwxr-x    2 sam      adm             0 10月 31 01:01 http3.conf
-rwxrwxr-x    2 sam      adm             0 10月 31 01:01 httpd.conf
&lt;/pre&gt;
用grep命令在所有的普通文件中搜索hostname这个词：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;find . -type f -print | xargs grep &amp;ldquo;hostname&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;./httpd1.conf:#     different IP addresses or hostnames and have them handled by the
./httpd1.conf:# VirtualHost: If you want to maintain multiple domains/hostnames
on your
&lt;/pre&gt;
用grep命令在当前目录下的所有普通文件中搜索hostnames这个词：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;find . -name * -type f -print | xargs grep &amp;ldquo;hostnames&amp;rdquo;&lt;/h1&gt;

&lt;p&gt;./httpd1.conf:#     different IP addresses or hostnames and have them handled by the
./httpd1.conf:# VirtualHost: If you want to maintain multiple domains/hostnames
on your
&lt;/pre&gt;
注意，在上面的例子中， 用来取消find命令中的*在shell中的特殊含义。&lt;/p&gt;

&lt;p&gt;find命令配合使用exec和xargs可以使用户对所匹配到的文件执行几乎所有的命令。&lt;/p&gt;

&lt;p&gt;四、find 命令的参数&lt;/p&gt;

&lt;p&gt;下面是find一些常用参数的例子，有用到的时候查查就行了，像上面前几个贴子，都用到了其中的的一些参数，也可以用man或查看论坛里其它贴子有find的命令手册&lt;/p&gt;

&lt;p&gt;1、使用name选项&lt;/p&gt;

&lt;p&gt;文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。&lt;/p&gt;

&lt;p&gt;可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。&lt;/p&gt;

&lt;p&gt;不管当前路径是什么，如果想要在自己的根目录$HOME中查找文件名符合&lt;em&gt;.txt的文件，使用~作为 &amp;lsquo;pathname&amp;rsquo;参数，波浪号~代表了你的$HOME目录。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find ~ -name &amp;ldquo;&lt;/em&gt;.txt&amp;rdquo; -print
&lt;/pre&gt;
想要在当前目录及子目录中查找所有的‘ &lt;em&gt;.txt’文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -name &amp;ldquo;&lt;/em&gt;.txt&amp;rdquo; -print
&lt;/pre&gt;
想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -name &amp;ldquo;[A-Z]&lt;em&gt;&amp;rdquo; -print
&lt;/pre&gt;
想要在/etc目录中查找文件名以host开头的文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /etc -name &amp;ldquo;host&lt;/em&gt;&amp;rdquo; -print
&lt;/pre&gt;
想要查找$HOME目录中的文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find ~ -name &amp;ldquo;&lt;em&gt;&amp;rdquo; -print 或find . -print
&lt;/pre&gt;
要想让系统高负荷运行，就从根目录开始查找所有的文件。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find / -name &amp;ldquo;&lt;/em&gt;&amp;rdquo; -print
&lt;/pre&gt;
如果想在当前目录查找文件名以两个小写字母开头，跟着是两个数字，最后是.txt的文件，下面的命令就能够返回名为ax37.txt的文件：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$find . -name &amp;ldquo;[a-z][a-z][0&amp;ndash;9][0&amp;ndash;9].txt&amp;rdquo; -print
&lt;/pre&gt;
2、用perm选项&lt;/p&gt;

&lt;p&gt;按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法。&lt;/p&gt;

&lt;p&gt;如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -perm 755 -print
&lt;/pre&gt;
还有一种表达方法：在八进制数字前面要加一个横杠-，表示都匹配，如-007就相当于777，-006相当于666
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;ls -l&lt;/h1&gt;

&lt;p&gt;-rwxrwxr-x    2 sam      adm             0 10月 31 01:01 http3.conf
-rw-rw-rw-    1 sam      adm         34890 10月 31 00:57 httpd1.conf
-rwxrwxr-x    2 sam      adm             0 10月 31 01:01 httpd.conf
drw-rw-rw-    2 gem      group        4096 10月 26 19:48 sam
-rw-rw-rw-    1 root     root         2792 10月 31 20:19 temp&lt;/p&gt;

&lt;h1&gt;find . -perm 006&lt;/h1&gt;

&lt;h1&gt;find . -perm -006&lt;/h1&gt;

&lt;p&gt;./sam
./httpd1.conf
./temp
-perm mode:文件许可正好符合mode&lt;/p&gt;

&lt;p&gt;-perm +mode:文件许可部分符合mode&lt;/p&gt;

&lt;p&gt;-perm -mode: 文件许可完全符合mode&lt;/p&gt;

&lt;p&gt;&lt;/pre&gt;
3、忽略某个目录&lt;/p&gt;

&lt;p&gt;如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用-prune选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略。&lt;/p&gt;

&lt;p&gt;如果希望在/apps目录下查找文件，但不希望在/apps/bin目录下查找，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /apps -path &amp;ldquo;/apps/bin&amp;rdquo; -prune -o -print
&lt;/pre&gt;
4、使用find查找文件的时候怎么避开某个文件目录&lt;/p&gt;

&lt;p&gt;比如要在/usr/sam目录下查找不在dir1子目录之内的所有文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
find /usr/sam -path &amp;ldquo;/usr/sam/dir1&amp;rdquo; -prune -o -print
&lt;/pre&gt;
find [-path ..] [expression] 在路径列表的后面的是表达式
-path &amp;ldquo;/usr/sam&amp;rdquo; -prune -o -print 是 -path &amp;ldquo;/usr/sam&amp;rdquo; -a -prune -o
-print 的简写表达式按顺序求值, -a 和 -o 都是短路求值，与 shell 的 &amp;amp;&amp;amp; 和 || 类似如果 -path &amp;ldquo;/usr/sam&amp;rdquo; 为真，则求值 -prune , -prune 返回真，与逻辑表达式为真；否则不求值 -prune，与逻辑表达式为假。如果 -path &amp;ldquo;/usr/sam&amp;rdquo; -a -prune 为假，则求值 -print ，-print返回真，或逻辑表达式为真；否则不求值 -print，或逻辑表达式为真。&lt;/p&gt;

&lt;p&gt;这个表达式组合特例可以用伪码写为
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
if -path &amp;ldquo;/usr/sam&amp;rdquo;  then
          -prune
else
          -print
&lt;/pre&gt;
避开多个文件夹
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
find /usr/sam ( -path /usr/sam/dir1 -o -path /usr/sam/file1 ) -prune -o -print
&lt;/pre&gt;
圆括号表示表达式的结合。
 表示引用，即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。
查找某一确定文件，-name等选项加在-o 之后
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#find /usr/sam  (-path /usr/sam/dir1 -o -path /usr/sam/file1 ) -prune -o -name &amp;ldquo;temp&amp;rdquo; -print
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;5、使用user和nouser选项&lt;/p&gt;

&lt;p&gt;按文件属主查找文件，如在$HOME目录中查找文件属主为sam的文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find ~ -user sam -print
&lt;/pre&gt;
在/etc目录下查找文件属主为uucp的文件：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /etc -user uucp -print
&lt;/pre&gt;
为了查找属主帐户已经被删除的文件，可以使用-nouser选项。这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-nouser选项时，不必给出用户名； find命令能够为你完成相应的工作。&lt;/p&gt;

&lt;p&gt;例如，希望在/home目录下查找所有的这类文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /home -nouser -print
&lt;/pre&gt;
6、使用group和nogroup选项&lt;/p&gt;

&lt;p&gt;就像user和nouser选项一样，针对文件所属于的用户组， find命令也具有同样的选项，为了在/apps目录下查找属于gem用户组的文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /apps -group gem -print
&lt;/pre&gt;
要查找没有有效所属用户组的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find / -nogroup-print
&lt;/pre&gt;
7、按照更改时间或访问时间等查找文件&lt;/p&gt;

&lt;p&gt;如果希望按照更改时间来查找文件，可以使用mtime,atime或ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。&lt;/p&gt;

&lt;p&gt;用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。&lt;/p&gt;

&lt;p&gt;希望在系统根目录下查找更改时间在5日以内的文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find / -mtime -5 -print
&lt;/pre&gt;
为了在/var/adm目录下查找更改时间在3日以前的文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /var/adm -mtime +3 -print
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;8、查找比某个文件新或旧的文件&lt;/p&gt;

&lt;p&gt;如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项。它的一般形式为：&lt;/p&gt;

&lt;p&gt;newest_file_name ! oldest_file_name
其中，！是逻辑非符号。&lt;/p&gt;

&lt;p&gt;查找更改时间比文件sam新但比文件temp旧的文件：&lt;/p&gt;

&lt;p&gt;例：有两个文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-rw-r&amp;ndash;r&amp;ndash;    1 sam      adm             0 10月 31 01:07 fiel
-rw-rw-rw-    1 sam      adm         34890 10月 31 00:57 httpd1.conf
-rwxrwxr-x    2 sam      adm             0 10月 31 01:01 httpd.conf
drw-rw-rw-    2 gem      group        4096 10月 26 19:48 sam
-rw-rw-rw-    1 root     root         2792 10月 31 20:19 temp&lt;/p&gt;

&lt;h1&gt;find -newer httpd1.conf  ! -newer temp -ls&lt;/h1&gt;

&lt;p&gt;1077669    0 -rwxrwxr-x   2 sam      adm             0 10月 31 01:01 ./httpd.conf
1077671    4 -rw-rw-rw-   1 root     root         2792 10月 31 20:19 ./temp
1077673    0 -rw-r&amp;ndash;r&amp;ndash;   1 sam      adm             0 10月 31 01:07 ./fiel
&lt;/pre&gt;
查找更改时间在比temp文件新的文件：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -newer temp -print
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;9、使用type选项
在/etc目录下查找所有的目录，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /etc -type d -print
&lt;/pre&gt;
在当前目录下查找除目录以外的所有类型的文件，可以用：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . ! -type d -print
&lt;/pre&gt;
在/etc目录下查找所有的符号链接文件，可以用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /etc -type l -print
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;10、使用size选项&lt;/p&gt;

&lt;p&gt;可以按照文件长度来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。以字节计量文件长度的表达形式为N c；以块计量文件长度只用数字表示即可。&lt;/p&gt;

&lt;p&gt;在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。
在当前目录下查找文件长度大于1 M字节的文件：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -size +1000000c -print
&lt;/pre&gt;
在/home/apache目录下查找文件长度恰好为100字节的文件：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find /home/apache -size 100c -print
&lt;/pre&gt;
在当前目录下查找长度超过10块的文件（一块等于512字节）：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -size +10 -print
&lt;/pre&gt;
11、使用depth选项&lt;/p&gt;

&lt;p&gt;在使用find命令时，可能希望先匹配所有的文件，再在子目录中查找。使用depth选项就可以使find命令这样做。这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。&lt;/p&gt;

&lt;p&gt;在下面的例子中， find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。&lt;/p&gt;

&lt;p&gt;它将首先匹配所有的文件然后再进入子目录中查找。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find / -name &amp;ldquo;CON.FILE&amp;rdquo; -depth -print
&lt;/pre&gt;
12、使用mount选项&lt;/p&gt;

&lt;p&gt;在当前的文件系统中查找文件（不进入其他文件系统），可以使用find命令的mount选项。&lt;/p&gt;

&lt;p&gt;从当前目录开始查找位于本文件系统中文件名以XC结尾的文件：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ find . -name &amp;ldquo;*.XC&amp;rdquo; -mount -print
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;五、关于本文&lt;/p&gt;

&lt;p&gt;本文是find 命令的详细说明，可贵的是针对参数举了很多的实例，大量的例证，让初学者更为容易理解；本文是zhy2111314兄贴在论坛中；我对本文进行了再次整理，为方便大家阅读； ── 北南南北&lt;/p&gt;

&lt;p&gt;转载自：&lt;a href=&#34;http://www.linuxsir.org/main/?q=node/137&#34; target=&#34;_blank&#34;&gt;http://www.linuxsir.org/main/?q=node/137&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Visor - 把你的终端变成Quake式的下拉形式</title>
      <link>http://blog.prosight.me/blogs/502</link>
      <pubDate>2009-12-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果你经常使用终端程序，这个小程序一定可以帮到你。他能将终端窗口变成类似雷神或CS那样的下拉窗口，非常酷。&lt;/p&gt;

&lt;p&gt;可以从这里下载 &lt;a href=&#34;http://visor.binaryage.com/&#34; target=&#34;_blank&#34;&gt;http://visor.binaryage.com/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;这个软件需要&lt;a href=&#34;http://www.culater.net/software/SIMBL/SIMBL.php&#34; target=&#34;_blank&#34;&gt;SIMBL&lt;/a&gt; ，如果你没有安装，要先安装这个。&lt;/p&gt;

&lt;p&gt;之后将下载下来的文件解压，将解压后的文件拷贝至/Library/Application Support/SIMBL/Plugins，之后再重新启动你的终端你就可以看到效果了。 默认的快捷启动键是Ctrl+&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/12/95d51fe0-f9a0-3c1e-874f-8549af02df28.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/12/95d51fe0-f9a0-3c1e-874f-8549af02df28-300x222.png&#34; alt=&#34;Visor&#34; title=&#34;Visor&#34; width=&#34;300&#34; height=&#34;222&#34; class=&#34;aligncenter size-medium wp-image-506&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Quicksilver - 快速启动你的应用程序</title>
      <link>http://blog.prosight.me/blogs/499</link>
      <pubDate>2009-12-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://docs.blacktree.com/lib/exe/fetch.php?w=&amp;h=&amp;cache=cache&amp;media=http%3A%2F%2Fwww.blacktree.com%2Fquicksilver%2Fimages%2Fscreenshots%2FBezel.s.gif&#34; title=&#34;Quicksilver&#34; class=&#34;aligncenter&#34; width=&#34;184&#34; height=&#34;109&#34; /&gt;&lt;/p&gt;

&lt;p&gt;偶然间看别人的视频无意中发现这个小软件，感觉很实用。 它是一个launcher，使用它可以通过键盘快速的启动你的应用程序，而不必用鼠标在一堆的应用程序中选择。&lt;/p&gt;

&lt;p&gt;软件安装也很简单，在它的官网下载&lt;a href=&#34;http://blacktree.com/&#34; target=&#34;_blank&#34;&gt;Quicksilver&lt;/a&gt;.解压后拖入Application中即可。&lt;/p&gt;

&lt;p&gt;运行这个软件，它会自动将经常打开的文件，程序记录到它的category中，可以通过键盘输入快速检索你所要启动的程序。&lt;/p&gt;

&lt;p&gt;这个软件默认的快捷启动键是Control-Space,你可以修改成其他快捷键比如option-space&lt;/p&gt;

&lt;p&gt;这里有一个简要的快速入门：&lt;a href=&#34;http://docs.blacktree.com/quicksilver/what_is_quicksilver&#34; target=&#34;_blank&#34;&gt;http://docs.blacktree.com/quicksilver/what_is_quicksilver&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>loadView vs viewDidLoad</title>
      <link>http://blog.prosight.me/blogs/492</link>
      <pubDate>2009-11-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;iPhone开发必不可少的要用到这两个方法。 他们都可以用来在视图载入的时候，初始化一些内容。 但是他们有什么区别呢？&lt;/p&gt;

&lt;p&gt;viewDidLoad 此方法只有当view从nib文件初始化的时候才被调用。&lt;/p&gt;

&lt;p&gt;loadView 此方法在控制器的view为nil的时候被调用。 此方法用于以编程的方式创建view的时候用到。 如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)loadView {
    UIView *view = [[UIView alloc] initWithFrame:[UIScreen
mainScreen].applicationFrame];
    [view setBackgroundColor:_color];
    self.view = view;
    [view release];
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;你在控制器中实现了loadView方法，那么你可能会在应用运行的某个时候被内存管理控制调用。 如果设备内存不足的时候， view 控制器会收到didReceiveMemoryWarning的消息。 默认的实现是检查当前控制器的view是否在使用。 如果它的view不在当前正在使用的view hierarchy里面，且你的控制器实现了loadView方法，那么这个view将被release, loadView方法将被再次调用来创建一个新的view。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>禁用复制粘帖功能</title>
      <link>http://blog.prosight.me/blogs/490</link>
      <pubDate>2009-11-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在SDK3.0中添加了复制粘帖功能，但是有时候这个新功能可能对你的应用造成不必要的麻烦。 今天在网上查到了这个方法，可以在Responder链上禁用复制粘帖功能。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (BOOL)canPerformAction:(SEL)action withSender:(id)sender
    {
        if (action == @selector(xxx)
            return NO;
        return [super canPerformAction:action withSender:sender];
    }
&lt;/pre&gt;
其中xxx就是你要禁用的方法，比如copy,cut,paste等
这是官方文档对这个方法的说明&lt;/p&gt;

&lt;blockquote&gt;
canPerformAction:withSender:
Requests the receiving responder to enable or disable the specified command in the user interface.

- (BOOL)canPerformAction:(SEL)action withSender:(id)sender

Parameters
action
A selector that identifies a method associated with a command. For the editing menu, this is one of the editing methods declared by the UIResponderStandardEditActions informal protocol (or example, copy:).

sender
The object calling this method. For the editing menu commands, this is the shared UIApplication object. Depending on the context, you can query the sender for information to help you determine whether a command should be enabled.

Return Value
YES if the the command identified by action should be enabled or NO if it should be disabled. Returning YES means that your class can handle the command in the current context.

Discussion
This default implementation of this method returns YES if the responder class implements the requested action and calls the next responder if it does not. Subclasses may override this method to enable menu commands based on the current state; for example, you would enable the Copy command if there is a selection or disable the Paste command if the pasteboard did not contain data with the correct pasteboard representation type. If no responder in the responder chain returns YES, the menu command is disabled. Note that if your class returns NO for a command, another responder further up the responder chain may still return YES, enabling the command.

This method might be called more than once for the same action but with a different sender each time. You should be prepared for any kind of sender including nil.

For information on the editing menu, see the description of the UIMenuController class.

Availability
Available in iPhone OS 3.0 and later.
Declared In
UIResponder.h
&lt;/blockquote&gt;
</description>
    </item>
    <item>
      <title>小组级git服务器搭建</title>
      <link>http://blog.prosight.me/blogs/485</link>
      <pubDate>2009-11-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果使用git的人数较少，可以使用下面的步骤快速部署一个git服务器环境。&lt;/p&gt;

&lt;h2&gt;1. 生成 SSH 公钥&lt;/h2&gt;

&lt;p&gt;每个需要使用git服务器的工程师，自己需要生成一个ssh公钥
进入自己的~/.ssh目录，看有没有用 文件名 和 文件名.pub 来命名的一对文件，这个 文件名 通常是 id_dsa 或者 id_rsa。 .pub 文件是公钥，另一个文件是密钥。假如没有这些文件（或者干脆连 .ssh 目录都没有），你可以用 ssh-keygen 的程序来建立它们，该程序在 Linux/Mac 系统由 SSH 包提供， 在 Windows 上则包含在 MSysGit 包里:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ ssh-keygen
Generating public/private rsa key pair.
Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /Users/schacon/.ssh/id_rsa.
Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.
The key fingerprint is:
43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;它先要求你确认保存公钥的位置（.ssh/id_rsa），然后它会让你重复一个密码两次，如果不想在使用公钥的时候输入密码，可以留空。&lt;/p&gt;

&lt;p&gt;现在，所有做过这一步的用户都得把它们的公钥给你或者 Git 服务器的管理者（假设 SSH 服务被设定为使用公钥机制）。他们只需要复制 .pub 文件的内容然后 e-email 之。公钥的样子大致如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
NrRFi9wrf+M7Q== schacon@agadorlaptop.local
&lt;/pre&gt;&lt;/p&gt;

&lt;h2&gt;2. 架设服务器&lt;/h2&gt;

&lt;p&gt;首先，创建一个 ‘git’ 用户并为其创建一个 .ssh 目录，在用户主目录下:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo adduser git
$ su git
$ cd
$ mkdir .ssh
&lt;/pre&gt;
接下来，把开发者的 SSH 公钥添加到这个用户的 authorized_keys 文件中。假设你通过 e-mail 收到了几个公钥并存到了临时文件里。只要把它们加入 authorized_keys 文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cat /tmp/id_rsa.john.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.josie.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
$ cat /tmp/id_rsa.jessica.pub &amp;gt;&amp;gt; ~/.ssh/authorized_keys
&lt;/pre&gt;
现在可以使用 &amp;ndash;bare 选项运行 git init 来设定一个空仓库，这会初始化一个不包含工作目录的仓库。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cd /opt/git
$ mkdir project.git
$ cd project.git
$ git &amp;ndash;bare init
&lt;/pre&gt;
这时，开发人员就可以把它加为远程仓库，推送一个分支，从而把第一个版本的工程上传到仓库里了。值得注意的是，每次添加一个新项目都需要通过 shell 登入主机并创建一个纯仓库。我们不妨以 gitserver 作为 git 用户和仓库所在的主机名。如果你在网络内部运行该主机，并且在 DNS 中设定 gitserver 指向该主机，那么以下这些命令都是可用的：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;在一个工程师的电脑上&lt;/h1&gt;

&lt;p&gt;$ cd myproject
$ git init
$ git add .
$ git commit -m &amp;lsquo;initial commit&amp;rsquo;
$ git remote add origin git@gitserver:/opt/git/project.git
$ git push origin master
&lt;/pre&gt;
这样，其他人的克隆和推送也一样变得很简单：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git clone git@gitserver:/opt/git/project.git
$ vim README
$ git commit -am &amp;lsquo;fix for the README file&amp;rsquo;
$ git push origin master
&lt;/pre&gt;
用这个方法可以很快捷的为少数几个开发者架设一个可读写的 Git 服务。&lt;/p&gt;

&lt;p&gt;作为一个额外的防范措施，你可以用 Git 自带的 git-shell 简单工具来把 git 用户的活动限制在仅与 Git 相关。把它设为 git 用户登入的 shell，那么该用户就不能拥有主机正常的 shell 访问权。为了实现这一点，需要指明用户的登入shell 是 git-shell ，而不是 bash 或者 csh。你可能得编辑 /etc/passwd 文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo vim /etc/passwd
&lt;/pre&gt;
在文件末尾，你应该能找到类似这样的行：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
git:x:1000:1000::/home/git:/bin/sh
&lt;/pre&gt;
把 bin/sh 改为 /usr/bin/git-shell （或者用 which git-shell 查看它的位置）。该行修改后的样子如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
git:x:1000:1000::/home/git:/usr/bin/git-shell
&lt;/pre&gt;
现在 git 用户只能用 SSH 连接来推送和获取 Git 仓库，而不能直接使用主机 shell。尝试登录的话，你会看到下面这样的拒绝信息：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ ssh git@gitserver
fatal: What do you think I am? A shell? （你以为我是个啥？shell吗？)
Connection to gitserver closed. （gitserver 连接已断开。）
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone应用程序名称本地化</title>
      <link>http://blog.prosight.me/blogs/488</link>
      <pubDate>2009-11-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;iPhone的应用程序名称也可以本地化，可以按照以下步骤来实施：
&lt;h2&gt;1. 修改项目目录下的&amp;rsquo;&lt;project name&gt;-info.plist&amp;rsquo;文件名&lt;/h2&gt;
将&amp;rsquo;&lt;project name&gt;-info.plist&amp;rsquo; 修改为 Info.plist&lt;/p&gt;

&lt;h2&gt;2. 将Info.plist本地化&lt;/h2&gt;

&lt;p&gt;在Info.plist上右键点选Get Info，在General标签下，点击Make File Localizable按钮。
里面会有一个默认的英文版本，点击Add Localization&amp;hellip; 按钮，添加你需要的本地化语言。 如简体中文&amp;rdquo;zh-hans&amp;rdquo;,然后点击添加
注意这里用了“zh-hans&amp;rdquo;表示简体中文，你也可以用&amp;rdquo;zh-CN&amp;rdquo;来表示，不过有些情况下这个可能不起作用。 对应的&amp;rdquo;zh-hant&amp;rdquo;表示繁体中文。&lt;/p&gt;

&lt;h2&gt;3. 创建InfoPlist.strings文件，并本地化它&lt;/h2&gt;

&lt;p&gt;在项目目录下新建一个InfoPlist.strings文件，重复上面的步骤，将其本地化。&lt;/p&gt;

&lt;h2&gt;4. 编辑InfoPlist.strings中的内容。&lt;/h2&gt;

&lt;p&gt;现在你就可以编辑InfoPlist.strings中的内容，实现应用程序名称的本地化了。
在其中添加
CFBundleDisplayName = &amp;ldquo;xxxxx&amp;rdquo;;
就可以了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>UITableView reloadData或viewWillAppear失效</title>
      <link>http://blog.prosight.me/blogs/483</link>
      <pubDate>2009-11-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天在做开发的时候，忽然发现在视图的viewWillAppear:方法中添加:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[self.tableView reloadData];
&lt;/pre&gt;
不起作用，viewWillAppear:这个方法根本没有调用&lt;/p&gt;

&lt;p&gt;后来发现原来用了UINavigationController后，viewWillAppear方法是没有效果的，要用UINavigationControllerDelegate的– navigationController:willShowViewController:animated:方法才可以达到这个目的。&lt;/p&gt;

&lt;p&gt;所以要做到这个，你必须做以下几步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;设置代理类
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
nav.delegate = self;
&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;代理类实现UINavigationControllerDelegate Protocol&lt;/li&gt;
&lt;li&gt;在代理类中添加– navigationController:willShowViewController:animated:方法&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)navigationController:(UINavigationController *)navigationController willShowViewController:(UIViewController *)viewController animated:(BOOL)animated {
    [self.myTableView reloadData];
}
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>loadView时候的注意事项</title>
      <link>http://blog.prosight.me/blogs/481</link>
      <pubDate>2009-11-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;loadView是使用代码生成视图的时候，当视图第一次载入的时候调用的方法。&lt;/p&gt;

&lt;p&gt;今天写一个Navigation Controller，给它加一个继承了TableViewController的View作为Navigation Controller的Root View&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
UITableViewController *tableViewController = [[TableViewController alloc] init];

UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController: tableViewController];
nav.navigationBar.barStyle = UIBarStyleBlack;
[self.view addSubview:nav.view];
&lt;/pre&gt;

&lt;p&gt;一切都很顺利成章，但是运行的时候，除了显示一个NavigationBar以外，表格并没有显示出来。 反复查找原因都为果。 后来仔细对比之前的代码，原来是tablebView中的loadView方法少写了下面这行代码：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[super loadView];
&lt;/pre&gt;

&lt;p&gt;后来查了文档，说的很清楚，自己的类里面的loadView一定要第一行加上[super loadView]这句话。 看来以后还是要多注意细节。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>判断你的设备是iPhone还是iPod</title>
      <link>http://blog.prosight.me/blogs/475</link>
      <pubDate>2009-11-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候你的程序需要知道用户使用的设备是iPhone还是iPod。因为有些特性iPod是没有的，比如电话功能。方法很简单：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSString *deviceType = [UIDevice currentDevice].model;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如果你想得到一个本地化的字符串，可以使用以下命令：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSString *deviceType = [UIDevice currentDevice].modellocalizedModel;
NSLog(@&amp;ldquo;type: %@&amp;ldquo;, deviceType);
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>将图片保存在iPhone的相册中</title>
      <link>http://blog.prosight.me/blogs/479</link>
      <pubDate>2009-11-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候你的应用需要将应用中的图片保存到用户iPhone或者iTouch的相册中。 可以使用UIKit的这个类方法来完成。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
void UIImageWriteToSavedPhotosAlbum (
   UIImage  *image,
   id       completionTarget,
   SEL      completionSelector,
   void     *contextInfo
);
&lt;/pre&gt;

&lt;p&gt;image
要保存到用户设备中的图片&lt;/p&gt;

&lt;p&gt;completionTarget
当保存完成后，回调方法所在的对象&lt;/p&gt;

&lt;p&gt;completionSelector
当保存完成后，所调用的回调方法。 形式如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void) image: (UIImage *) image
    didFinishSavingWithError: (NSError *) error
    contextInfo: (void *) contextInfo;
&lt;/pre&gt;
contextInfo
可选的参数，保存了一个指向context数据的指针，它将传递给回调方法。&lt;/p&gt;

&lt;p&gt;比如你可以这样来写一个存贮照片的方法：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
// 要保存的图片
  UIImage *img = [UIImage imageNamed:@&amp;ldquo;ImageName.png&amp;rdquo;];&lt;/p&gt;

&lt;p&gt;// 保存图片到相册中
  UIImageWriteToSavedPhotosAlbum(img, self, @selector(image:didFinishSavingWithError:contextInfo:), nil);
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;回调方法看起来可能是这样：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error
             contextInfo:(void *)contextInfo
  {
    // Was there an error?
    if (error != NULL)
    {
      // Show error message&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;}
else  // No errors
{
  // Show message image successfully saved
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>设置statusBar的颜色</title>
      <link>http://blog.prosight.me/blogs/477</link>
      <pubDate>2009-11-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;status bar可以根据你的应用的需要设置为三种样式（UIStatusBarStyle）：&lt;/p&gt;

&lt;p&gt;UIStatusBarStyleBlackTranslucent 黑色透明
UIStatusBarStyleBlackOpaque       黑色不透明
UIStatusBarStyleDefault                默认白色&lt;/p&gt;

&lt;p&gt;可以在你的App Delegate文件中使用以下方法来设置你的UIStatusBarStyle
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[[UIApplication sharedApplication]
      setStatusBarStyle:UIStatusBarStyleBlackTranslucent animated:NO];&lt;br /&gt;
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>给Mac自带的字典安装汉语字典</title>
      <link>http://blog.prosight.me/blogs/470</link>
      <pubDate>2009-11-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Mac自带了一个字典程序，默认只有英英字典。 其实我们可以利用DictUnifier程序来添加StarDict的字典。 方法如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;下载Dict Unifier工具。 点击&lt;a href=&#34;http://code.google.com/p/mac-dictionary-kit/&#34;&gt;这里&lt;/a&gt;下载&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;下载StarDict字典。 可以从&lt;a href=&#34;http://zh.sourceforge.jp/projects/sfnet_stardict/releases/?fulllist=1&#34;&gt;这里&lt;/a&gt;下载所有的StarDict字典&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;打开Dict Unifier, 选择刚刚下载的StarDict字典文件，注意不要解压缩，保持文件后缀为bz2&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;点击convert按钮，开始转换，转换完成后，字典程序将自动启动。 你可以在预置中调整字典的顺序。 注意，当完成一个转换后，要关掉字典程序，否则下一个转换好的字典将覆盖前面一个&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;安装好后，选中你要翻译的单词，按住Command+Control+d就可以屏幕取词翻译。 这时候再按住Command+Control不放，鼠标移到其他单词上，又可以翻译其他单词。 是不是很方便。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>从URL载入并显示一个图片</title>
      <link>http://blog.prosight.me/blogs/468</link>
      <pubDate>2009-11-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;这个例子展示了如何从互联网远程下载一个图片并将它显示出来。&lt;/p&gt;

&lt;h2&gt;设定远程图片地址&lt;/h2&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSURL *url = [NSURL URLWithString: @&#34;http://domain.com/somepic.png&#34;];
&lt;/pre&gt;

&lt;h2&gt;从NSData中生成图片&lt;/h2&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
UIImage *image = [UIImage imageWithData: [NSData dataWithContentsOfURL:url]];
&lt;/pre&gt;

&lt;h2&gt;合成在一起&lt;/h2&gt;

&lt;p&gt;将前两步合在一起，并且将图片显示在界面上。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSURL *url = [NSURL URLWithString: @&amp;ldquo;http://domain.com/somepic.png&amp;rdquo;];
UIImage *image = [UIImage imageWithData: [NSData dataWithContentsOfURL:url]];
[self.view addSubview:[[UIImageView alloc] initWithImage:image]];
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何使用Objective-C的Category来缩放图片</title>
      <link>http://blog.prosight.me/blogs/466</link>
      <pubDate>2009-11-14 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;UIImage类并没有提供缩放图片需要用到的API，是不是觉得很吃惊？没关系，我们自己来添加一个。&lt;/p&gt;

&lt;h2&gt;定义缩放图片的Category&lt;/h2&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
//  UIImage+Scale.h
 
@interface UIImage (scale)
 
-(UIImage*)scaleToSize:(CGSize)size;
 
@end
&lt;/pre&gt;

&lt;h2&gt;实现这个Category的定义&lt;/h2&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
//  UIImage+Scale.h
 
#import &#34;UIImage+Scale.h&#34;
 
@implementation UIImage (scale)
 
-(UIImage*)scaleToSize:(CGSize)size
{
  // 创建一个bitmap的context
  // 并把它设置成为当前正在使用的context
  UIGraphicsBeginImageContext(size);
 
  // 绘制改变大小的图片
  [self drawInRect:CGRectMake(0, 0, size.width, size.height)];
 
  // 从当前context中创建一个改变大小后的图片
  UIImage* scaledImage = UIGraphicsGetImageFromCurrentImageContext();
 
  // 使当前的context出堆栈
  UIGraphicsEndImageContext();
 
  // 返回新的改变大小后的图片
  return scaledImage;
}
 
@end
&lt;/pre&gt;

&lt;h2&gt;如何使用&lt;/h2&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
// 创建图片
UIImage *image = [UIImage imageNamed:@&#34;myImage.png&#34;];
 
// 更改图片大小
UIImage *scaledImage = [image scaleToSize:CGSizeMake(25.0f, 35.0f)];
&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>NSLog中使用的格式符</title>
      <link>http://blog.prosight.me/blogs/464</link>
      <pubDate>2009-11-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;NSLog在输出的时候，可以使用很多C中的格式符号，与print一样。 具体含义如下
&lt;table style=&#34;border:1px soild #fff&#34; border=&#34;0&#34; cellspacing=&#34;0&#34; cellpadding=&#34;5&#34;&gt;&lt;caption class=&#34;tablecaption&#34;&gt;** **Format specifiers supported by the \u000a&lt;code&gt;NSString\u000a&lt;/code&gt; formatting methods and CFString formatting functions&lt;/caption&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th style=&#34;font-weight: bold&#34; align=&#34;left&#34; scope=&#34;col&#34;&gt;Specifier&lt;/th&gt;
&lt;th style=&#34;font-weight: bold&#34; align=&#34;left&#34; scope=&#34;col&#34;&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%@\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Objective-C object, printed as the string returned by \u000a&lt;code&gt;descriptionWithLocale:\u000a&lt;/code&gt; if available, or \u000a&lt;code&gt;description\u000a&lt;/code&gt; otherwise. Also works with \u000a&lt;code&gt;CFTypeRef\u000a&lt;/code&gt; objects, returning the result of the \u000a&lt;code&gt;CFCopyDescription\u000a&lt;/code&gt; function.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%%\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;\u000a&lt;code&gt;&#39;%&#39;\u000a&lt;/code&gt; character&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%d\u000a&lt;/code&gt;, \u000a&lt;code&gt;%D\u000a&lt;/code&gt;, \u000a&lt;code&gt;%i\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Signed 32-bit integer (\u000a&lt;code&gt;int\u000a&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%u\u000a&lt;/code&gt;, \u000a&lt;code&gt;%U\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unsigned 32-bit integer (\u000a&lt;code&gt;unsigned int\u000a&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%hi\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Signed 16-bit integer (\u000a&lt;code&gt;short\u000a&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%hu\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unsigned 16-bit integer (\u000a&lt;code&gt;unsigned short\u000a&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%qi\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Signed 64-bit integer (\u000a&lt;code&gt;long long\u000a&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%qu\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unsigned 64-bit integer (\u000a&lt;code&gt;unsigned long long\u000a&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%x\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unsigned 32-bit integer (\u000a&lt;code&gt;unsigned int\u000a&lt;/code&gt;), printed in hexadecimal using the digits 0–9 and lowercase a–f&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%X\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unsigned 32-bit integer (\u000a&lt;code&gt;unsigned int\u000a&lt;/code&gt;), printed in hexadecimal using the digits 0–9 and uppercase A–F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%qx\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unsigned 64-bit integer (\u000a&lt;code&gt;unsigned long long\u000a&lt;/code&gt;), printed in hexadecimal using the digits 0–9 and lowercase a–f&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%qX\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unsigned 64-bit integer (\u000a&lt;code&gt;unsigned long long\u000a&lt;/code&gt;), printed in hexadecimal using the digits 0–9 and uppercase A–F&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%o\u000a&lt;/code&gt;, \u000a&lt;code&gt;%O\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Unsigned 32-bit integer (\u000a&lt;code&gt;unsigned int\u000a&lt;/code&gt;), printed in octal&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%f\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;64-bit floating-point number (\u000a&lt;code&gt;double\u000a&lt;/code&gt;)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%e\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;64-bit floating-point number (\u000a&lt;code&gt;double\u000a&lt;/code&gt;), printed in scientific notation using a lowercase e to introduce the exponent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%E\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;64-bit floating-point number (\u000a&lt;code&gt;double\u000a&lt;/code&gt;), printed in scientific notation using an uppercase E to introduce the exponent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%g\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;64-bit floating-point number (\u000a&lt;code&gt;double\u000a&lt;/code&gt;), printed in the style of \u000a&lt;code&gt;%e\u000a&lt;/code&gt; if the exponent is less than –4 or greater than or equal to the precision, in the style of \u000a&lt;code&gt;%f\u000a&lt;/code&gt; otherwise&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%G\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;64-bit floating-point number (\u000a&lt;code&gt;double\u000a&lt;/code&gt;), printed in the style of \u000a&lt;code&gt;%E\u000a&lt;/code&gt; if the exponent is less than –4 or greater than or equal to the precision, in the style of \u000a&lt;code&gt;%f\u000a&lt;/code&gt; otherwise&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%c\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;8-bit unsigned character (\u000a&lt;code&gt;unsigned char\u000a&lt;/code&gt;), printed by \u000a&lt;code&gt;NSLog()\u000a&lt;/code&gt; as an ASCII character, or, if not an ASCII character, in the octal format \u000a&lt;code&gt;\ddd\u000a&lt;/code&gt; or the Unicode hexadecimal format \u000a&lt;code&gt;\udddd\u000a&lt;/code&gt;, where \u000a&lt;code&gt;d\u000a&lt;/code&gt; is a digit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%C\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;16-bit Unicode character (\u000a&lt;code&gt;unichar\u000a&lt;/code&gt;), printed by \u000a&lt;code&gt;NSLog()\u000a&lt;/code&gt; as an ASCII character, or, if not an ASCII character, in the octal format \u000a&lt;code&gt;\ddd\u000a&lt;/code&gt; or the Unicode hexadecimal format \u000a&lt;code&gt;\udddd\u000a&lt;/code&gt;, where \u000a&lt;code&gt;d\u000a&lt;/code&gt; is a digit&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%s\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Null-terminated array of 8-bit unsigned characters. \u000a&lt;code&gt;%s\u000a&lt;/code&gt; interprets its input in the system encoding rather than, for example, UTF-8.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%S\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Null-terminated array of 16-bit Unicode characters&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%p\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Void pointer (\u000a&lt;code&gt;void *\u000a&lt;/code&gt;), printed in hexadecimal with the digits 0–9 and lowercase a–f, with a leading \u000a&lt;code&gt;0x\u000a&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%L\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Length modifier specifying that a following \u000a&lt;code&gt;a\u000a&lt;/code&gt;, \u000a&lt;code&gt;A\u000a&lt;/code&gt;, \u000a&lt;code&gt;e\u000a&lt;/code&gt;, \u000a&lt;code&gt;E\u000a&lt;/code&gt;, \u000a&lt;code&gt;f\u000a&lt;/code&gt;, \u000a&lt;code&gt;F\u000a&lt;/code&gt;, \u000a&lt;code&gt;g\u000a&lt;/code&gt;, or \u000a&lt;code&gt;G\u000a&lt;/code&gt; conversion specifier applies to a \u000a&lt;code&gt;long double\u000a&lt;/code&gt; argument&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%a\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;64-bit floating-point number (\u000a&lt;code&gt;double\u000a&lt;/code&gt;), printed in scientific notation with a leading \u000a&lt;code&gt;0x\u000a&lt;/code&gt; and one hexadecimal digit before the decimal point using a lowercase \u000a&lt;code&gt;p\u000a&lt;/code&gt; to introduce the exponent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%A\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;64-bit floating-point number (\u000a&lt;code&gt;double\u000a&lt;/code&gt;), printed in scientific notation with a leading \u000a&lt;code&gt;0X\u000a&lt;/code&gt; and one hexadecimal digit before the decimal point using a uppercase \u000a&lt;code&gt;P\u000a&lt;/code&gt; to introduce the exponent&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%F\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;64-bit floating-point number (\u000a&lt;code&gt;double\u000a&lt;/code&gt;), printed in decimal notation&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%z\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Length modifier specifying that a following \u000a&lt;code&gt;d\u000a&lt;/code&gt;, \u000a&lt;code&gt;i\u000a&lt;/code&gt;, \u000a&lt;code&gt;o\u000a&lt;/code&gt;, \u000a&lt;code&gt;u\u000a&lt;/code&gt;, \u000a&lt;code&gt;x\u000a&lt;/code&gt;, or \u000a&lt;code&gt;X\u000a&lt;/code&gt; conversion specifier applies to a \u000a&lt;code&gt;size_t\u000a&lt;/code&gt; or the corresponding signed integer type argument&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%t\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Length modifier specifying that a following \u000a&lt;code&gt;d\u000a&lt;/code&gt;, \u000a&lt;code&gt;i\u000a&lt;/code&gt;, \u000a&lt;code&gt;o\u000a&lt;/code&gt;, \u000a&lt;code&gt;u\u000a&lt;/code&gt;, \u000a&lt;code&gt;x\u000a&lt;/code&gt;, or \u000a&lt;code&gt;X\u000a&lt;/code&gt; conversion specifier applies to a \u000a&lt;code&gt;ptrdiff_t\u000a&lt;/code&gt; or the corresponding unsigned integer type argument&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td scope=&#34;row&#34;&gt;\u000a&lt;code&gt;%j\u000a&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;Length modifier specifying that a following \u000a&lt;code&gt;d\u000a&lt;/code&gt;, \u000a&lt;code&gt;i\u000a&lt;/code&gt;, \u000a&lt;code&gt;o\u000a&lt;/code&gt;, \u000a&lt;code&gt;u\u000a&lt;/code&gt;, \u000a&lt;code&gt;x\u000a&lt;/code&gt;, or \u000a&lt;code&gt;X\u000a&lt;/code&gt; conversion specifier applies to a \u000a&lt;code&gt;intmax_t\u000a&lt;/code&gt; or \u000a&lt;code&gt;uintmax_t\u000a&lt;/code&gt; argument&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>UIVIew中center,bounds和frame的含义</title>
      <link>http://blog.prosight.me/blogs/461</link>
      <pubDate>2009-11-09 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一直没有很好的理解这两个的区别，今天Google了一下，有了比较清楚的认识。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;frame&lt;/strong&gt; - this is the property you most often use for normal iPhone applications. most controls will be laid out relative to the &amp;ldquo;containing&amp;rdquo; control so the frame.origin will directly correspond to where the control needs to display, and frame.size will determine how big to make the control.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;center&lt;/strong&gt; - this is the property you will likely focus on for sprite based games and animations where movement or scaling may occur. By default animation and rotation will be based on the center of the UIView. It rarely makes sense to try and manage such objects by the frame property.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;bounds&lt;/strong&gt; - this property is not a positioning property, but defines the drawable area of the UIView &amp;ldquo;relative&amp;rdquo; to the frame. By default this property is usually (0,0,width,height). Changing this property will allow you to draw outside of the frame or restrict drawing to a smaller area within the frame. A good discussion of this can be found at the link below. It is uncommon for this property to be manipulated unless there is specific need to adjust the drawing region. The only exception is that most programs will use the [[UIScreen mainScreen] bounds] on startup to determine the visible area for the application and setup their initial UIView&amp;rsquo;s frame accordingly.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Objective-C 私有方法</title>
      <link>http://blog.prosight.me/blogs/459</link>
      <pubDate>2009-11-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在面向对象的开发中，一个很重要的原则就是不要暴露不需要暴露的东西。 在Objective-C中，在头文件中你只能声明类方法和实例方法，这意味着你所有的方法都要暴露在外边。&lt;/p&gt;

&lt;p&gt;其实在Objective-C中也可以来声明一个私有方法，这个方法只有本类可见，其他任何类都看不到，即使是继承于这个类的其他子类也无法看到。 方法也比较简单。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
@interface Controller : NSObject
{
    NSString *something;
}
 
+ (void)thisIsAStaticMethod;
- (void)thisIsAnInstanceMethod;
 
@end
 
@interface Controller (Private)
 
- (void)thisIsAPrivateMethod;
 
@end
&lt;/pre&gt;

&lt;p&gt;只要在头文件或者实现类里面添加一个interface，这个Interface的名字跟头文件里面的一样，只是后面加上了（Private）。现在在这个interface中声明的方法就是私有方法了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>NSArray 和 KVC</title>
      <link>http://blog.prosight.me/blogs/455</link>
      <pubDate>2009-11-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;a href=&#34;http://theocacao.com/document.page/165&#34; target=&#34;_blank&#34;&gt;Theocoacao&lt;/a&gt;有篇不错的介绍NSArray和KVC的文章，我给粗略翻译了一下。&lt;/p&gt;

&lt;p&gt;NSArray的-valueForKey: 有一个不是很显著的特性. 你可以使用它返回一个由tree对象包装的值对象的数组。这句话可能不是很容易理解，看下面的例子就清楚了。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSMutableArray * tree = [NSMutableArray array];
NSDictionary   * p = nil;   // parent
NSDictionary   * c = nil;   // child
NSNumber       * n = nil;   // value
int i;&lt;/p&gt;

&lt;p&gt;for ( i = 0; i &amp;lt; 10; i++ )
{
n = [NSNumber numberWithInt: i];
c = [NSDictionary dictionaryWithObject:n forKey: @&amp;ldquo;someKey&amp;rdquo;];
p = [NSDictionary dictionaryWithObject: c forKey: @&amp;ldquo;storage&amp;rdquo;];
[tree addObject: p];
}&lt;/p&gt;

&lt;p&gt;NSLog (@&amp;ldquo;%@&amp;rdquo;, tree);
// here&amp;rsquo;s the important part!
NSArray * justValues;
justValues = [tree valueForKeyPath: @&amp;ldquo;storage.someKey&amp;rdquo;];
NSLog (@&amp;ldquo;%@&amp;rdquo;, justValues);
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;第一个NSLog输出的内容t:&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSLog (@&#34;%@&#34;, tree);
(
{storage = {someKey = 0; }; },
{storage = {someKey = 1; }; },
{storage = {someKey = 2; }; },
{storage = {someKey = 3; }; },
{storage = {someKey = 4; }; },
{storage = {someKey = 5; }; },
{storage = {someKey = 6; }; },
{storage = {someKey = 7; }; },
{storage = {someKey = 8; }; },
{storage = {someKey = 9; }; }
)
&lt;/pre&gt;

&lt;p&gt;第二个NSLog 返回一个数组的值，这个数组是由封装它的tree对象的 @&amp;ldquo;storage.someKey&amp;rdquo;:这个keypath提供的：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSArray * justValues;
justValues = [tree valueForKeyPath: @&#34;storage.someKey&#34;];
NSLog (@&#34;%@&#34;, justValues);
(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
&lt;/pre&gt;

&lt;p&gt;我发现它真的非常方便，当你使用Core Data要排序一个managed objects对象里面的一个数组的时候。 你可以用一个attribute就把它里面数组的值列出来。.&lt;/p&gt;
</description>
    </item>
    <item>
      <title>把你的程序限定到10.6和64位上</title>
      <link>http://blog.prosight.me/blogs/440</link>
      <pubDate>2009-11-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果你已经在使用Snow Leopard和XCode 3.2了，你编译了一个64位的程序。 但是你发现他们可能无法在Leopard中很好运行，可能有些地方会出现问题。&lt;/p&gt;

&lt;p&gt;如果你想提供一个要求运行在10.6以后系统并且支持64位的程序的话，可以在你的应用的Info.plist中，在最后一个&lt;/dict&gt;前加入以下内容：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;key&gt;LSMinimumSystemVersionByArchitecture&lt;/key&gt;
&lt;dict&gt;
    &lt;key&gt;x86_64&lt;/key&gt;
    &lt;string&gt;10.6.0&lt;/string&gt;
&lt;/dict&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这个方法是被Apple批准和支持的，可以合法的使用。&lt;/p&gt;

&lt;p&gt;具体的LSMinimumSystemVersionByArchitecture文档可以参考&lt;a href=&#34;http://developer.apple.com/mac/library/documentation/General/Reference/InfoPlistKeyReference/Articles/LaunchServicesKeys.html#//apple_ref/doc/uid/TP40009250-113253-BAJDHACB&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Cocoa程序支持多国语言环境</title>
      <link>http://blog.prosight.me/blogs/445</link>
      <pubDate>2009-11-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;当你的Cocoa程序面向多个不同语言国家的用户时候，通常需要配置你的应用的多国语言环境，而不是单独编译几个不同的语言版本。&lt;/p&gt;

&lt;h3&gt;1. nib/xib多国语言支持&lt;/h3&gt;

&lt;p&gt;nib或xib文件，支持多国语言很简单，只需在你的nib/xib文件右键点击，选择Get Info菜单。 点击最下面的Add Localization按钮
[caption id=&amp;ldquo;attachment_446&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo; caption=&amp;ldquo;xib添加多国语言支持&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/11/1.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/11/1-300x252.png&#34; alt=&#34;xib添加多国语言支持&#34; title=&#34;xib添加多国语言支持&#34; width=&#34;300&#34; height=&#34;252&#34; class=&#34;size-medium wp-image-446&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;在弹出的窗口中输入你要支持的语言编号， 如zh_CN（简体中文）、zh_TW 或者 zh_HK（繁体中文），其他几个常用的国家语言可以不是编号而是国家语言名称，如：
日语：Japanese
德语：German
西班牙语：Spanish
法语：French&lt;/p&gt;

&lt;p&gt;之后编辑nib/xib文件中的文字，图片后保存就可以了。&lt;/p&gt;

&lt;h3&gt;2. 程序中引用多国语言&lt;/h3&gt;

&lt;p&gt;建立Localizable.strings文件&lt;/p&gt;

&lt;p&gt;在项目中点右键，选择Add-&amp;gt;New File
在列表中选择Strings File，也可以取别的名字，比如MyApp.strings&lt;/p&gt;

&lt;p&gt;这个文件如果包含非拉丁字符的话，一定要保存为utf-8格式，如上图中的File Encoding中的设置。&lt;/p&gt;

&lt;p&gt;.strings文件的内容可以是标准的plist格式，也可以是旧的列表格式：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;
&lt;!DOCTYPE plist PUBLIC &#34;-//Apple Computer//DTD PLIST 1.0//EN&#34; &#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd&#34;&gt;
&lt;plist version=&#34;1.0&#34;&gt;
&lt;dict&gt;
    &lt;key&gt;mykey&lt;/key&gt;
    &lt;string&gt;myvalue&lt;/string&gt;
        ….
&lt;/dict&gt;
&lt;/plist&gt;
&lt;/pre&gt;
字符串如果要换行的话，直接按回车换行，不要写成n这种形式。

或者直接使用旧式的列表格式：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&#34;mykey&#34; = &#34;myvalue&#34;;
…
&lt;/pre&gt;
注意每行后面加分号。

如果你使用的是Localizable.strings，那么你在程序中可以这样获取字符串：

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSLocalizedString(@&#34;mykey&#34;, nil)
 &lt;/pre&gt;

&lt;p&gt;如果你使用的是自定义名字的.strings，比如MyApp.strings，那么你在程序中可以这样获取字符串：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSLocalizedStringFromTable (@&#34;mykey&#34;,@&#34;MyApp&#34;, nil)
 &lt;/pre&gt;

&lt;p&gt;这样即可获取到&amp;rdquo;mykey&amp;rdquo;这个字符串，可以是任何语言。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>CentOS 5.3 OpenVZ安装指南</title>
      <link>http://blog.prosight.me/blogs/435</link>
      <pubDate>2009-10-27 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;安装宿主系统CentOS 5.3，分区的时候，要分一个/vz的ext3分区用来存放OpenVZ的template和Virtual Private Servers。 官方的建议是：
&lt;blockquote&gt;
/                2-4G
/swap        2倍物理内存
/vz             剩余的磁盘空间
&lt;/blockquote&gt;&lt;/li&gt;
&lt;li&gt;关掉FIrewall和SELinux&lt;/li&gt;
&lt;li&gt;安装OpenVZ
a) 从http://wiki.openvz.org/Download/kernel下载你操作系统对应的内核版本。 我这里用的是ovzkernel-2.6.18-128.2.1.el5.028stab064.7.i686.rpm
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
rpm -ihv ovzkernel-2.6.18-128.2.1.el5.028stab064.7.i686.rpm
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;b) 编辑GRUB Loader
/boot/grub/grub.conf
确保grub.conf文件的内容为：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
title OpenVZ (2.6.18-128.2.1.el5.028stab064.7)
        root (hd0,0)
        kernel /boot/vmlinuz-2.6.18-128.2.1.el5.028stab064.7 ro root=LABEL=/
        initrd /boot/initrd-2.6.18-128.2.1.el5.028stab064.7.img
&lt;/pre&gt;
c) 设置sysctl参数
/etc/sysctl.conf
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;On Hardware Node we generally need&lt;/h1&gt;

&lt;h1&gt;packet forwarding enabled and proxy arp disabled&lt;/h1&gt;

&lt;p&gt;net.ipv4.ip_forward = 1
net.ipv4.conf.default.proxy_arp = 0&lt;/p&gt;

&lt;h1&gt;Enables source route verification&lt;/h1&gt;

&lt;p&gt;net.ipv4.conf.all.rp_filter = 1&lt;/p&gt;

&lt;h1&gt;Enables the magic-sysrq key&lt;/h1&gt;

&lt;p&gt;kernel.sysrq = 1&lt;/p&gt;

&lt;h1&gt;TCP Explict Congestion Notification&lt;/h1&gt;

&lt;p&gt;#net.ipv4.tcp_ecn = 0&lt;/p&gt;

&lt;h1&gt;we do not want all our interfaces to send redirects&lt;/h1&gt;

&lt;p&gt;net.ipv4.conf.default.send_redirects = 1
net.ipv4.conf.all.send_redirects = 0
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;使用下面的命令，使设置生效，之后重启系统。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;sysctl -p&lt;/h1&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;c) 安装客户端工具
&lt;ul&gt;
    &lt;li&gt;vzctl: 这个工具是用来操作VPS的，如创建，销毁，开始，关闭和设置参数&lt;/li&gt;
    &lt;li&gt;vzquota: 用于设定VPS的 quota&lt;/li&gt;
    &lt;li&gt;vzpkg:这个工具用来管理 OpenVZ的 templates.&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
rpm -Uhv vzyum-2.4.0-11.noarch.rpm
rpm -Uhv vzquota-3.0.12-1.i386.rpm
rpm -Uhv vzctl-3.0.23-1.i386.rpm
rpm -Uhv vzpkg-2.7.0-18.noarch.rpm
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;然后你就可以启动OpenVZ了
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/etc/init.d/vz start
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;3.安装OpenVZ template
在这里下载你所需要的模板http://openvz.org/download/template/
先安装模板metadata，再使用vzpkgcache生成cache&lt;/p&gt;

&lt;p&gt;或者直接在http://openvz.org/download/template/cache/下载已经cache过的模板，比如centos-5-x86_64.tar.gz ，不用解压，直接把它放到/vz/template/cache中。 然后使用下面的命令来生成虚机
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vzctl create 101 &amp;ndash;ostemplate centos-5-x86 &amp;ndash;config vps.basic
&lt;/pre&gt;
create后面的数字是这个VPS的ID，每个VPS都要有一个唯一的ID来做标示。 可以使用ip的最后一位来做标示， 这样方便记忆。&lt;/p&gt;

&lt;p&gt;VPS创建后，会在/vz/root/vpsid/生成一个目录作为它的私有空间.
为了便于设置，不必每个VPS都指定参数，创建的时候跟上了一个&amp;ndash;config参数用于指定VPS的设置参数。 这些配置文件在/etc/sysconfig/vz-script中。 上面使用的就是/etc/sysconfig/vz-scripts/ve-vps.basic.conf-sample这个文件&lt;/p&gt;

&lt;p&gt;你可以通过编辑/etc/sysconfig/vz文件的内容，来预先指定模板和配置文件，如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
DEF_OSTEMPLATE=&amp;ldquo;centos-5-x86&amp;rdquo;
CONFIGFILE=&amp;ldquo;vps.basic&amp;rdquo;
&lt;/pre&gt;
这样就可以通过下面的命令快速建立VPS
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;vzctl create 101&lt;/h1&gt;

&lt;p&gt;Creating VPS private area: /vz/private/101
VPS is mounted
Postcreate action done
VPS is unmounted
VPS private area was created
&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;设置VPS
创建虚机后，使用下面命令来设置虚机的参数
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vzctl set 101 &amp;ndash;hostname test101.my.org &amp;ndash;save  #设置主机名
vzctl set 101 &amp;ndash;nameserver 202.96.209.5 &amp;ndash;save  #设置DNS
vzctl set 101 &amp;ndash;ipadd 172.1.1.101 &amp;ndash;save  #设置IP
vzctl set 101 &amp;ndash;userpasswd username:password #设置帐号
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;启动和终止
a) 启动
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vzctl start 101
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;b)终止
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vzctl stop 101
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;c)查看状态
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vzctl status 101
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;d)查看所有虚机的资源占用情况
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cat /proc/vz/veinfo
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;e) 查看所有虚机的状态
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vzlist -a
&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;删除VPS
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vzctl destroy 101
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>针对SQLite3为Cocoa 和 Cocoa Touch设计的持久化对象</title>
      <link>http://blog.prosight.me/blogs/432</link>
      <pubDate>2009-10-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;向大家推荐一款很不错的轻量级的Cocoa持久化对象 &amp;ndash; &lt;a href=&#34;http://code.google.com/p/sqlitepersistentobjects/&#34; target =&#34;_blank&#34;&gt;sqlitepersistentobjects&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;使用起来跟ActiveRecord很类似，也非常简单
将下载的zip中的所有文件加入你的项目中，然后链接libsqlite3.dylib，之后你就可以声明实体类了。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &lt;foundation/foundation.h&gt;
#import &amp;ldquo;SQLitePersistentObject.h&amp;rdquo;&lt;/p&gt;

&lt;p&gt;@interface PersistablePerson : SQLitePersistentObject {
 NSString *lastName;
 NSString *firstName;
}
@property (nonatomic, retain) NSString * lastName;
@property (nonatomic, retain) NSString * firstName;
@end
&lt;/pre&gt;
然后你可以这样使用它：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
PersistablePerson *person = [[PersistablePerson alloc] init];
person.firstName = @&amp;ldquo;Joe&amp;rdquo;;
person.lastName = @&amp;ldquo;Smith&amp;rdquo;;
&lt;/pre&gt;
当你打算保存的时候：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[person save];
&lt;/pre&gt;
是不是很简单&lt;/p&gt;
</description>
    </item>
    <item>
      <title>SQLite3 简要使用指南</title>
      <link>http://blog.prosight.me/blogs/427</link>
      <pubDate>2009-10-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;OS X自从10.4后把SQLite这套相当出名的数据库软件，放进了作业系统工具集里。OS X包装的是第三版的SQLite，又称SQLite3。这套软件有几个特色：
&lt;ul&gt;
    &lt;li&gt;支援大多数的SQL指令（下面会简单介绍）。&lt;/li&gt;
    &lt;li&gt;一个档案就是一个数据库。不需要安装数据库服务器软件。&lt;/li&gt;
    &lt;li&gt;完整的Unicode支援（因此没有跨语系的问题）。&lt;/li&gt;
    &lt;li&gt;速度很快。&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;

&lt;p&gt;目前在OS X 10.4里，SQLite是以/usr/bin/sqlite3的形式包装，也就说这是一个命令列工具，必须先从终端机（Terminal.app或其他程序）进入shell之后才能使用。网络上有一些息协助使用SQLite的视觉化工具，但似乎都没有像CocoaMySQL（配合MySQL数据库使用）那般好用。或许随时有惊喜也未可知，以下仅介绍命令列的操作方式。&lt;/p&gt;

&lt;p&gt;以下我们就建立数据库、建立资料表及索引、新增资料、查询资料、更改资料、移除资料、sqlite3命令列选项等几个项目做简单的介绍。&lt;/p&gt;

&lt;h3&gt;建立数据库档案&lt;/h3&gt;

&lt;p&gt;用sqlite3建立数据库的方法很简单，只要在shell下键入（以下$符号为shell提示号，请勿键入）：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sqlite3 foo.db
&lt;/pre&gt;
如果目录下没有foo.db，sqlite3就会建立这个数据库。sqlite3并没有强制数据库档名要怎么取。&lt;/p&gt;

&lt;p&gt;在sqlite3提示列下操作&lt;/p&gt;

&lt;p&gt;进入了sqlite3之后，会看到以下文字：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
SQLite version 3.1.3
Enter &#34;.help&#34; for instructions
sqlite&gt; 
&lt;/pre&gt;
这时如果使用.help可以取得求助，.quit则是离开（请注意：不是quit）

### SQL的指令格式

所以的SQL指令都是以分号（;）结尾的。如果遇到两个减号（--）则代表注解，sqlite3会略过去。

**建立资料表**

假设我们要建一个名叫film的资料表，只要键入以下指令就可以了：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
create table film(title, length, year, starring);
&lt;/pre&gt;
这样我们就建立了一个名叫film的资料表，里面有name、length、year、starring四个字段。

这个create table指令的语法为：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
create table table_name(field1, field2, field3, ...);
&lt;/pre&gt;
table_name是资料表的名称，fieldx则是字段的名字。sqlite3与许多SQL数据库软件不同的是，它不在乎字段属于哪一种资料型态：sqlite3的字段可以储存任何东西：文字、数字、大量文字（blub），它会在适时自动转换。

**建立索引**

如果资料表有相当多的资料，我们便会建立索引来加快速度。好比说：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
create index film_title_index on film(title);
&lt;/pre&gt;
意思是针对film资料表的name字段，建立一个名叫film_name_index的索引。这个指令的语法为
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
create index index_name on table_name(field_to_be_indexed);
&lt;/pre&gt;
一旦建立了索引，sqlite3会在针对该字段作查询时，自动使用该索引。这一切的操作都是在幕后自动发生的，无须使用者特别指令。

**加入一笔资料**

接下来我们要加入资料了，加入的方法为使用insert into指令，语法为：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
insert into table_name values(data1, data2, data3, ...);
&lt;/pre&gt;
例如我们可以加入

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
insert into film values (&#39;Silence of the Lambs, The&#39;, 118, 1991, &#39;Jodie Foster&#39;);
insert into film values (&#39;Contact&#39;, 153, 1997, &#39;Jodie Foster&#39;);
insert into film values (&#39;Crouching Tiger, Hidden Dragon&#39;, 120, 2000, &#39;Yun-Fat Chow&#39;);
insert into film values (&#39;Hours, The&#39;, 114, 2002, &#39;Nicole Kidman&#39;);
&lt;/pre&gt;
如果该字段没有资料，我们可以填NULL。



**查询资料**

讲到这里，我们终于要开始介绍SQL最强大的select指令了。我们首先简单介绍select的基本句型：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select columns from table_name where expression;
&lt;/pre&gt;
最常见的用法，当然是倒出所有数据库的内容：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select * from film;
&lt;/pre&gt;
如果资料太多了，我们或许会想限制笔数：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select * from film limit 10;
&lt;/pre&gt;
或是照着电影年份来排列：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select * from film order by year limit 10;
&lt;/pre&gt;
或是年份比较近的电影先列出来：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select * from film order by year desc limit 10;
&lt;/pre&gt;
或是我们只想看电影名称跟年份：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select title, year from film order by year desc limit 10;
&lt;/pre&gt;
查所有茱蒂佛斯特演过的电影：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select * from film where starring=&#39;Jodie Foster&#39;;
&lt;/pre&gt;
查所有演员名字开头叫茱蒂的电影(&#39;%&#39; 符号便是 SQL 的万用字符）：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select * from film where starring like &#39;Jodie%&#39;;
&lt;/pre&gt;
查所有演员名字以茱蒂开头、年份晚于1985年、年份晚的优先列出、最多十笔，只列出电影名称和年份：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select title, year from film where starring like &#39;Jodie%&#39; and year &gt;= 1985 order by year desc limit 10;
&lt;/pre&gt;
有时候我们只想知道数据库一共有多少笔资料：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select count(*) from film;
&lt;/pre&gt;
有时候我们只想知道1985年以后的电影有几部：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
select count(*) from film where year &gt;= 1985;
&lt;/pre&gt;
（进一步的各种组合，要去看SQL专书，不过你大概已经知道SQL为什么这么流行了：这种语言允许你将各种查询条件组合在一起──而我们还没提到「跨数据库的联合查询」呢！）

**如何更改或删除资料**

了解select的用法非常重要，因为要在sqlite更改或删除一笔资料，也是靠同样的语法。

例如有一笔资料的名字打错了：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
update film set starring=&#39;Jodie Foster&#39; where starring=&#39;Jodee Foster&#39;;
&lt;/pre&gt;
就会把主角字段里，被打成&#39;Jodee Foster&#39;的那笔（或多笔）资料，改回成Jodie Foster。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
delete from film where year &lt; 1970;
&lt;/pre&gt;
就会删除所有年代早于1970年（不含）的电影了。

**其他sqlite的特别用法**

sqlite可以在shell底下直接执行命令：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sqlite3 film.db &#34;select * from film;&#34;
&lt;/pre&gt;

&lt;p&gt;输出 HTML 表格：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sqlite3 -html film.db &amp;ldquo;select * from film;&amp;rdquo;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;将数据库「倒出来」：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sqlite3 film.db &amp;ldquo;.dump&amp;rdquo; &amp;gt; output.sql
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;利用输出的资料，建立一个一模一样的数据库（加上以上指令，就是标准的SQL数据库备份了）：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sqlite3 film.db &amp;lt; output.sql
&lt;/pre&gt;
在大量插入资料时，你可能会需要先打这个指令：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
begin;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;插入完资料后要记得打这个指令，资料才会写进数据库中：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
commit;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;小结&lt;/p&gt;

&lt;p&gt;以上我们介绍了SQLite这套数据库系统的用法。事实上OS X也有诸于SQLiteManagerX这类的图形接口程序，可以便利数据库的操作。不过万变不离其宗，了解SQL指令操作，SQLite与其各家变种就很容易上手了。&lt;/p&gt;

&lt;p&gt;至于为什么要写这篇教学呢？除了因为OS X Tiger大量使用SQLite之外（例如：Safari的RSS reader，就是把文章存在SQLite数据库里！你可以开开看~/Library/Syndication/Database3这个档案，看看里面有什么料），OpenVanilla从0.7.2开始，也引进了以SQLite为基础的词汇管理工具，以及全字库的注音输入法。因为使用SQLite，这两个模块不管数据库内有多少笔资料，都可以做到「瞬间启动」以及相当快速的查询回应。&lt;/p&gt;

&lt;p&gt;将一套方便好用的数据库软件包进OS X中，当然也算是Apple相当相当聪明的选择。再勤劳一点的朋友也许已经开始想拿SQLite来记录各种东西（像我们其中就有一人写了个程序，自动记录电池状态，写进SQLite数据库中再做统计&amp;hellip;&amp;hellip;）了。想像空间可说相当宽广。&lt;/p&gt;

&lt;p&gt;目前支援SQLite的程序语言，你能想到的大概都有了。这套数据库2005年还赢得了美国O&amp;rsquo;Reilly Open Source Conference的最佳开放源代码软件奖，奖评是「有什么东西能让Perl, Python, PHP, Ruby语言团结一致地支援的？就是SQLite」。由此可见SQLite的地位了。而SQLite程序非常小，更是少数打 &amp;ldquo;gcc -o sqlite3 *&amp;ldquo;，不需任何特殊设定就能跨平台编译的程序。小而省，小而美，SQLite连网站都不多赘言，直指SQL语法精要及API使用方法，原作者大概也可以算是某种程序设计之道（Tao of Programming）里所说的至人了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone开发中使用的特殊URL</title>
      <link>http://blog.prosight.me/blogs/420</link>
      <pubDate>2009-10-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在iPhone中，可以直接用UIApp打开URL地址。如下所示：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[ UIApp openURL: [ NSURL URLWithString:@&amp;ldquo;http://www.apple.com&amp;rdquo; ] ];
&lt;/pre&gt;
或者：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[ UIApp openURL: [ NSURL URLWithString:@&amp;ldquo;mailto:apple@mac.com?Subject=hello&amp;rdquo; ] ];
 &lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;与此同时，iPhone还包含一些其他除了http://或者mailto:之外的URL：
sms:// 可以调用短信程序
tel:// 可以拨打电话
itms:// 可以打开MobileStore.app
audio-player-event:// 可以打开iPod
audio-player-event://?uicmd=show-purchased-playlist 可以打开iPod播放列表
video-player-event:// 可以打开iPod中的视频&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用UITextFieldDelegate来隐藏键盘</title>
      <link>http://blog.prosight.me/blogs/422</link>
      <pubDate>2009-10-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在iPhone界面上，时常会需要当用户输入完内容后，隐藏键盘。 当然有很多方法，今天只介绍使用UITextFieldDelegate这个协议实现隐藏键盘。&lt;/p&gt;

&lt;p&gt;其实很简单， 需要三步：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在你的控制器类中，加入UITextFieldDelegate这个协议
如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
@interface AddItemViewController : UIViewController &lt;UITextFieldDelegate&gt;
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;在使用了UITextFieldDelegate协议的控制器类的实现中，加入- (BOOL)textFieldShouldReturn:方法。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#pragma mark UITextFieldDelegate implementation&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(BOOL)textFieldShouldReturn:(UITextField *)textField {&lt;/p&gt;

&lt;p&gt;[textField resignFirstResponder];
return YES;
}
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将xib文件中的TextField控件的delegate变量指向到之前使用UITextFieldDelegate协议的那个控制器类
&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/10/1.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/10/1.png&#34; alt=&#34;delegate IBOutlet变量&#34; title=&#34;delegate IBOutlet变量&#34; width=&#34;347&#34; height=&#34;291&#34; class=&#34;alignnone size-full wp-image-423&#34; /&gt;&lt;/a&gt;
将TextField的delegate IBOutlet变量右键链接到前面的控制器类的实例上。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;或者使用代码方式，指定相关TextField的delegate变量。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)viewDidLoad {
    [super viewDidLoad];
    itemNameField.delegate = self;
    priceField.delegate = self;
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;第三步很容易忽略，之前就因为忘记指定delegate变量，导致点击键盘的return健，键盘死活不隐藏。 起初以为是方法名字写错了，或者代理的类的名字些错了，后来直接从SDK中拷贝一边也是一样。 - (BOOL)textFieldShouldReturn:这个方法死活就是不被执行，后来经过仔细排查，才找到这个问题所在。&lt;/p&gt;

&lt;p&gt;实现了这三步后，用户就可以点击键盘上的“Return&amp;rdquo;键来隐藏键盘。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>为什么要在addsubview:一个view对象后，release它</title>
      <link>http://blog.prosight.me/blogs/425</link>
      <pubDate>2009-10-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;先看代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
IMGView *imgView = [[IMGView alloc] initWithFrame:CGRectMake(10, 0, 300, 300)];
[self.view addSubview:imgView];
[imgView release];
&lt;/pre&gt;
为什么imgView要release呢？可能很多人跟我一样，之前不是很清楚。 我们逐行分析一下&lt;/p&gt;

&lt;p&gt;第一行，alloc一次，imgView对象retainCount为1，
第二行，addSubview一次，此方法会把你传过去的对象retain一次，那么此时它的retainCount为2。self.view变为它的第二个待有者。参考：The receiver retains view. If you use removeFromSuperview to remove view from the view hierarchy, view is released.
第三行，调用release方法，此处释放对imgView的所有权，retainCount减1。&lt;/p&gt;

&lt;p&gt;到语言句尾imgView的所有者只剩下self.view，并且它的retainCount仅为1。内存管理第一铁则，谁retain(alloc,copy)谁release(autorelease)。上述的做法也是为了符合这一准则。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>IBOutlet变量的生命周期</title>
      <link>http://blog.prosight.me/blogs/415</link>
      <pubDate>2009-10-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天遇到一个问题困扰了很久。 代码如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
FileOverviewViewController *fileOverviewViewController = [[FileOverviewViewController alloc] initWithNibName:@&amp;ldquo;FileOverviewView&amp;rdquo; bundle:nil];
// AAAAA
[self.navigationController pushViewController:fileOverviewViewController animated:YES];
// BBBBBB
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如果你有这个Controller中的view里面有IBOutlet的变量，如果你在A的地方进行赋值或者其他操作的话，界面将不会有任何更新，那些IBoutlet变量的值都为NULL， 如果在B处设置就可以正常显示了。&lt;/p&gt;

&lt;p&gt;结论： 如果你使用navigation Controller的话， 一定要在push了这个ViewController之后再操作这个ViewController中的IBOutlet变量，否则这个变量会因为不在作用范围内而无法操作。&lt;/p&gt;

&lt;p&gt;扩展开来也就是说只有当一个ViewController被载入处于活动状态的时候，这个ViewController中的IBOutlet变量才能正常使用，否则都会因为不在作用范围内而无法正常使用的&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用NSRange获取范围</title>
      <link>http://blog.prosight.me/blogs/412</link>
      <pubDate>2009-10-19 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;如果你要获取一个字符串或者一个数组中的一个子集，那么使用NSRange会很方便的定义这个子集。
NSRange定义
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Declaration: typedef struct _NSRange {
   NSUInteger location;
   NSUInteger length;
} NSRange;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;创建NSRange的方法定义
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Declaration: NSRange NSMakeRange (
   NSUInteger loc,
   NSUInteger len
);
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;例如获取一个数组的一个子集：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
        NSRange range = NSMakeRange(0, 5);
    NSArray *subArray = [self.states subarrayWithRange:range];
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这样就获得了这个数组中0开始的5个元素的子集。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>生成随机数</title>
      <link>http://blog.prosight.me/blogs/409</link>
      <pubDate>2009-10-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候我们需要在程序中生成随机数。 但是Objective-C并没有提供相关函数，好在C提供了rand(), srand(), random(), srandom()， arc4random()几个函数
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
// Get random number between 0 and 500
int x = arc4random() % 100;&lt;/p&gt;

&lt;p&gt;// Get random number between 500 and 1000
int y =  (arc4random() % 501) + 500);
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;arc4random()的好处是不用seed&lt;/p&gt;
</description>
    </item>
    <item>
      <title>给TableView添加背景</title>
      <link>http://blog.prosight.me/blogs/406</link>
      <pubDate>2009-10-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;iPhone SDK提供了默认的几个TableView样式，但是如果想提供更个性化的样式就需要自己定义。 比如添加背景&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;&#34; src=&#34;http://iPhoneDeveloperTips.com/wp-content/uploads/2009/10/tablecell2.png&#34; title=&#34;tableView&#34; class=&#34;alignnone&#34; width=&#34;250&#34; height=&#34;365&#34; /&gt;&lt;/p&gt;

&lt;p&gt;如上图的样子。 其实自定义table view的样子很简单，无非就是把table view和table view cell的背景变成透明的，然后在指定视图和cell的背景图片（当然，也可以指定table view的背景图片）&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
@interface MainViewController : UIViewController &lt;UITableViewDelegate, UITableViewDataSource&gt;
{
  UITableView *theTableView;
}
&lt;/pre&gt;
先建立Controller，注意是继承自UIViewController而不是UITableViewController

实现类
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (id)init
{
  if (self = [super init]) 
  {
    self.view = [[[UIView alloc] initWithFrame:[[UIScreen mainScreen] applicationFrame]] autorelease];
 
    // Setup the background
    UIImageView *background = [[UIImageView alloc] initWithImage:[UIImage imageNamed:@&#34;background.png&#34;]];
    [self.view addSubview:background];
    [background release];
 
    // Create table view
    theTableView = [[UITableView alloc] initWithFrame:CGRectMake(0, 11, 320, 460) style: UITableViewStylePlain];
    [theTableView setDelegate:self];
    [theTableView setDataSource:self];
 
    // This should be set to work with the image height
    [theTableView setRowHeight:68];
 
    // Transparent, so we can see the background
    [theTableView setBackgroundColor:[UIColor clearColor]];
    [theTableView setSeparatorStyle:UITableViewCellSeparatorStyleNone];
    [theTableView setIndicatorStyle:UIScrollViewIndicatorStyleWhite];
 
    [self.view addSubview:theTableView];
 
  }
  return self;
}
&lt;/pre&gt;
代码中的注释已经很清楚了。 先设置视图的背景，再设定table view的背景

再看另外一断代码，设置了cell的背景，注意，这里面使用了自定义的cell类CustomCell
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath 
{
    CustomCell *cell= [[[CustomCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:nil] autorelease];
    
    // Default to no selected style and not selected
    cell.selectionStyle = UITableViewCellSelectionStyleNone;
    
    // Set the image for the cell
    [cell setTheImage:[UIImage imageNamed:[NSString stringWithFormat:@&#34;Arrows%d.png&#34;, indexPath.row + 1]]];
    
    return cell;
}
&lt;/pre&gt;

&lt;p&gt;我们再看看如何定义自定义的cell
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &lt;UIKit/UIKit.h&gt;&lt;/p&gt;

&lt;p&gt;@interface CustomCell : UITableViewCell
{
  UIImageView *image;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(void) setTheImage:(UIImage *)icon;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@end
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;再看实现类
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &amp;ldquo;CustomCell.h&amp;rdquo;&lt;/p&gt;

&lt;p&gt;@implementation CustomCell&lt;/p&gt;

&lt;p&gt;/&lt;em&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
*
*&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/em&gt;/
-(id) initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier
{
    if (self = [super initWithStyle:style reuseIdentifier:reuseIdentifier])
  {
    // Cells are transparent
    [self.contentView setBackgroundColor:[UIColor clearColor]];
    }&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return self;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;/&lt;em&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
*
*&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/em&gt;/
- (void) setTheImage:(UIImage *) icon
{&lt;br /&gt;
  // Alloc and set the frame
  image = [[UIImageView alloc] initWithImage:icon];
  image.frame = CGRectMake(0, 0, 286, 68);&lt;/p&gt;

&lt;p&gt;// Add subview
  [self.contentView addSubview:image];&lt;br /&gt;
}&lt;/p&gt;

&lt;p&gt;/&lt;em&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
*
*&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/em&gt;/
- (void)setSelected:(BOOL)selected animated:(BOOL)animated
{
  [super setSelected:selected animated:animated];&lt;br /&gt;
  if (selected == YES)
    image.alpha = .5;
  else
    image.alpha = 1;
}&lt;/p&gt;

&lt;p&gt;/&lt;em&gt;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;
*
*&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;&lt;/em&gt;/
- (void)dealloc
{
  [image release];
  [super dealloc];
}&lt;/p&gt;

&lt;p&gt;@end
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;还是很简单的吧。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何获得对象的retain count</title>
      <link>http://blog.prosight.me/blogs/404</link>
      <pubDate>2009-10-15 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Mac特别是iPhone中的内存管理是通过引用计数来实现的。 而对于开发者来说，特别是从具备垃圾回收功能的语言开发工程师来说，这种内存管理方式具有很大的挑战性。&lt;/p&gt;

&lt;p&gt;我们最关心的就是一个对象的“retain count”， 当这个数字变成0的时候，这个对象就将被释放内存，如果此时尝试访问这个对象，你的应用程序就会崩溃。但是如果你不及时release对象，将retain count数量减少的话，又会造成内存泄漏。&lt;/p&gt;

&lt;p&gt;想知道一个对象的retain count的值的方法其实很简单。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSLog([NSString stringWithFormat:@&amp;ldquo;Retain Count:%i&amp;rdquo;, [someObject retainCount]]);
&lt;/pre&gt;
对象的retainCount方法就会反回这个对象的retain count的值。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Call of Duty：Modern Warfare 2(现代战争2)</title>
      <link>http://blog.prosight.me/blogs/401</link>
      <pubDate>2009-10-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;object classid=&#34;clsid:d27cdb6e-ae6d-11cf-96b8-444553540000&#34;  codebase=&#34;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=8,0,0,0&#34; id=&#34;gtembed&#34; width=&#34;480&#34; height=&#34;392&#34;&gt; &lt;param name=&#34;allowScriptAccess&#34; value=&#34;sameDomain&#34; /&gt; &lt;param name=&#34;allowFullScreen&#34; value=&#34;true&#34; /&gt; &lt;param name=&#34;movie&#34; value=&#34;http://www.gametrailers.com/remote_wrap.php?mid=57232&#34;/&gt; &lt;param name=&#34;quality&#34; value=&#34;high&#34; /&gt; &lt;embed src=&#34;http://www.gametrailers.com/remote_wrap.php?mid=57232&#34; swLiveConnect=&#34;true&#34; name=&#34;gtembed&#34; align=&#34;middle&#34; allowScriptAccess=&#34;sameDomain&#34; allowFullScreen=&#34;true&#34; quality=&#34;high&#34; pluginspage=&#34;http://www.macromedia.com/go/getflashplayer&#34; type=&#34;application/x-shockwave-flash&#34; width=&#34;480&#34; height=&#34;392&#34;&gt;&lt;/embed&gt; &lt;/object&gt;&lt;/p&gt;

&lt;p&gt;非常值得期待的一部游戏大作，每一集都是我必玩的，每一集都能体会到如电影般震撼的感受。 本集相信会带给我更多的惊喜。&lt;/p&gt;

&lt;p&gt;据GTTV的主持人Geoff Keighley介绍，本作联机模式的最高角色等级可以达到70级（前作的转生上限是55级），另外大家喜欢的“威望”系统也依然健在。&lt;/p&gt;

&lt;p&gt;除此之外，他还确认《现代战争2》中新的联机杀敌奖励，连续杀死11个敌人后获得的驾驶AC-130从空中扫射的机会，并不是本作的终极奖励。不过IW方面没有透露更厉害的杀敌手段是什么，也没有说明需要完成什么条件才能开启。&lt;/p&gt;

&lt;p&gt;IW总裁Vince Zampella在节目中没有就终极奖励的话题给出任何确切的数字，但可以肯定的是这个数至少得比1大……另外，他确认本作中玩家将有机会扮演几名不同的角色。&lt;/p&gt;

&lt;p&gt;此外，他还提到《现代战争2》的特别任务不设记录点，所以如果游戏中途有玩家挂掉，那任务就得从头开始。GTTV的节目中演示了4个特别任务，详情可以查看上面的视频。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Git与Xcode配合使用</title>
      <link>http://blog.prosight.me/blogs/399</link>
      <pubDate>2009-10-07 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;要想使Git与Xcode配合使用，就需要设置好以下两个文件。&lt;/p&gt;

&lt;p&gt;在项目根目录下加入如下两个文件：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;gitignore
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;xcode noise&lt;/h1&gt;

&lt;p&gt;build/*
*.pbxuser
*.mode1v3&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1&gt;old skool&lt;/h1&gt;

&lt;p&gt;.svn&lt;/p&gt;

&lt;h1&gt;osx noise&lt;/h1&gt;

&lt;p&gt;.DS_Store
profile
&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;.gitattributes
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
*.pbxproj -crlf -diff -merge
&lt;/pre&gt;
这行是将xcode的项目文江当作二进制文件来处理，这样就不会随意添加比较信息等git的信息了。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>Mac向后删除文本</title>
      <link>http://blog.prosight.me/blogs/395</link>
      <pubDate>2009-10-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Mac的键盘中的delete键跟PC中的键的定义是不一样的。 Mac中的delete键相当于PC键盘中的Backspace键，是向前删除文本，即删除光标前面的文字。 很多人为了删除光标后面的文字，用方向键把光标移至后面的文字后，再按delete键删除前面的文字。&lt;/p&gt;

&lt;p&gt;其实有一个小技巧，Mac也可以像PC一样删除后面的文字，这个技巧很简单，只要你按住Fn+delete就可以删除光标后面的文字了。 快试试吧，是不是很神奇。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何在iPhone编程中使用UITextField</title>
      <link>http://blog.prosight.me/blogs/397</link>
      <pubDate>2009-10-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;下面的例子将展示如何通过UITextField的内容来改变UILabel中的内容&lt;/p&gt;

&lt;h3&gt;实现UITextField Delegate协议&lt;/h3&gt;

&lt;p&gt;首先我们需要在viewController的接口中声明实现UITextFieldDelegate代理协议
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
@interface TextField : UIViewController&lt;UITextFieldDelegate&gt; {&lt;/p&gt;

&lt;p&gt;}
@end
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;添加UILabel 和 UITextField对象&lt;/h3&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &amp;ldquo;TextField.h&amp;rdquo;&lt;/p&gt;

&lt;p&gt;@implementation TextField
UILabel *label;
UITextField *textField;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;(void)viewDidLoad {
[super viewDidLoad];&lt;/p&gt;

&lt;p&gt;//Create label
label = [[UILabel alloc] init];
label.frame = CGRectMake(10, 10, 300, 40);
label.textAlignment = UITextAlignmentCenter;
label.text = @&amp;ldquo;&amp;rdquo;;
[self.view addSubview:label];&lt;/p&gt;

&lt;p&gt;// Initialization code
textField = [[UITextField alloc] initWithFrame:CGRectMake(10, 200, 300, 50)];
textField.delegate = self;
textField.placeholder = @&amp;rdquo;&lt;Enter Text&gt;&amp;rdquo;;
textField.textAlignment = UITextAlignmentCenter;
[self.view addSubview: textField];
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(void)dealloc {
[textField release];
[label release];
[super dealloc];
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@end
&lt;/pre&gt;
这段程序没有什么好说的，就是建立并初始化一个UILabel和UITextField对象&lt;/p&gt;

&lt;h3&gt;实现代理方法&lt;/h3&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (BOOL)textFieldShouldReturn:(UITextField *)textField{
    label.text = textField.text;
    [textField resignFirstResponder];&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;return YES;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;
当用户按了键盘上的Return键后，此方法被调用。 它做了两件事，一件是把UILabel中的值设置成UITextField中的值，另外一个是关闭虚拟键盘。&lt;/p&gt;

&lt;p&gt;iPhone编程中大量使用了代理和回调方法，是一种基本的设计模式，所以大家要熟悉这种编程模式。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Winodws 7下启用Administrator账户</title>
      <link>http://blog.prosight.me/blogs/393</link>
      <pubDate>2009-10-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在Winodws7或者Vista下， Administrator账户默认是关闭的。 但是某些软件安装还必须使用Administrator账号来安装，例如在安装Maya 2010时，最后阶段出现“1: 5 2 Failed to install/uninstall the anchor service 3: 1007 ”&lt;/p&gt;

&lt;p&gt;启用Administrator账号的方法：
1、右键我的电脑 打开管理
2、找到左侧的本地用户和组  &amp;mdash; 用户
3、用户点开后右边会出现 administrator  右键此帐户&amp;mdash;属性
4、属性里倒数第二个  帐户已禁用  把前面的钩去除
5、注销用户就能看到administrator了  登陆后就是Administrator身份了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在snow leopard上编译Ruby, RubyGems, 和Rails </title>
      <link>http://blog.prosight.me/blogs/390</link>
      <pubDate>2009-10-01 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;准备：
&lt;ol&gt;
&lt;li&gt;Snow Leopard系统&lt;/li&gt;
&lt;li&gt;XCode编译环境，Snow Leopard系统盘上有&lt;/li&gt;
&lt;/ol&gt;&lt;/p&gt;

&lt;p&gt;第一步：设置路径
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim ~/.profile
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在文件最后加上：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
export PATH=&amp;ldquo;/usr/local/bin:/usr/local/sbin:/usr/local/mysql/bin:$PATH&amp;rdquo;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;使新的路径生效
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
source ~/.profile
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;第二步：下载源文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
curl -O &lt;a href=&#34;ftp://ftp.ruby-lang.org/pub/ruby/1.8/ruby-1.8.7-p174.tar.gz&#34;&gt;ftp://ftp.ruby-lang.org/pub/ruby/1.8/ruby-1.8.7-p174.tar.gz&lt;/a&gt;
curl -O &lt;a href=&#34;http://files.rubyforge.vm.bytemark.co.uk/rubygems/rubygems-1.3.5.tgz&#34;&gt;http://files.rubyforge.vm.bytemark.co.uk/rubygems/rubygems-1.3.5.tgz&lt;/a&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;第三步：编译安装
安装ruby
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
tar xzvf ruby-1.8.7-p174.tar.gz
cd ruby-1.8.7-p174
./configure &amp;ndash;enable-shared &amp;ndash;enable-pthread CFLAGS=-D_XOPEN_SOURCE=1
make
sudo make install
cd ..
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;安装rubygem
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
tar xzvf rubygems-1.3.5.tgz
cd rubygems-1.3.5
sudo /usr/local/bin/ruby setup.rb
cd ..
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;安装rails
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo gem install rails
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;安装ruby的mysql驱动
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo gem install mysql &amp;ndash; &amp;ndash;with-mysql-dir=/usr/local/mysql
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;MySQL使用官方的dmg安装即可。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Snow Leopard安装PHP+MySQL+Apache</title>
      <link>http://blog.prosight.me/blogs/385</link>
      <pubDate>2009-09-30 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;其实Snow Leopard已经内置了apache 2.2.11和php 5.3.0，只是默认都没有打开。&lt;/p&gt;

&lt;blockquote&gt;感谢网友Jerry的提醒，如果没有安装过XCode的朋友，在执行下面这些步骤之前，请先安装XCode，XCode在Snow Leopard的光盘里面自带了，你也可以去Apple官方网站，注册一个帐号去下载最新版本的。&lt;/blockquote&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;启用Apache
进入系统偏好-&amp;gt;共享，勾选web共享后即可开启Apache&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配置PHP
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo vim /etc/apache2/httpd.conf
&lt;/pre&gt;
在
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#LoadModule php5_module        libexec/apache2/libphp5.so
&lt;/pre&gt;
把前面的#去掉。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo cp /etc/php.ini.default /etc/php.ini
&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;安装MySQL
从&lt;a href=&#34;http://dev.mysql.com/downloads/mysql/5.1.html#macosx-dmg&#34;&gt;MySQL网站&lt;/a&gt;下载最新的MySQL的dmg，按照普通程序安装即可。&lt;/li&gt;
&lt;/ol&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo vim /etc/php.ini
&lt;/pre&gt;
将mysql.default_socket的值改为：“/tmp/mysql.sock”
将mysql.default_port的值改为：3306

重启Apache
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo apachectl restart
&lt;/pre&gt;

&lt;p&gt;4.测试
在/Library/WebServer/Documents下面建立一个test.php，里面写入：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&amp;lt;?php
phpinfo();
?&amp;gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;然后访问http://localhost/test.php，可以看到mysql都已经配置好了。&lt;/p&gt;

&lt;p&gt;5.增加mcrypt扩展支持
先下载，&lt;a href=&#34;http://sourceforge.net/projects/mcrypt/files/Libmcrypt/&#34;&gt;libmcrypt&lt;/a&gt;，然后在终端定位到目录里面&lt;/p&gt;

&lt;p&gt;再在终端输入：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
./configure &amp;ndash;disable-posix-threads &amp;ndash;enable-static
make
sudo make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;下载&lt;a href=&#34;http://www.php.net/get/php-5.3.0.tar.bz2/from/a/mirror&#34;&gt;php的源码包&lt;/a&gt;，然后解包，在终端用cd定位到里面的ext/mcrypt目录&lt;/p&gt;

&lt;p&gt;终端输入：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
phpize
./configure
make
cd modules
sudo cp mcrypt.so /usr/lib/php/extensions/no-debug-non-zts-20090626/mcrypt.so
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;然后在终端输入：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo pico /etc/php.ini
&lt;/pre&gt;
在extensions那里加上:&lt;/p&gt;

&lt;p&gt;extension=mcrypt.so&lt;/p&gt;

&lt;p&gt;当然，别忘记把extension_dir＝后面的改为：&lt;/p&gt;

&lt;p&gt;“/usr/lib/php/extensions/no-debug-non-zts-20090626/”&lt;/p&gt;

&lt;p&gt;然后，重启apache
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo apachectl restart
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;至此，就在Snow Leopard下成功安装了PHP，MySQL和Apache了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Mac OS X：如何校验SHA-1</title>
      <link>http://blog.prosight.me/blogs/383</link>
      <pubDate>2009-09-28 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;从网上下载的软件，有时候为了确保文件的一致性，需要对软件进行sha验证，尤其是apple的一些重要升级文件。&lt;/p&gt;

&lt;p&gt;使用一下步骤可以进行校验&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;打开 Terminal.&lt;/li&gt;
&lt;li&gt;输入以下命令：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ /usr/bin/openssl sha1 [full path to file]
&lt;/pre&gt;
例如:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ /usr/bin/openssl sha1 /Users/test/Documents/1024SecUpd2003-03-03.dmg
SHA1(/Users/test/Documents/1024SecUpd2003-03-03.dmg) =2eb722f340d4e57aa79bb5422b94d556888cbf38
&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>从u盘启动安装snow leopard</title>
      <link>http://blog.prosight.me/blogs/373</link>
      <pubDate>2009-09-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;每次系统更新，都要刻一张双层DVD有点浪费。 如果你有容量足够大的U盘，那么从U盘安装更经济快捷。&lt;/p&gt;

&lt;p&gt;启动磁盘工具，选择恢复。源磁盘选择snow leopard的dmg，目标磁盘选择你的U盘（从左侧列表中拖拽过去），然后点击恢复就可以了。
&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/2.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/2-300x263.png&#34; alt=&#34;恢复dmg镜像&#34; title=&#34;恢复dmg镜像&#34; width=&#34;300&#34; height=&#34;263&#34; class=&#34;alignnone size-medium wp-image-374&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;恢复好后，用U盘启动（启动时按住alt键，选择U盘），就可以像光盘安装那样，安装snow leopard了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Apple硬件保修信息查询</title>
      <link>http://blog.prosight.me/blogs/376</link>
      <pubDate>2009-09-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;你可能买了很多Apple的硬件产品，但是记不清他们都是什么时候保修到期，该不该买apple care。 你可以通过这个网址进行查询&lt;a href=&#34;https://selfsolve.apple.com/GetWarranty.do&#34;&gt;https://selfsolve.apple.com/GetWarranty.do&lt;/a&gt;。 输入你的序列号就可以了。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/12.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/12.png&#34; alt=&#34;1&#34; title=&#34;1&#34; width=&#34;590&#34; height=&#34;189&#34; class=&#34;alignnone size-full wp-image-380&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/22.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/22-300x195.png&#34; alt=&#34;2&#34; title=&#34;2&#34; width=&#34;300&#34; height=&#34;195&#34; class=&#34;alignnone size-medium wp-image-381&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>清除iPhone模拟器中的程序</title>
      <link>http://blog.prosight.me/blogs/370</link>
      <pubDate>2009-09-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;当你使用iPhone模拟器测试过很多程序以后，模拟器中放置了大量无用的程序。 一直在找如何清除这些程序，其实后来发现很简单。 模拟器本身就带将这些程序清除到垃圾箱的功能。
&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/1.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/1.png&#34; alt=&#34;清除模拟器中的程序&#34; title=&#34;清除模拟器中的程序&#34; width=&#34;210&#34; height=&#34;219&#34; class=&#34;alignnone size-full wp-image-371&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>升级内核后spawn-fcgi无法启动</title>
      <link>http://blog.prosight.me/blogs/368</link>
      <pubDate>2009-09-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天升级Linux内核到2.6.30-r5。但是升级重启后，发现blog打不开了。Nginx报502的Gateway错误。&lt;/p&gt;

&lt;p&gt;第一反应就是起到php解析作用的spawn-fcgi没有启动起来。于是尝试再次手动启动。 但是发现怎么也启动不起来。&lt;/p&gt;

&lt;p&gt;开始以为是因为升级内核引起的，于是退回以前的内核版本，结果一样。始终无法启动spawn-fcgi的fastcgi服务。说明不是内核的问题。 检查Nginx日志和系统日志都没有什么有价值的信息。&lt;/p&gt;

&lt;p&gt;在一筹莫展的时候，突然注意到启动spawn-fcgi的命令中包含了php-cgi这个命令。 会不会是php的问题呢。 后来手工直接执行，发现确实php有问题。 重新使用emerge -av php编译安装php后，终于可以启动spawn-fcgi了。 网站也一切正常了。&lt;/p&gt;

&lt;p&gt;出现问题的原因应该是以前使用emerge升级过系统，部分升级影响了php所需要调用的文件，当时没有重新启动，升级后的影响没有马上生效。 这次升级内核重启后，那些升级都生效了，结果问题就暴露出来了。&lt;/p&gt;

&lt;p&gt;以后出现问题还是不要着急，任何环节都有可能出现问题。 而且有时候可能被问题的表象所蒙蔽，比如这次升级就误认为是因为内核的问题，但是其实后来证明根本跟内核没有关系。 出现问题还是要不放过任何可能出现问题的地方，即使你觉得不可能出现问题的地方也要去测试一下，逐一排查，最终肯定可以找到问题的原因的。&lt;/p&gt;

&lt;p&gt;Gentoo下安装PHP和Nginx请参考之前发表的&lt;a href=&#34;http://blog.prosight.me/index.php/2009/07/250&#34;&gt;帖子&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>如何在iPhone的应用中使用Google Map</title>
      <link>http://blog.prosight.me/blogs/366</link>
      <pubDate>2009-09-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在iPhone中应用Google地图其实很简单， 下面的例子将告诉你如何通过经纬度或者一个地址在iPhone中打开一个Google地图。&lt;/p&gt;

&lt;p&gt;下面这个例子展示如何用经纬度来打开Google地图：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
//Using longitude and latitude to drop a pin on Google maps
    float longitude = 38.892219;
    float latitude = -77.034674;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *url = [NSString stringWithFormat: @&amp;quot;http://maps.google.com/?q=%f,%f&amp;quot;,
                     longitude,
                     latitude];

[[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;注意这个例子中的openURL:方法。 iPhone中的程序经常使用这个方法来共享他们的功能。 任何一个iPhone程序都可以注册一个URL用来让其他应用程序通过这个URL打开此应用。 Google地图程序就注册了一个这样的“http://maps.google.com/?q”URL。 上面的例子执行后，就会关掉当前的应用程序，而打开Google地图。&lt;/p&gt;

&lt;p&gt;下面这个例子展示如何用地址打开一个Google地图：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
//URL to map address
NSString *url = @&amp;ldquo;http://maps.google.com/?q=Constitution+Avenue+Northwest+Washington+DC&amp;rdquo;;&lt;/p&gt;

&lt;p&gt;[[UIApplication sharedApplication] openURL:[NSURL URLWithString:url]];
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Objective-C中切分数组</title>
      <link>http://blog.prosight.me/blogs/355</link>
      <pubDate>2009-09-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在很多脚本语言如ruby,python中都有将字符串切分成数组或者将数组元素以某个间隔字符串间隔形成新的数组。 其实NSArray也提供了这样的功能。&lt;/p&gt;

&lt;p&gt;使用-componentsSeparatedByString:来切分NSArray。 如：&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSString *string = @&#34;white:black:blue:red&#34;;
NSArray *aArray = [string componentsSeparatedByString:@&#34;:&#34;];
&lt;/pre&gt;

&lt;p&gt;用-componentsJoinedByString:来合并NSArray中的各个元素并创建一个新的字符串，如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
string = [aArray componentsJoinedByString:@&amp;ldquo;,&amp;rdquo;];
&lt;/pre&gt;
这样，上面的数组就中的各个元素就以&amp;rdquo;,&amp;ldquo;分割形成一个字符串。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>XCode调试技巧--设置全局断点快速定位问题代码所在行</title>
      <link>http://blog.prosight.me/blogs/357</link>
      <pubDate>2009-09-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;很多时候，在调试程序的时候，我们很想马上知道错误的代码在哪一行。 而不想大概设置一个断点，逐行调试发现最终是哪一行代码出问题导致程序崩溃。 可以使用下面这个办法快速定位问题代码。&lt;/p&gt;

&lt;p&gt;选择Run&amp;ndash;&amp;gt;Show&amp;ndash;&amp;gt;Breakpoints，进入断点窗口&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_358&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo; caption=&amp;ldquo;Xcode的断点窗口&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/1.jpg&#34;&gt;&lt;img class=&#34;size-medium wp-image-358&#34; title=&#34;Xcode的断点窗口&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/1-300x169.jpg&#34; alt=&#34;Xcode的断点窗口&#34; width=&#34;300&#34; height=&#34;169&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;首先需要为-[NSException raise]创建一个断点。 选择Global Breakpoints, 双击Double-click for Symbol框， 输入-[NSException raise]，然后按return键。
[caption id=&amp;ldquo;attachment_362&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;300&amp;rdquo; caption=&amp;ldquo;添加了断点-NSException raise后&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/2.jpg&#34;&gt;&lt;img class=&#34;size-medium wp-image-362 &#34; title=&#34;添加了断点-[NSException raise]后&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/09/2-300x169.jpg&#34; alt=&#34;添加了断点-[NSException raise]后&#34; width=&#34;300&#34; height=&#34;169&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;其次，再按照上面的步骤添加另外一个全局断点objc_exception_throw。&lt;/p&gt;

&lt;p&gt;现则，运行的程序有异常抛出的时候，调试器就会中止程序运行并指向有问题的代码行。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>深入理解Objective-c中@class的含义</title>
      <link>http://blog.prosight.me/blogs/347</link>
      <pubDate>2009-09-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在Objective-c中，当一个类需要引用另一个类，即建立复合关系的时候，需要在类的头文件中建立被引用类的指针。 如：&lt;/p&gt;

&lt;p&gt;Car.h
&lt;pre class=&#34;prettyprint linenums&#34;&gt;#import&lt;/p&gt;

&lt;p&gt;@interface Car:NSObject
{
    Tire *tires[4];
    Engine *engine;
}&lt;/p&gt;

&lt;p&gt;&amp;hellip;&lt;/pre&gt;
实现类我们先省略，如果你直接这么编译，编译器会报错，告诉你它不知道Tire和Engine是什么。&lt;/p&gt;

&lt;p&gt;这时候有两个选择，一个是import这两个被引用类的头文件，另一个是使用@class声明Tire和Engine是类名。 二者的区别在于：
&lt;ol&gt;
    &lt;li&gt;import会包含这个类的所有信息，包括实体变量和方法，而@class只是告诉编译器，其后面声明的名称是类的名称，至于这些类是如何定义的，暂时不用考虑，后面会再告诉你。&lt;/li&gt;
    &lt;li&gt;在头文件中， 一般只需要知道被引用的类的名称就可以了。 不需要知道其内部的实体变量和方法，所以在头文件中一般使用@class来声明这个名称是类的名称。 而在实现类里面，因为会用到这个引用类的内部的实体变量和方法，所以需要使用#import来包含这个被引用类的头文件。&lt;/li&gt;
    &lt;li&gt;在编译效率方面考虑，如果你有100个头文件都#import了同一个头文件，或者这些文件是依次引用的，如A&amp;ndash;&amp;gt;B, B&amp;ndash;&amp;gt;C, C&amp;ndash;&amp;gt;D这样的引用关系。当最开始的那个头文件有变化的话，后面所有引用它的类都需要重新编译，如果你的类有很多的话，这将耗费大量的时间。而是用@class则不会。&lt;/li&gt;
    &lt;li&gt;如果有循环依赖关系，如:A&amp;ndash;&amp;gt;B, B&amp;ndash;&amp;gt;A这样的相互依赖关系，如果使用#import来相互包含，那么就会出现编译错误，如果使用@class在两个类的头文件中相互声明，则不会有编译错误出现。&lt;/li&gt;
&lt;/ol&gt;
所以，一般来说，@class是放在interface中的，只是为了在interface中引用这个类，把这个类作为一个类型来用的。 在实现这个接口的实现类中，如果需要引用这个类的实体变量或者方法之类的，还是需要import在@class中声明的类进来.&lt;/p&gt;

&lt;p&gt;如：
a.h
&lt;pre class=&#34;prettyprint linenums&#34;&gt;@class Rectangle;
@interface A : NSObject {
&amp;hellip;
}&lt;/pre&gt;
a.m
&lt;pre class=&#34;prettyprint linenums&#34;&gt;#import Rectangle
@implementation A
&amp;hellip;&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用rsync同步文件</title>
      <link>http://blog.prosight.me/blogs/345</link>
      <pubDate>2009-09-04 12:00:00 +0800</pubDate>
      <description>&lt;h2&gt;什么是 rsync？&lt;/h2&gt;

&lt;p&gt;rsync 应用程序是在 Linux® 和 UNIX® 上广泛使用的文件传输和同步程序，而且它已经移植到了 Windows® 上。它的关键特性是一个非常快的算法，它只通过数据链路发送文件差异，因此把机器之间传输的数据总量降低到最低限度。（如果使用 File Transfer Protocol [FTP] 或 rcp 和 scp 等实用程序，那么即使只修改了一个字节，也会发送完整的文件）。当然，rsync 并非只能处理现有的文件：它还可以处理只在链路一端存在的文件和目录。最后，通过压缩数据来优化通信，因此可以通过非宽带连接使用这个工具。&lt;/p&gt;

&lt;h2&gt;使用 rsync&lt;/h2&gt;

&lt;p&gt;我们使用 rsync 把本地文件直接同步到一个远程服务器。还可以把远程服务器同步到本地，或者同步两个本地目录，但是不能同步两个远程服务器。&lt;/p&gt;

&lt;p&gt;效果相同但格式不同的两个rsync命令
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
rsync &amp;ndash;compress &amp;ndash;recursive &amp;ndash;delete &amp;ndash;links
&amp;ndash;times &amp;ndash;perms &amp;ndash;owner &amp;ndash;group
&amp;ndash;verbose &amp;ndash;progress &amp;ndash;stats
&amp;ndash;rsh=&amp;ldquo;ssh&amp;rdquo;
&amp;ndash;exclude &amp;ldquo;&lt;em&gt;bak&amp;rdquo; &amp;ndash;exclude &amp;ldquo;&lt;/em&gt;~&amp;rdquo;
/my/path/at/the/laptop/* myserver:/some/path/at/the/server&lt;/p&gt;

&lt;p&gt;rsync -zrltpogve &amp;ldquo;ssh&amp;rdquo; &amp;ndash;progress &amp;ndash;stats &amp;ndash;delete
&amp;ndash;exclude &amp;ldquo;&lt;em&gt;bak&amp;rdquo; &amp;ndash;exclude &amp;ldquo;&lt;/em&gt;~&amp;rdquo;
/my/path/at/the/laptop/* myserver:/some/path/at/the/server
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;注意，上面命令中选项的次序是任意的，而且大多数选项有短格式。首先，&amp;ndash;compress（或 -z）指定将压缩数据，这可以节省带宽。应该总是使用这个选项。（在非常高速的数据链路上，不进行压缩可能也可以，但是对于大多数远程连接，压缩都是有帮助的）。可以使用补充选项 &amp;ndash;compress-level=level 指定压缩的级别；但是，通常可以接受标准的压缩级别。&lt;/p&gt;

&lt;p&gt;&amp;ndash;recursive (-r) 选项让 rsync 递归地复制所有目录。这会复制目录中的所有文件，包括其中的子目录及其内容。如果不需要这个功能，可以使用 &amp;ndash;dirs 选项 (-d) 产生相反的效果：跳过子目录及其内容。&lt;/p&gt;

&lt;p&gt;在默认情况下，rsync 把需要的文件复制到目标计算机，但是并不删除额外文件。通过使用 &amp;ndash;delete 选项，目标目录会与原目录保持完全一致。但是要注意：如果把一个空目录同步到远程目录，就会删除远程目录中的所有内容！&lt;/p&gt;

&lt;p&gt;如果原目录中有符号链接，&amp;ndash;links 选项（或 -l）会在目标目录中重新创建这些符号链接。另一种方法是使用 &amp;ndash;copy-links（或 -L）复制符号链接指向的文件或目录，而不是复制符号链接本身。如果有符号链接指向复制的树之外的文件或目录（这是一种安全风险），可以使用 &amp;ndash;copy-unsafe-links。&amp;ndash;safe-links 选项忽略这样的链接，这更安全。&lt;/p&gt;

&lt;p&gt;后面四个选项（&amp;ndash;times、&amp;ndash;perms、&amp;ndash;owner 和 &amp;ndash;group 或 -tpog）分别让 rsync 保持原来的更新时间戳、权限、所有者和组信息。同时指定所有这些选项的简便方法是使用 &amp;ndash;archive（或 -a），这还会设置 &amp;ndash;recursive 和 &amp;ndash;links 选项。&lt;/p&gt;

&lt;p&gt;后面三个选项（&amp;ndash;verbose、&amp;ndash;progress 和 &amp;ndash;stats）提供关于 rsync 正在执行的操作的大量信息。如果对这些信息不感兴趣，只需跳过它们，除非出现错误，rsync 会悄悄地运行。&lt;/p&gt;

&lt;p&gt;尽管当前的 rsync 版本默认使用 ssh，但是可以使用 &amp;ndash;rsh（或 -e）选项强制使用 ssh。如果需要使用额外的 ssh 参数（例如希望让 ssh 使用非标准端口），可以添加这些参数，例如 &amp;ndash;rsh &amp;ldquo;ssh -p 12345&amp;rdquo;。&lt;/p&gt;

&lt;p&gt;可以使用 &amp;ndash;exclude 选项（和对应的 &amp;ndash;include）选择要同步的文件。在这个示例中，排除了常见的备份文件。应该根据需要排除和包含文件，从而优化发送的内容。&lt;/p&gt;

&lt;p&gt;最后，指定源路径和目标路径。不要忘记最后的 /&lt;em&gt;，否则结果可能不符合期望。可以通过查看文档了解 some/path、some/path/ 和 some/path/&lt;/em&gt; 之间的差异。但是，使用 /* 是最保险的方法。&lt;/p&gt;

&lt;p&gt;可以使用 -a 选项 (&amp;ndash;archive) 简化清单 1 中的命令，见 清单 2。（如果作为根在服务器上运行 rsync，-a 选项可能会复制一些额外的内容 — 请查阅文档 — 这不是一种安全的做法）。rsync 还有许多选项；可以通过 rsync &amp;ndash;help 和 man rsync 了解所有选项。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>F5负载均衡配置手册</title>
      <link>http://blog.prosight.me/blogs/341</link>
      <pubDate>2009-08-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;负载均衡器通常称为四层交换机或七层交换机。四层交换机主要分析IP层及TCP/UDP层，实现四层流量负载均衡。七层交换机除了支持四层负载均衡以外，还有分析应用层的信息，如HTTP协议URI或Cookie信息。&lt;/p&gt;

&lt;p&gt;一、F5配置步骤：
1、F5组网规划
(1)组网拓朴图（具体到网络设备物理端口的分配和连接，服务器网卡的分配与连接）
(2)IP地址的分配（具体到网络设备和服务器网卡的IP地址的分配）
(3)F5上业务的VIP、成员池、节点、负载均衡算法、策略保持方法的确定&lt;/p&gt;

&lt;p&gt;2、F5配置前的准备工作
(1)版本检查
f5-portal-1:~# b version
Kernel:
BIG-IP Kernel 4.5PTF-07 Build18
(2)时间检查－－如不正确，请到单用户模式下进行修改
f5-portal-1:~# date
Thu May 20 15:05:10 CST 2004
(3)申请license－－现场用的F5都需要自己到F5网站上申请license&lt;/p&gt;

&lt;p&gt;3、F5　的通用配置
(1)在安全要求允许的情况下，在setup菜单中可以打开telnet及ftp功能，便于以后方便维护
(2)配置vlan unique_mac选项，此选项是保证F5上不同的vlan 的MAC地址不一样。在缺省情况下，F5的各个vlan的MAC地址是一样的，建议在配置时，把此项统一选择上。可用命令ifconfig –a来较验
具体是system/Advanced Properties/vlan unique_mac
(3)配置snat any_ip选项选项，此选项为了保证内网的机器做了snat后，可以对ping的数据流作转换。Ping是第三层的数据包，缺省情况下F5是不对 ping的数据包作转换，也就是internal vlan的主机无法ping external vlan的机器。（注意：还可以采用telnet来验证。）
具体是system/Advanced Properties/snat any_ip&lt;/p&gt;

&lt;p&gt;4、F5 的初始化配置
建议在对F5进行初始时都用命令行方式来进行初始化（用Web页面初始化的方式有时会有问题）。登录到命令行上，运行config或setup命令可以进行初始化配置。初次运行时会提示一些license的信息。
default:~# config&lt;/p&gt;

&lt;p&gt;5、F5双机切换监控配置（有F5双机时需要）
(1)在web页面中选择相应的vlan，在arm failsafe选择则可。Timeout为从F5收不到包的时间起，经过多长时间就发生切换。此配置不能同步，需要在F5的主备机上同时配置。每个vlan都可以配置vlan arm failsafe。
具体在Network下
(2)在web页面中选择system，在redundant properties中把gateway failsafe选择则可。Router是需要监控的地址。此配置不能同步，需要在F5的主备机上同时配置。一套F5上只能配置一个gateway failsafe
具体在system/redundant properties/gateway failsafe&lt;/p&gt;

&lt;p&gt;6、F5　MAC　masquerade配置
Mac Masquerading是F5的Shared IP Address (Floating)的MAC地址，F5如果不配置此项，则shared IP Address的MAC地址与每台F5的vlan self IP Address的MAC地址是一样的。
一般服务器是以shared IP Address为网关，在两台F5上都配置了Mac Masquerade（相同的MAC地址），这样当F5发生切换后，服务器上shared IP address的MAC不变，保证了业务的不中断
具体在Network下&lt;/p&gt;

&lt;p&gt;7、F5的pool配置
(1)在配置工具Web页面的导航面板中选择“Pools”中的“Pools”标签，点击“ADD”按钮添加服务器池(Pool)。
(2)在池属性（Pool Properties）中的“Load Balancing Method”表格中选择负载均衡策略，通常采用默认策略：“Round Robin”
(3)在“Resouces”表格中的“Member Address”文本框输入成员IP地址，在“Service”文本框中输入服务端口，点击“&amp;gt;&amp;gt;”添加到“Current Members”当前成员列表中。
(4)添加所有组成员，点击“Done”完成配置。
(5)在“Pools”中的“Pool Name”列选中特定池，然后池属性页面中选择“Persistence”标签。
(6)在“Persistence Type”表格中选定会话保持类型。点击“Apply”应用配置。&lt;/p&gt;

&lt;p&gt;8、F5的virtual server配置
(1)在配置工具Web页面的导航面板中选择“Virtual Servers”中的“Virtual Servers”标签，点击“ADD”按钮添加虚拟服务器。
(2)在“Add Virtual Server”窗口的“Address”文本框中输入虚拟服务器IP地址，并在“Service”文本框中输入服务端口号或在下拉框中选择现有的服务名称，点击“Next”执行下一步。
(3)在“Add Virtual Server”窗口的“Configure Basic Properties”页面中点击“Next”执行下一步。 在“Add Virtual Server”窗口的“Select Physical Resources”页面中点击单选按钮“Pool”，并在下拉框中选择虚拟服务器对应的负载均衡池。
(4)按“Done”完成创建虚拟服务器。&lt;/p&gt;

&lt;p&gt;9、F5的monitor的配置
(1)在配置工具Web页面的导航面板中选择“Monitor”中的“Monitors”标签，点击“ADD”按钮添加监控
(2)根据需要选择相关关联类型：“Node Associations”标签、Node Address Associations”标签、Service Associations”标签。
(3)被选关联标签中，在“Choose Monitor”表格中选择监控名称，点击“&amp;gt;&amp;gt;”按钮添加到“Monitor Rule”监控规格文本框中。监控规则可以为一条或多条。
(4)选择监控规则后，在对应节点的“Associate Current Monitor Rule”复选框中选中。如果欲删除监控关联，则选中对应节点的“Delete Existing Assocation”复选框。
(5)点击“Apply”关联监控&lt;/p&gt;

&lt;p&gt;10、F5的SNAT配置
(1)在配置工具Web页面的导航面板中选择“NATs”中的“SNATs”标签，点击“ADD”按钮添加SNAT地址。
(2)在“Add SNAT”窗口中“Translation Address”的“IP”文本框中输入SNAT IP地址，并在“Origin List”的“Origin Address”文本框中输入节点IP地址或在“Origin VLAN”下拉框中选择VLAN名称，点击“&amp;gt;&amp;gt;”加入“Current List”列表。
(3)按“Done”完成添加SNAT IP地址。&lt;/p&gt;

&lt;p&gt;11、F5主备机同步及切换校验
具体在system/Redundant Properties/synchonize Config&amp;hellip;&lt;/p&gt;

&lt;p&gt;12、业务的校验
F5主备机切换的校验
F5主备机业务运行的校验&lt;/p&gt;

&lt;p&gt;其中1~6是基本配置，7~10业务配置，11~12校验&lt;/p&gt;

&lt;p&gt;二、F5负载均衡器的维护&lt;/p&gt;

&lt;p&gt;1、F5节点及应用的检查
通过“System -&amp;gt; Network Map”页面查看节点及应用状态
绿色:节点或虚拟服务器为“UP”
红色:节点或虚拟服务器状态为“Down”
灰色:节点或虚拟服务器被禁用&lt;/p&gt;

&lt;p&gt;2、日志的检查
(1)当天日志：从web上查看logs中的system log、bigip log、monitor log，看日志中是否有异常。
(2)7天内的日志
系统日志文件 - /var/log/messages消息, 系统消息
BIG-IP 日志文件 - /var/log/bigip
“External” BIG-IP events
Monitor 日志文件 - /var/log/bigd
“Internal” BIG-IP Events
3DNS 日志文件 - /var/log/3dns
3DNS Information
用gzcat、more、vi命令打开&lt;/p&gt;

&lt;p&gt;3、F5流量的检查
(1)业务上的基本维护主要是在F5上查看F5分发到各节点的connect是否负载均衡，一般不应有数量级的差别
(2)通过WEB-&amp;gt;pool-&amp;gt; pool statistics中查看connection项中的total和current项，不应有明显的数量级的差别
(3)F5 qkview命令
执行qkview，执行完成后将输出信息保存在文件“/var/tmp/-tech.out”中，供高级技术支持用
(4)F5 tcpdump命令
TCPDUMP是Unix系统常用的报文分析工具，TCPDUMP经常用于故障定位，如会话保持失效、SNAT通信问题等
tcpdump [ -adeflnNOpqRStvxX ] [ -c count ] [ -F file ]
[ -i interface ] [ -m module ] [ -r file ]
[ -s snaplen ] [ -T type ] [ -w file ]
[ -E algo:secret ] [ expression ]&lt;/p&gt;
</description>
    </item>
    <item>
      <title>18 Web Design Tools</title>
      <link>http://blog.prosight.me/blogs/343</link>
      <pubDate>2009-08-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;In this article ive rounded-up 18 FREE web design tools in which you might find helpfull when designing and/or coding your websites.&lt;/p&gt;

&lt;p&gt;Official Lorem Ipsum Generator
&lt;a href=&#34;http://www.lipsum.com/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/01.gif&#34; title=&#34;Official Lorem Ipsum Generator&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Blind Text Generator
&lt;a href=&#34;http://www.blindtextgenerator.com/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/02.gif&#34; title=&#34;Blind Text Generator&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Icon Finder
&lt;a href=&#34;http://www.iconfinder.net/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/03.gif&#34; title=&#34;Icon Finder&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Form Spring
&lt;a href=&#34;http://www.formspring.com/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/04.gif&#34; title=&#34;Form Spring&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Measure It Firefox Addon
&lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/539&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/05.gif&#34; title=&#34;Measure It Firefox Addon&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Web Developer Firefox Addon
&lt;a href=&#34;https://addons.mozilla.org/en-US/firefox/addon/60&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/06.gif&#34; title=&#34;Web Developer Firefox Addon&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Blue Print CSS
&lt;a href=&#34;http://www.blueprintcss.org/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/07.gif&#34; title=&#34;Blue Print CSS&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;EM Calculator
&lt;a href=&#34;http://riddle.pl/emcalc/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/08.gif&#34; title=&#34;EM Calculator&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;CSS Layout Generator
&lt;a href=&#34;http://csscreator.com/?q=tools/layout&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/09.gif&#34; title=&#34;CSS Layout Generator&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Wordoff
&lt;a href=&#34;http://wordoff.org/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/10.gif&#34; title=&#34;Wordoff&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;What The Font
&lt;a href=&#34;http://new.myfonts.com/WhatTheFont/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/11.gif&#34; title=&#34;What The Font&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Pic Reflect
&lt;a href=&#34;http://picreflect.com/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/12.gif&#34; title=&#34;Pic Reflect&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Are My Sites Up
&lt;a href=&#34;http://aremysitesup.com/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/13.gif&#34; title=&#34;Are My Sites Up&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Stripe Mania
&lt;a href=&#34;http://www.stripemania.com/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/14.gif&#34; title=&#34;Stripe Mania&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Browsershots
&lt;a href=&#34;http://browsershots.org/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/15.gif&#34; title=&#34;Browsershots&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Rounded Cornr
&lt;a href=&#34;http://www.roundedcornr.com/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/15.gif&#34; title=&#34;Rounded Cornr&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Kuler
&lt;a href=&#34;http://kuler.adobe.com/#themes/rating?time=30&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/17.gif&#34; title=&#34;Kuler&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Type Tester
&lt;a href=&#34;http://www.typetester.org/&#34;&gt;&lt;img alt=&#34;&#34; src=&#34;http://www.hv-designs.co.uk/articles/webdesign_tools/18.gif&#34; title=&#34;Type Tester&#34; class=&#34;alignnone&#34; width=&#34;600&#34; height=&#34;200&#34; /&gt;&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>苹果电脑电池使用方法</title>
      <link>http://blog.prosight.me/blogs/333</link>
      <pubDate>2009-08-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;官方网站关于新机器使用时的电池的唯一要求是，要让第一次连接电脑后让电池完全充电，然后再进行软件更新。 就校正电池的方法：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;完全充电。&lt;/li&gt;
&lt;li&gt;使用电源适配器供电达两个小时，其间可使用电脑。&lt;/li&gt;
&lt;li&gt;拆下电源适配器让电池放电，直至屏幕显示电量不足对话栏。其间可使用电脑。&lt;/li&gt;
&lt;li&gt;让电脑进入睡眠状态。&lt;/li&gt;
&lt;li&gt;关机或让电脑保持睡眠状态达5小时以上。&lt;/li&gt;
&lt;li&gt;连上电源适配器，让电脑完全充电。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>Snow leopard正式版开包图</title>
      <link>http://blog.prosight.me/blogs/335</link>
      <pubDate>2009-08-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;据macrumors消息，西班牙苹果fans已收到snow leopard零售版。
并已经证实正式版的snow leopard的版本号就是Build 10A432（传说中的GM版）.&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;Snow leopard正式版开包图&#34; src=&#34;http://docs.google.com/File?id=ddggm6dt_579rqhvc3w7_b&#34; title=&#34;外包装&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;666&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img alt=&#34;Snow leopard正式版开包图&#34; src=&#34;http://docs.google.com/File?id=ddggm6dt_580cnrqg3fs_b&#34; title=&#34;内部&#34; class=&#34;alignnone&#34; width=&#34;500&#34; height=&#34;374&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Objective-C中的一些特殊的数据类型</title>
      <link>http://blog.prosight.me/blogs/337</link>
      <pubDate>2009-08-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在Objective-C中，有一些我们之前并不熟悉但是经常见到的数据类型，比如id、nil、Nil、SEL等等。在很多文章里，我们都见过这些数据类型的介绍，但是都没有说的太清楚。&lt;/p&gt;

&lt;p&gt;这篇文章从最底层的定义开始，介绍一下这些类型到底是怎么定义的，这会帮助我们更加深入地了解Objective-C。&lt;/p&gt;

&lt;p&gt;原文作者为Greg Miller，文章地址在：
&lt;a href=&#34;http://unixjunkie.blogspot.com/2006/02/nil-and-nil.html&#34;&gt;http://unixjunkie.blogspot.com/2006/02/nil-and-nil.html&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Objective-C中有一些很有趣的数据类型经常会被错误地理解。他们中的大多数都可以在/usr/include/objc/objc.h或者这个目录中的其他头文件中找到。下面是从objc.h中摘录的一段，定义了一些数据类型：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
// objc.h
typedef struct objc_class *Class;
typedef struct objc_object {
  Class isa;
} *id;&lt;/p&gt;

&lt;p&gt;typedef struct objc_selector  *SEL;
typedef id (*IMP)(id, SEL, …);
typedef signed char BOOL;&lt;/p&gt;

&lt;p&gt;#define YES             (BOOL)1
#define NO              (BOOL)0&lt;/p&gt;

&lt;p&gt;#ifndef Nil
  #define Nil 0   /* id of Nil class */
#endif&lt;/p&gt;

&lt;p&gt;#ifndef nil
  #define nil 0   /* id of Nil instance */
#endif
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;我们在这里解释一下它们的细节：
id&lt;/p&gt;

&lt;p&gt;id和void *并非完全一样。在上面的代码中，id是指向struct objc_object的一个指针，这个意思基本上是说，id是一个指向任何一个继承了Object（或者NSObject）类的对象。需要注意的是id 是一个指针，所以你在使用id的时候不需要加星号。比如id foo=nil定义了一个nil指针，这个指针指向NSObject的一个任意子类。而id *foo=nil则定义了一个指针，这个指针指向另一个指针，被指向的这个指针指向NSObject的一个子类。
nil&lt;/p&gt;

&lt;p&gt;nil和C语言的NULL相同，在objc/objc.h中定义。nil表示一个Objctive-C对象，这个对象的指针指向空（没有东西就是空）。
Nil&lt;/p&gt;

&lt;p&gt;首字母大写的Nil和nil有一点不一样，Nil定义一个指向空的类（是Class，而不是对象）。
SEL&lt;/p&gt;

&lt;p&gt;这个很有趣。SEL是“selector”的一个类型，表示一个方法的名字。比如以下方法：&lt;/p&gt;

&lt;p&gt;-[Foo count] 和 -[Bar count] 使用同一个selector，它们的selector叫做count。&lt;/p&gt;

&lt;p&gt;在上面的头文件里我们看到，SEL是指向 struct objc_selector的指针，但是objc_selector是什么呢？那么实际上，你使用GNU Objective-C的运行时间库和NeXT Objective-C的运行运行时间库（Mac OS X使用NeXT的运行时间库）时,它们的定义是不一样的。实际上Mac OSX仅仅将SEL映射为C字符串。比如，我们定义一个Foo的类，这个类带有一个- (int) blah方法，那么以下代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSLog (@&amp;ldquo;SEL=%s&amp;rdquo;, @selector(blah));
&lt;/pre&gt;
会输出为 SEL=blah。&lt;/p&gt;

&lt;p&gt;说白了SEL就是返回方法名。
IMP&lt;/p&gt;

&lt;p&gt;从上面的头文件中我们可以看到，IMP定义为 id (*IMP) (id, SEL, …)。这样说来， IMP是一个指向函数的指针，这个被指向的函数包括id(“self”指针)，调用的SEL（方法名），再加上一些其他参数。&lt;/p&gt;

&lt;p&gt;说白了IMP就是实现方法。
Method&lt;/p&gt;

&lt;p&gt;在objc/objc-class.h中定义了叫做Method的类型，是这样定义的：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
typedef struct objc_method *Method;&lt;/p&gt;

&lt;p&gt;struct objc_method {
  SEL method_name;
  char *method_types;
  IMP method_imp;
};
&lt;/pre&gt;
这个定义看上去包括了我们上面说过的其他类型。也就是说，Method（我们常说的方法）表示一种类型，这种类型与selector和实现(implementation)相关。
Class&lt;/p&gt;

&lt;p&gt;从上文的定义看，Class（类）被定义为一个指向struct objc_class的指针，在objc/objc-class.h中它是这么定义的：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
struct objc_class {
  struct objc_class *isa;
  struct objc_class *super_class;
  const char *name;
  ong version;
  long info;
  long instance_size;
  struct objc_ivar_list *ivars;
  struct objc_method_list **methodLists;
  struct objc_cache *cache;
  struct objc_protocol_list *protocols;
};
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Leopard下手工安装ruby,rails和mysql</title>
      <link>http://blog.prosight.me/blogs/328</link>
      <pubDate>2009-08-23 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;&lt;p&gt;安装readline
&lt;a href=&#34;ftp://ftp.gnu.org/gnu/readline/&#34;&gt;ftp://ftp.gnu.org/gnu/readline/&lt;/a&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd readline-6.0
./configure &amp;ndash;prefix=/usr/local
make
sudo make install
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安装ruby
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
tar xvjf ruby-1.8.7-p174.tar.bz2
cd ruby-1.8.7-p174
./configure &amp;ndash;prefix=/usr/local/ruby &amp;ndash;enable-pthread &amp;ndash;with-readline-dir=/usr/local &amp;ndash;enable-shared
make
sudo make install
sudo make install-doc
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;使用ruby -v来确认版本安装正确&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装mysql
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/configure &amp;ndash;prefix=/usr/local/mysql &amp;ndash;with-extra-charsets=complex &amp;ndash;enable-thread-safe-client &amp;ndash;enable-local-infile &amp;ndash;enable-shared &amp;ndash;with-plugins=max-no-ndb
make
sudo make install
cd /usr/local/mysql
sudo ./bin/mysql_install_db &amp;ndash;user=mysql
sudo chown -R mysql ./var/
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;mac os x 是靠 launchd 守护进程运行的, 配置文件用的是 PropertyList (XML 格式), 通过观察发现每10秒检查一次, 发现进程不在就启动.&lt;/p&gt;

&lt;p&gt;方法是新建 /Library/LaunchDaemons/com.mysql.mysqld.plist 写入如下内容.
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;ldquo;-//Apple//DTD PLIST 1.0//EN&amp;rdquo; &amp;ldquo;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;rdquo;&amp;gt;
&lt;plist version=&#34;1.0&#34;&gt;
&lt;dict&gt;
    &lt;key&gt;KeepAlive&lt;/key&gt;
&lt;true /&gt;
    &lt;key&gt;Label&lt;/key&gt;
    &lt;string&gt;com.mysql.mysqld&lt;/string&gt;
    &lt;key&gt;Program&lt;/key&gt;
    &lt;string&gt;/usr/local/mysql/bin/mysqld_safe&lt;/string&gt;
    &lt;key&gt;RunAtLoad&lt;/key&gt;
&lt;true /&gt;
    &lt;key&gt;UserName&lt;/key&gt;
    &lt;string&gt;mysql&lt;/string&gt;
    &lt;key&gt;WorkingDirectory&lt;/key&gt;
    &lt;string&gt;/usr/local/mysql&lt;/string&gt;
    &lt;/dict&gt;
&lt;/plist&gt;
&lt;/pre&gt;
加入守护清单
sudo launchctl load -w /Library/LaunchDaemons/com.mysql.mysqld.plist&lt;/p&gt;

&lt;p&gt;查看清单
launchctl list&lt;/p&gt;

&lt;p&gt;解除守护
sudo launchctl unload -w /Library/LaunchDaemons/com.mysql.mysqld.plist&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安装mysql的c驱动
&lt;a href=&#34;http://rubyforge.org/fsr/download.php/51087/mysql-ruby-2.8.1.tar.gz&#34;&gt;http://rubyforge.org/fsr/download.php/51087/mysql-ruby-2.8.1.tar.gz&lt;/a&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
tar xzvf mysql-ruby-2.8.1.tar.gz
cd mysql-ruby-2.8.1
ruby extconf.rb &amp;ndash;with-mysql-dir=/usr/local/mysql
make
sudo make instal
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果出现类似以下的错误
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
checking for mysql_query() in -lmysqlclient&amp;hellip; no
checking for main() in -lm&amp;hellip; yes
checking for mysql_query() in -lmysqlclient&amp;hellip; no
checking for main() in -lz&amp;hellip; yes
checking for mysql_query() in -lmysqlclient&amp;hellip; no
checking for main() in -lsocket&amp;hellip; no
checking for mysql_query() in -lmysqlclient&amp;hellip; no
checking for main() in -lnsl&amp;hellip; no
checking for mysql_query() in -lmysqlclient&amp;hellip; no
checking for main() in -lmygcc&amp;hellip; yes
checking for mysql_query() in -lmysqlclient&amp;hellip; no
*** extconf.rb failed ***
Could not create Makefile due to some reason, probably lack of
necessary libraries and/or headers.  Check the mkmf.log file for more
details.  You may need configuration options.
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;就换用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo ruby extconf.rb &amp;ndash;with-mysql-config
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>no such file to load -- sqlite3问题解决</title>
      <link>http://blog.prosight.me/blogs/330</link>
      <pubDate>2009-08-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;从rails2.0.2以后，rails默认的数据库是sqlite3了。 所以如果你使用rails appName命令建立应用的话，使用的是sqlite数据库。&lt;/p&gt;

&lt;p&gt;作为开发和测试，使用sqlite3数据库倒是可以。如果你在运行应用的时候出现了
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
no such file to load &amp;ndash; sqlite3
&lt;/pre&gt;
这个错误，说明你没有安装sqlite的ruby驱动。 使用以下命令可以安装此驱动
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo gem install sqlite3-ruby
&lt;/pre&gt;
安装成功后，上面的问题就解决了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>DIV+CSS侧边栏自适应高度</title>
      <link>http://blog.prosight.me/blogs/326</link>
      <pubDate>2009-08-09 12:00:00 +0800</pubDate>
      <description>&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;div id=&#34;container&#34;&gt;
  &lt;div id=&#34;sidebar1&#34;&gt;
    &lt;!-- end #sidebar1 --&gt;
  &lt;/div&gt;
  
  &lt;div id=&#34;mainContent&#34;&gt;
  &lt;/div&gt;

  &lt;!-- end #container --&gt;
&lt;/div&gt;
&lt;/pre&gt;

&lt;p&gt;如上面这个比较经典的两栏布局。 如果sidebar1使用了背景平铺图片或者背景颜色，这时候，如果如果另一侧的mainContent比sidebar1高的话，就会出现sidebar1上半部分是之前指定sidebar1的背景，而下面则是这个container的背景。也就是说sidebar1定义的背景并没有自动随着页面高度的增加而自动延伸下来。&lt;/p&gt;

&lt;p&gt;即使你把sidebar1的高度设置成100%也是没有效果的。&lt;/p&gt;

&lt;p&gt;解决办法很简单，因为另一侧的mainContent的内容增加了，高度变高了，会自动导致包含它的container的高度也自然增加，所以如果把sidebar1的背景设置在container中就解决了。&lt;/p&gt;

&lt;p&gt;如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
background: #fff url(../images/left_bg.jpg) repeat-y;
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>让Safari不再弹出新窗口</title>
      <link>http://blog.prosight.me/blogs/315</link>
      <pubDate>2009-08-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一直很喜欢Firefox点击页面中带有target=“_blank&amp;rdquo;链接的时候，不是新开窗口，而是打开一个新的标签。&lt;/p&gt;

&lt;p&gt;其实Safari也可以。 只要在terminal输入一下命令就可以了
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
defaults write com.apple.Safari TargetedClicksCreateTabs -bool true
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;然后再重启你的浏览器就可以了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>打开Safari的开发模式</title>
      <link>http://blog.prosight.me/blogs/318</link>
      <pubDate>2009-08-06 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Firefox有firebug可以用来帮助开发者调试网络应用。 其实Safari也有一个类似的开发模式可以帮助开发人员调试网络应用。&lt;/p&gt;

&lt;p&gt;在Terminal中输入一下内容
&lt;pre class=&#34;prettyprint linenums&#34;&gt;defaults write com.apple.Safari IncludeDebugMenu 1&lt;/pre&gt;
完成后, 打开 safari (如果已经运行，重新启动它) 你将看到开发菜单项就会出现在菜单栏里面。你可以发现很多有用的工具，如：
&lt;strong&gt;web检查器&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/08/12.png&#34;&gt;&lt;img class=&#34;alignnone size-medium wp-image-324&#34; title=&#34;web检查器&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/08/12-300x52.png&#34; alt=&#34;web检查器&#34; width=&#34;300&#34; height=&#34;52&#34; /&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;检查元素&lt;/strong&gt;
&lt;img class=&#34;size-full wp-image-319&#34; title=&#34;1903477581_c00c0b4903&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/08/1903477581_c00c0b4903.jpg&#34; alt=&#34;Safari开发工具&#34; width=&#34;500&#34; height=&#34;127&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用ETag和Expires调优web服务器性能</title>
      <link>http://blog.prosight.me/blogs/313</link>
      <pubDate>2009-08-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;正确使用Etag和Expires标识处理，可以使得页面更加有效被Cache。&lt;/p&gt;

&lt;p&gt;在客户端通过浏览器发出第一次请求某一个URL时，根据 HTTP 协议的规定，浏览器会向服务器传送报头(Http Request Header)，服务器端响应同时记录相关属性标记(Http Reponse Header)，服务器端的返回状态会是200，格式类似如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
HTTP/1.1 200 OK
Date: Tue, 03 Mar 2009 04:58:40 GMT
Content-Type: image/jpeg
Content-Length: 83185
Last-Modified: Tue, 24 Feb 2009 08:01:04 GMT
Cache-Control: max-age=2592000&lt;/p&gt;

&lt;p&gt;Expires: Thu, 02 Apr 2009 05:14:08 GMT
Etag: “5d8c72a5edda8d6a:3239″
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;客户端第二次请求此URL时，根据 HTTP 协议的规定，浏览器会向服务器传送报头(Http Request Header)，服务器端响应并记录相关记录属性标记文件没有发生改动,服务器端返回304，直接从缓存中读取：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
HTTP/1.x 304 Not Modified
Date: Tue, 03 Mar 2009 05:03:56 GMT
Content-Type: image/jpeg
Content-Length: 83185
Last-Modified: Tue, 24 Feb 2009 08:01:04 GMT
Cache-Control: max-age=2592000
Expires: Thu, 02 Apr 2009 05:14:08 GMT
Etag: “5d8c72a5edda8d6a:3239″
&lt;/pre&gt;
其中Last-Modified、Expires和Etag是标记页面缓存标识&lt;/p&gt;

&lt;h3&gt;一、Last-Modified、Expires和Etag相关工作原理&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;1、Last-Modified&lt;/strong&gt;
在浏览器第一次请求某一个URL时，服务器端的返回状态会是200，内容是你请求的资源，同时有一个Last-Modified的属性标记(Http Reponse Header)此文件在服务期端最后被修改的时间，格式类似这样：
Last-Modified: Tue, 24 Feb 2009 08:01:04 GMT
客户端第二次请求此URL时，根据 HTTP 协议的规定，浏览器会向服务器传送 If-Modified-Since 报头(Http Request Header)，询问该时间之后文件是否有被修改过：
If-Modified-Since: Tue, 24 Feb 2009 08:01:04 GMT
如果服务器端的资源没有变化，则自动返回 HTTP 304 （NotChanged.）状态码，内容为空，这样就节省了传输数据量。当服务器端代码发生改变或者重启服务器时，则重新发出资源，返回和第一次请求时类似。从而保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。
注：如果If-Modified-Since的时间比服务器当前时间(当前的请求时间request_time)还晚，会认为是个非法请求&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2、Etag工作原理&lt;/strong&gt;
HTTP 协议规格说明定义ETag为“被请求变量的实体标记” （参见14.19）。简单点即服务器响应时给请求URL标记，并在HTTP响应头中将其传送到客户端，类似服务器端返回的格式：
Etag: “5d8c72a5edda8d6a:3239″
客户端的查询更新格式是这样的：
If-None-Match: “5d8c72a5edda8d6a:3239″
如果ETag没改变，则返回状态304。
即:在客户端发出请求后，Http Reponse Header中包含 Etag: “5d8c72a5edda8d6a:3239″
标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个 URI的时候，浏览器同时发出一个If-None-Match报头( Http RequestHeader)此时包头中信息包含上次访问得到的Etag: “5d8c72a5edda8d6a:3239″标识。
If-None-Match: “5d8c72a5edda8d6a:3239“
,这样，Client端等于Cache了两份，服务器端就会比对2者的etag。如果If-None-Match为False，不返回200，返回304 (Not Modified) Response。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;3、Expires&lt;/strong&gt;
给出的日期/时间后，被响应认为是过时。如Expires: Thu, 02 Apr 2009 05:14:08 GMT
需和Last-Modified结合使用。用于控制请求文件的有效时间，当请求数据在有效期内时客户端浏览器从缓存请求数据而不是服务器端. 当缓存中数据失效或过期，才决定从服务器更新数据。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4、Last-Modified和Expires&lt;/strong&gt;
Last-Modified标识能够节省一点带宽，但是还是逃不掉发一个HTTP请求出去，而且要和Expires一起用。而Expires标识却使得浏览器干脆连HTTP请求都不用发，比如当用户F5或者点击Refresh按钮的时候就算对于有Expires的URI，一样也会发一个HTTP请求出去，所以，Last-Modified还是要用的，而 且要和Expires一起用。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;5、Etag和Expires&lt;/strong&gt;
如果服务器端同时设置了Etag和Expires时，Etag原理同样，即与Last-Modified/Etag对应的HttpRequest Header:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和WebServer发出的 Last-Modified,Etag值完全一样；在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和 Etag之后，服务器才能返回304.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;6、Last-Modified和Etag&lt;/strong&gt;
Last-Modified 和ETags请求的http报头一起使用，服务器首先产生 Last-Modified/Etag标记，服务器可在稍后使用它来判断页面是否已经被修改，来决定文件是否继续缓存
过程如下:
1. 客户端请求一个页面（A）。
2. 服务器返回页面A，并在给A加上一个Last-Modified/ETag。
3. 客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。
4. 客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。
5. 服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。
注：
1、Last-Modified和Etag头都是由Web Server发出的Http Reponse Header，Web Server应该同时支持这两种头。
2、Web Server发送完Last-Modified/Etag头给客户端后，客户端会缓存这些头；
3、客户端再次发起相同页面的请求时，将分别发送与Last-Modified/Etag对应的Http RequestHeader:If-Modified-Since和If-None-Match。我们可以看到这两个Header的值和 WebServer发出的Last-Modified,Etag值完全一样；
4、通过上述值到服务器端检查，判断文件是否继续缓存；&lt;/p&gt;

&lt;h3&gt;二、Apache、Lighttpd和Nginx中针配置Etag和Expires，有效缓存纯静态如css/js/pic/页面/流媒体等文件。&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;A、Expires&lt;/strong&gt;
&lt;strong&gt;A.1、Apache Etag&lt;/strong&gt;
使用Apache的mod_expires 模块来设置，这包括控制应答时的Expires头内容和Cache-Control头的max-age指令
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ExpiresActive On
ExpiresByType image/gif “access plus 1 month”
ExpiresByType image/jpg “access plus 1 month”
ExpiresByType image/jpeg “access plus 1 month”
ExpiresByType image/x-icon “access plus 1 month”
ExpiresByType image/bmp “access plus 1 month”
ExpiresByType image/png “access plus 1 month”
ExpiresByType text/html “access plus 30 minutes”
ExpiresByType text/css  “access plus 30 minutes”
ExpiresByType text/txt  “access plus 30 minutes”
ExpiresByType text/js   ”access plus 30 minutes”
ExpiresByType application/x-javascript   ”access plus 30 minutes”
ExpiresByType application/x-shockwave-flash     ”access plus 30 minutes”
或
&lt;ifmodule mod_expires.c&gt;
&lt;filesmatch “.(jpg|gif|png|css|js)$”&gt;
ExpiresActive on
ExpiresDefault “access plus 1 year”
&lt;/filesmatch&gt;
&lt;/ifmodule&gt;
&lt;/pre&gt;
当设置了expires后，会自动输出Cache-Control 的max-age 信息
具体关于 Expires 详细内容可以查看Apache官方文档。
在这个时间段里，该文件的请求都将直接通过缓存服务器获取，
当然如果需要忽略浏览器的刷新请求（F5)，缓存服务器squid还需要使用 refresh_pattern 选项来忽略该请求
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
refresh_pattern -i .gif$ 1440 100% 28800 ignore-reload
refresh_pattern -i .jpg$ 1440 100% 28800 ignore-reload
refresh_pattern -i .jpeg$ 1440 100% 28800 ignore-reload
refresh_pattern -i .png$ 1440 100% 28800 ignore-reload
refresh_pattern -i .bmp$ 1440 100% 28800 ignore-reload
refresh_pattern -i .htm$ 60 100% 100 ignore-reload
refresh_pattern -i .html$ 1440 50% 28800 ignore-reload
refresh_pattern -i .xml$ 1440 50% 28800 ignore-reload
refresh_pattern -i .txt$ 1440 50% 28800 ignore-reload
refresh_pattern -i .css$ 1440 50% 28800 reload-into-ims
refresh_pattern -i .js$ 60 50% 100 reload-into-ims
refresh_pattern . 10 50% 60
&lt;/pre&gt;
有关Squid中Expires的说明，请参考Squid官方中refresh_pattern介绍。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;A.2、Lighttpd Expires&lt;/strong&gt;
和Apache一样Lighttpd设置expire也要先查看是否支持了mod_expire模块，
下面的设置是让URI中所有images目录下的文件1小时后过期；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
expire.url = ( “/images/” =&amp;gt; “access 1 hours” )
&lt;/pre&gt;
下面是让作用于images目录及其子目录的文件；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$HTTP[&amp;ldquo;url&amp;rdquo;] =~ “^/images/” {
expire.url = ( “” =&amp;gt; “access 1 hours” )
}
&lt;/pre&gt;
也可以指定文件的类型；
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$HTTP[&amp;ldquo;url&amp;rdquo;] =~ “.(jpg|gif|png|css|js)$” {
expire.url = ( “” =&amp;gt; “access 1 hours” )
}
&lt;/pre&gt;
具体参考Lighttpd官方Expires解释&lt;/p&gt;

&lt;p&gt;A.3、Nginx中Expires
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
location ~ .&lt;em&gt;.(gif|jpg|jpeg|png|bmp|swf)$
{
expires 30d;
}
location ~ .&lt;/em&gt;.(js|css)?$
{
expires 1h;
}
&lt;/pre&gt;
这类文件并不常修改，通过 expires 指令来控制其在浏览器的缓存，以减少不必要的请求。 expires 指令可以控制 HTTP 应答中的“ Expires ”和“ Cache-Control ”的头标（起到控制页面缓存的作用）。其他请参考Nginx中Expires&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;B.1、Apache中Etag设置&lt;/strong&gt;
在Apache中设置Etag的支持比较简单，只用在含有静态文件的目录中建立一个文件.htaccess, 里面加入：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
FileETag MTime Size
&lt;/pre&gt;
这样就行了，详细的可以参考Apache的FileEtag文档页&lt;/p&gt;

&lt;p&gt;B.2、Lighttpd Etag
在Lighttpd中设置Etag支持：
etag.use-inode: 是否使用inode作为Etag
etag.use-mtime: 是否使用文件修改时间作为Etag
etag.use-size: 是否使用文件大小作为Etag
static-file.etags: 是否启用Etag的功能
第四个参数肯定是要enable的， 前面三个就看实际的需要来选吧，推荐使用修改时间&lt;/p&gt;

&lt;p&gt;B.3、 Nginx Etag
Nginx中默认没有添加对Etag标识.Igor Sysoev的观点”在对静态文件处理上看不出如何Etag好于Last-Modified标识。”
Note:
Yes, it’s addition,and it’s easy to add, however, I do not see howETag is better than Last-Modified for static files. -Igor Sysoev
A nice short description is here:
&lt;a href=&#34;http://www.mnot.net/cache_docs/#WORK&#34;&gt;http://www.mnot.net/cache_docs/#WORK&lt;/a&gt;
It looks to me that it makes some caches out there to cache theresponse from the origin server more reliable as in rfc2616(ftp://ftp.rfc-editor.org/in-notes/rfc2616.txt) is written.
3.11 Entity Tags 13.3.2 Entity Tag Cache Validators 14.19 ETag
当然也有第三方nginx-static-etags 模块了，请参考
&lt;a href=&#34;http://mikewest.org/2008/11/generating-etags-for-static-content-using-nginx&#34;&gt;http://mikewest.org/2008/11/generating-etags-for-static-content-using-nginx&lt;/a&gt;&lt;/p&gt;

&lt;h3&gt;三、对于非实时交互动态页面中Expires和Etag处理&lt;/h3&gt;

&lt;p&gt;对数据更新并不频繁、如tag分类归档等等，可以考虑对其cache。简单点就是在非实时交互的动态程序中输出expires和etag标识，让其缓存。但需要注意关闭session，防止http response时http header包含session id标识；
&lt;strong&gt;3.1、Expires&lt;/strong&gt;
如expires.php
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&amp;lt;?php
header(’Cache-Control: max-age=86400,must-revalidate’);
header(’Last-Modified: ‘ .gmdate(’D, d M Y H:i:s’) . ‘ GMT’ );
header(”Expires: ” .gmdate (’D, d M Y H:i:s’, time() + ‘86400′ ). ‘ GMT’);
?&amp;gt;
&lt;/pre&gt;
以上信息表示该文件自请求后24小时后过期。
其他需要处理的动态页面直接调用即可。
3.2、Etag
根据Http返回状态来处理。当返回304直接从缓存中读取
如etag.php
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&amp;lt;?php
cache();
echo date(”Y-m-d H:i:s”);
function cache()
{
$etag = “http://longrujun.name”;
if ($_SERVER[&amp;lsquo;HTTP_IF_NONE_MATCH&amp;rsquo;] == $etag)
{
header(’Etag:’.$etag,true,304);
exit;
}
else header(’Etag:’.$etag);
}
?&amp;gt;
&lt;/pre&gt;
来自: &lt;a href=&#34;http://longrujun.name/index.php/2009/03/04/etag%E5%92%8Cexpires/&#34;&gt;http://longrujun.name/index.php/2009/03/04/etag%E5%92%8Cexpires/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>深入理解sudo</title>
      <link>http://blog.prosight.me/blogs/311</link>
      <pubDate>2009-07-27 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;以前没有太在意这方面的知识，现整理如下：&lt;/p&gt;

&lt;p&gt;用root用户登录或用su - 切换到root用户，使用visudo命令，方法跟vi一样&lt;/p&gt;

&lt;h3&gt;赋予用户在所有主机上的所有权限&lt;/h3&gt;

&lt;p&gt;在最后一行加入
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
your_user_name ALL=(ALL) ALL&lt;br /&gt;
&lt;/pre&gt;
第一个ALL表示主机，后两个ALL表示权限
保存即可。&lt;/p&gt;

&lt;h3&gt;指定主机别名&lt;/h3&gt;

&lt;p&gt;为了方便设置一批主机，可以在文件中定义别名，如
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Host_Alias     FILESERVERS = fs1, fs2&lt;br /&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;指定用户别名&lt;/h3&gt;

&lt;p&gt;用户同样可以设置别名，方便定义一组用户，如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
User_Alias ADMINS = jsmith, mikem&lt;br /&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;指定命令别名&lt;/h3&gt;

&lt;p&gt;为了方便给不同用户设置不同的权限，可以将相关命令打包成一个组，如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Cmnd_Alias NETWORKING = /sbin/route, /sbin/ifconfig, /bin/ping, /sbin/dhclient, /usr/bin/net, /sbin/iptables, /usr/bin/rfcomm, /usr/bin/wvdial, /sbin/iwconfig, /sbin/mii-tool
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;授权用户指定主机指定权限&lt;/h3&gt;

&lt;p&gt;有了上面的知识积累，就可以给指定的用户授予指定的管理员权限，如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
your_user_name server1 = NETWORKING&lt;br /&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;授权某个用户组相应权限&lt;/h3&gt;

&lt;p&gt;如果想将一组用户都可以使用sudo，则使用%加在组名前面
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
%your_group_name ALL=(ALL) ALL&lt;br /&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;授权用户使用管理权限的时候不输入密码&lt;/h3&gt;

&lt;p&gt;如果想不必输入密码，则需要更改visudo中的相关行如下
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
your_user_name ALL=(ALL) NOPASSWD: ALL&lt;br /&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;设置过以上相关内容后，就可以使用sudo临时使用需要管理权限的命令，方法是
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
sudo commands&lt;br /&gt;
&lt;/pre&gt;
如果没有指定NOPASSWORD的话，是需要输入相关用户密码的。
可以使用sudo -l命令列出此用户的相关特殊权限&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用fail2ban增强Linux安全防护</title>
      <link>http://blog.prosight.me/blogs/304</link>
      <pubDate>2009-07-26 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;观察/var/log/messages你可能会经常发现有类似以下的访问记录
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Jul 26 04:16:22 prosight sshd[29679]: Invalid user benjamin from 123.140.230.12
Jul 26 04:16:23 prosight sshd[29681]: Invalid user daniel from 123.140.230.12
Jul 26 04:16:24 prosight sshd[29683]: Invalid user william from 123.140.230.12
Jul 26 04:16:24 prosight sshd[29685]: Invalid user anthony from 123.140.230.12
Jul 26 04:16:25 prosight sshd[29687]: Invalid user cameron from 123.140.230.12
Jul 26 04:16:25 prosight sshd[29689]: Invalid user james from 123.140.230.12
&lt;/pre&gt;
同一个用户在不断的尝试用各种用户来登录你的机器。 &lt;a href=&#34;http://www.fail2ban.org/wiki/index.php/Main_Page&#34; target=&#34;_blank&#34;&gt;fail2ban&lt;/a&gt;可以很有效的阻止这种频繁的试图登录你的机器的尝试&lt;/p&gt;

&lt;h3&gt;安装fail2ban&lt;/h3&gt;

&lt;p&gt;对于gentoo来说很简单，只要emerge一下就可以了。 其他版本的Linux可以通过源码或者rpm包安装
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo emerge -av fail2ban
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;设置fail2ban&lt;/h3&gt;

&lt;p&gt;/etc/fail2ban/fail2ban.conf 是fail2ban的全局基本配置，基本不用动
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cat /etc/fail2ban/fail2ban.conf&lt;/p&gt;

&lt;p&gt;loglevel = 3
logtarget = /var/log/fail2ban.log
socket = /tmp/fail2ban.sock
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;/etc/fail2ban/jail.conf 是fail2ban的规则配置文件，我们需要根据情况来编辑它&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[DEFAULT]
ignoreip = 127.0.0.1 #可以忽略的ip，多个ip用空格隔开

#当在findtime时间内（秒）失败超过maxretry次数后，就被封bantime时间（秒）
bantime  = 3600
findtime  = 600
maxretry = 3   

backend = auto
#如果你使用的是iptables就将这个规则设置为true
[ssh-iptables]

enabled  = true
filter   = sshd
action   = iptables[name=SSH, port=ssh, protocol=tcp]
           mail-whois[name=SSH, dest=yourmail@mail.com]
logpath  = /var/log/sshd.log #你ssh日志存放的地址
&lt;/pre&gt;

&lt;h3&gt;启动fail2ban&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ sudo /etc/init.d/fail2ban start
&lt;/pre&gt;

&lt;h3&gt;查看fail2ban状态&lt;/h3&gt;

&lt;p&gt;启动之后，只要符合filter所定义的正则式规则的日志项出现，就会执行相应的action。由于0.8源码树采用客户机/服务器的模式，因此可以很方便的查询fail2ban的执行情况。比方所，要查询刚才定义的“ssh-iptables”段的情况，只要执行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
fail2ban-client status ssh-iptables
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;输出结果：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Status for the jail: ssh-iptables
|- filter
|  |- Currently failed: 0
|  &lt;code&gt;- Total failed:     5
&lt;/code&gt;- action
   |- Currently banned: 1
   |  &lt;code&gt;- IP list:       192.168.210.21
&lt;/code&gt;- Total banned:     1
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;fail2ban-client也可以直接定义运行中的fail2ban参数
比如增加屏蔽时间为一天
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
fail2ban-client set ssh-iptables bantime 86400
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;重新读入配置文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
fail2ban-client reload
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;其它还有很多用法，可以不带参数执行fail2ban-client查看更多选项。&lt;/p&gt;

&lt;p&gt;因为fail2ban的框架，所以可以执行修改filter或者action来满足自己的特殊需要，比如我希望改变fail2ban默认的 iptables规则插入方式，那么我就可以到action.d目录下，找到希望修改的action，这里的例子是iptables.conf&lt;/p&gt;

&lt;p&gt;默认actionstart的iptables规则有一条是
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
iptables -I INPUT -p &lt;protocol&gt; &amp;ndash;dport &lt;port&gt; -j fail2ban-&lt;name&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这样就把fail2ban的规则插到INPUT链的最前面，而我希望自己写的一条iptables -A INPUT -p ALL -s 1.2.3.&lt;sup&gt;4&lt;/sup&gt;&amp;frasl;&lt;sub&gt;32&lt;/sub&gt; -j ACCEPT一直作为第一条规则从而使自己的IP作为信任IP不受防火墙后面规则的限制。那么就要修改fail2ban的启动规则，把上面那条改为
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
iptables -I INPUT 2 -p &lt;protocol&gt; &amp;ndash;dport &lt;port&gt; -j fail2ban-&lt;name&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;这样fail2ban就会把自己的规则作为INPUT链的第二条规则插入，而不影响第一条。&lt;/p&gt;

&lt;p&gt;这里只是一个很简单的例子，你可以根据自己的规则，对action做更多的修改。&lt;/p&gt;

&lt;p&gt;而在filter.d目录里就是一些日志的正则式匹配规则，系统自带了一些常见软件的匹配，如 sshd,apache,postfix,vsftpd,pure-ftpd等等。来看看sshd的规则，就能了解这些filter应该怎么写，你就可以用fail2ban来保护更多自己的服务。&lt;/p&gt;

&lt;p&gt;sshd.conf的内容
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[Definition]&lt;/p&gt;

&lt;p&gt;failregex = Authentication failure for .* from &lt;HOST&gt;
            Failed [-/w]+ for .* from &lt;HOST&gt;
            ROOT LOGIN REFUSED .* FROM &lt;HOST&gt;
            &lt;a href=&#34;?:llegal|nvalid&#34;&gt;iI&lt;/a&gt; user .* from &lt;HOST&gt;&lt;/p&gt;

&lt;p&gt;ignoreregex =
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;可以看到，每行一则正则式，对应各种错误认证，如果你的sshd版本错误认证日志项不太一样，可以修改这里的，或者加入更多。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Git学习笔记(3) -- 标记(tag)</title>
      <link>http://blog.prosight.me/blogs/279</link>
      <pubDate>2009-07-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;当执行git log
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git log
&lt;strong&gt;commit 29293409f6d4a389fee75bd42fba5194fee5b899&lt;/strong&gt;
Author: elton &lt;a href=&#34;mailto:elton.zheng.sh@gmail.com&#34;&gt;elton.zheng.sh@gmail.com&lt;/a&gt;
Date:   Wed Jul 22 12:26:11 2009 +0800
&amp;hellip;
&lt;/pre&gt;
其中commit后面的数字是一个唯一的版本号，每次提交都不同。&lt;/p&gt;

&lt;h3&gt;显示版本信息&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$git show 29293409f6d4a389fee75bd42fba5194fee5b899
&lt;/pre&gt;
就显示这个版本的详细信息
也可以使用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$git show 292934
&lt;/pre&gt;
只要你这个版本号足够区分其他版本就可以了。

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$git show master
&lt;/pre&gt;
显示master分支的版本信息

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$git show HEAD
&lt;/pre&gt;
HEAD代表当前分支的头（也就是最近一次commit）
每一次commit都会有”parent commit”，可以使用^表示parent：

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$git show HEAD^ //查看HEAD的父母的信息
$git show HEAD^^ //查看HEAD的父母的父母的信息
$git show HEAD~4 //查看HEAD上溯4代的信息

要注意的是git-merge是会产生双父母的，这种情况这样处理：
$git show HEAD^1 //查看HEAD的第一个父母
$git show HEAD^2 //查看HEAD的第二个父母
&lt;/pre&gt;

&lt;p&gt;当你觉得某个版本是一个有意义的里程碑的时候，你可以为这个版本打一个标记
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$git tag V3 5b888
&lt;/pre&gt;
这样就给5b888这个版本打了一个tag，之后就可以使用这个版本来作其他的操作了
如显示详情
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$git show V3
&lt;/pre&gt;
创建一个基于V3的分支
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git branch stable V3
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Git学习笔记(5) -- 独立开发者所用的命令(a)</title>
      <link>http://blog.prosight.me/blogs/287</link>
      <pubDate>2009-07-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;独立开发者的最大特点就是他们不需要和其他人来交换补丁，而且只在一个独立的固定的git仓库中工作。&lt;/p&gt;

&lt;p&gt;下面这些命令将可以帮助你完成日常工作：&lt;/p&gt;

&lt;p&gt;git-show-branch：可以显示你当前所在的分支以及提交记录。
git-log：显示提交日志
git-checkout或者git-branch：用于切换和创建分支
git-add：用于将修改内容加入到index文件中
git-diff和git-status：用于显示开发者所做的修改
git-commit：用于提交当前修改到git仓库。
git-reset和git-checkout：用于撤销某些修改
git-merge：用于合并两个分支
git-rebase：用于维护topic分支（此处我也不太懂，等完成git学习后转过头来会关注此问题）
git-tag：用于标记标签。&lt;/p&gt;

&lt;p&gt;git checkout 命令格式
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
git checkout [-q] [-f] [-m] [&lt;branch&gt;]
git checkout [-q] [-f] [-m] [-b &lt;new_branch&gt;] [&lt;start_point&gt;]
git checkout [-f|&amp;ndash;ours|&amp;ndash;theirs|-m|&amp;ndash;conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [&amp;ndash;] &lt;paths&gt;…
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;git checkout &lt;branch&gt; 切换到&lt;branch&gt;这个分支上
git checkouot -b &lt;new_branch&gt; 新建一个分支
git checkout v2.6.18 切换到v2.6.18这个tag的start_point上， 1.5以后的git支持&lt;/p&gt;

&lt;p&gt;下面的代码切换到master分支,后退Makefile两个版本,错误的删除了 hello.c , 然后再从index恢复它.
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git checkout master
$ git checkout master~2 Makefile
$ rm -f hello.c
$ git checkout &amp;ndash; hello.c
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;git branch 显示，新建和删除分支
命令格式：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
git branch [&amp;ndash;color | &amp;ndash;no-color] [-r | -a] [-v [&amp;ndash;abbrev=&lt;length&gt; | &amp;ndash;no-abbrev]] [(&amp;ndash;merged | &amp;ndash;no-merged | &amp;ndash;contains) [&lt;commit&gt;]]
git branch [&amp;ndash;track | &amp;ndash;no-track] [-l] [-f] &lt;branchname&gt; [&lt;start-point&gt;]
git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt; git branch (-d | -D) [-r] &lt;branchname&gt;…
&lt;/pre&gt;
git branch ，不带任何参数就是显示所有的本地分支。 带上-r参数，表示显示远程分支。 -a表示远程分支和本地分支都要
git branch &lt;branchname&gt; [&lt;start-point&gt;]  创建一个新的分支，如果后面有star-point就从这个版本创建分支，否则就从当前版本创建分支。这个命令只是创建分支，并没有checkout到它， 就是你没有切换到这个分支，你还是需要执行git checkout &lt;branchname&gt;来切换到这个分支上。&lt;/p&gt;

&lt;p&gt;例子：
从一个版本创建分支
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git clone git://git.kernel.org/pub/scm/&amp;hellip;/linux-2.6 my2.6
$ cd my2.6
$ git branch my2.6.14 v2.6.14  //前面一个参数是branch名，后面是指定的tag名，从这个版本创建分支
$ git checkout my2.6.14 //这两步可以合并为一步：&amp;rdquo;checkout -b my2.6.14 v2.6.14&amp;rdquo;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;git add 命令用于把修改过的文件或者新的文件加入到index中
这个命令可以在commit前执行多次。 可以利用git status来查看那些文件被add到index中，下次commit的时候会提交。&lt;/p&gt;

&lt;p&gt;例子：
添加所有目录Documentation（包括Documentation子目录）下的.txt文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git add Documentation/*.txt
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;添加所有git-&lt;em&gt;.sh脚本，子目录下的文件不会被add。 如subDir/git=foo.sh
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git add git-&lt;/em&gt;.sh
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Git学习笔记(2) -- 分支控制(branch)</title>
      <link>http://blog.prosight.me/blogs/277</link>
      <pubDate>2009-07-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;git branch
    列出所有的分支, -r参数表示列出所有远程的分支
git branch &lt;branch&gt;
    建立一个名为&lt;branch&gt;的分支,使用当前版本作为这个新分支的版本
git branch &lt;branch&gt; &lt;start-point&gt;
    建立一个名为&lt;branch&gt;的分支, 使用指定的 &lt;start-point&gt;作为新分支的版本,这个start-point可以是其他的分支名称或者tag名称。
git branch -d &lt;branch&gt;
    删除分支 &lt;branch&gt;; 如果你要删除的分支并没有被merge到当前分支的话，将产生一个错误提示。
git branch -D &lt;branch&gt;
    同-d，但是不管要删除的分支是否已经merge到当前分支，都会删除
git checkout &lt;branch&gt;
    切换当前分支到 &lt;branch&gt;, 更新 working directory 到&lt;branch&gt; 所对应的版本
git checkout -b &lt;new&gt; &lt;start-point&gt;
    按照&lt;start-point&gt;的版本建立一个新的分支&lt;new&gt;，然后再checkout到这个分支上。&lt;/p&gt;

&lt;p&gt;一个特殊符号 &amp;ldquo;HEAD&amp;rdquo; 总是指向当前分支. 实际上git使用一个在.git目录中叫 &amp;ldquo;HEAD&amp;rdquo;的文件来记录当前分支:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ cat .git/HEAD
ref: refs/heads/master
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;示例：
&amp;ldquo;master&amp;rdquo;分支是当初你执行git-clone时候，clone的一个远程repository的HEAD版本的一个copy.
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git branch -r
  origin/HEAD
  origin/html
  origin/maint
  origin/man
  origin/master
  origin/next
  origin/pu
  origin/todo
&lt;/pre&gt;
列出所有远程版本， origin是用来表示你当初执行git-clone时候的repository，你不可以直接checkout远程repository，但是你可以根据远程repository生成一个本地repository
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git checkout -b my-todo-copy origin/todo
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Git学习笔记(4) -- 基本命令</title>
      <link>http://blog.prosight.me/blogs/281</link>
      <pubDate>2009-07-22 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;git init&lt;/h3&gt;

&lt;p&gt;初始化一个本地目录，加入版本管理&lt;/p&gt;

&lt;h3&gt;git clone&lt;/h3&gt;

&lt;p&gt;克隆一个版本库(repository)到一个新的目录&lt;/p&gt;

&lt;p&gt;命令格式
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
git clone [&amp;ndash;template=&lt;template_directory&gt;] [-l] [-s] [&amp;ndash;no-hardlinks] [-q] [-n] [&amp;ndash;bare] [&amp;ndash;mirror] [-o &lt;name&gt;] [-u &lt;upload-pack&gt;] [&amp;ndash;reference &lt;repository&gt;] [&amp;ndash;depth &lt;depth&gt;] [&amp;ndash;] &lt;repository&gt; [&lt;directory&gt;]
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在clone后, 执行不带参数的git fetch的命令将更新远端的任何branches, 而执行不带参数的git pull的命令将merge远程的master branch到当前master branch&lt;/p&gt;

&lt;p&gt;&lt;repository&gt; 表示要clone的仓库名称，可以是本地或者远程的。 仓库可以由以下几种表现方式：
    rsync://host.xz/path/to/repo.git/
    &lt;a href=&#34;http://host.xz[:port]/path/to/repo.git/&#34;&gt;http://host.xz[:port]/path/to/repo.git/&lt;/a&gt;
    &lt;a href=&#34;https://host.xz[:port]/path/to/repo.git/&#34;&gt;https://host.xz[:port]/path/to/repo.git/&lt;/a&gt;
    git://host.xz[:port]/path/to/repo.git/
    git://host.xz[:port]/~user/path/to/repo.git/
    ssh://[user@]host.xz[:port]/path/to/repo.git/
    ssh://[user@]host.xz/path/to/repo.git/
    ssh://[user@]host.xz/~user/path/to/repo.git/
    ssh://[user@]host.xz/~/path/to/repo.git&lt;/p&gt;

&lt;p&gt;其中ssh是默认协议，所以如果使用ssh协议可以不写ssh的协议名&lt;/p&gt;

&lt;p&gt;如果使用本地仓库，可以使用以下路径：
    /path/to/repo.git/
    file:///path/to/repo.git/
使用以上仓库路径，就相当于显式的使用了-l或-local参数&lt;/p&gt;

&lt;p&gt;&lt;directory&gt; 表示你本地的路径名，会将远程的仓库的内容clone这个目录里面。&lt;/p&gt;

&lt;p&gt;参考：
&lt;a href=&#34;http://www.kernel.org/pub/software/scm/git/docs/everyday.html&#34; target=&#34;_blank&#34;&gt;Everyday GIT With 20 Commands Or So&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Git学习笔记(1) -- 创建和修改项目</title>
      <link>http://blog.prosight.me/blogs/274</link>
      <pubDate>2009-07-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;当你设置好gitosis(&lt;a href=&#34;http://blog.prosight.me/index.php/2009/07/271&#34;&gt;使用gitosis来配置管理git服务器端&lt;/a&gt;)后，就可以使用git来管理你的项目了。&lt;/p&gt;

&lt;p&gt;当新创建一个项目的时候，需要在gitosis的gitosis.conf文件中添加对应的项目
&lt;pre class=&#34;prettyprint linenums&#34;&gt;# cd gitosis-admin&lt;/p&gt;

&lt;h1&gt;vim gitosis.conf&lt;/h1&gt;

&lt;p&gt;添加：
[group myteam] #team名称
members = elton@macbook #开发者名称
writable = project_name #项目名称，表示members中的开发者对这个项目可写&lt;/pre&gt;
之后，进入你这个项目的目录，执行以下命令
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ cd your_project
$ git remote add origin git@YOUR_SERVER_HOSTNAME:project_name.git&lt;/pre&gt;
其中project_name.git中的project_name跟gitosis.conf中的项目名称一样。添加远程repo&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;初始化项目&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;git init&lt;/pre&gt;
git init命令用于初始化当前所在目录的这个项目，shell返回的提示表明已经建立了一个.git隐藏目录来保存这个项目目前的进展信息。我们可以用ls -a看到它。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;添加文件到git index&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;git add .&lt;/pre&gt;
git add .这个命令要求git给我目前的这个项目制作一个快照snapshot（快照只是登记留名，快照不等于记录在案，git管快照叫做索引index)。快照一般会暂时存储在一个临时存储区域中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提交&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;git commit -m &amp;ldquo;init the project&amp;rdquo;&lt;/pre&gt;
git commit用于将快照里登记的内容永久写入git仓库中，也就是开发者已经想好了要提交自己的开发成果了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查找更改&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;git diff –cached
git diff&lt;/pre&gt;
git diff –cached是用来查看index file(快照)和仓库之间代码的区别的。
git diff 是比较working tree和index file(快照)的区别，working tree就是表示你的源文件
当你修改过源代码后，但是没有commit的时候，git diff –cached是没有输出结果的，但是git diff有结果，列出了源文件和index之间的差别。 当你提交后，git diff –cached就有输出结果了，而git diff就没有了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;查看状态&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;git status&lt;/p&gt;

&lt;h1&gt;On branch master&lt;/h1&gt;

&lt;h1&gt;Changed but not updated:&lt;/h1&gt;

&lt;h1&gt;(use “git add …” to update what will be committed)&lt;/h1&gt;

&lt;p&gt;#&lt;/p&gt;

&lt;h1&gt;modified:   main.c&lt;/h1&gt;

&lt;p&gt;#
no changes added to commit (use “git add” and/or “git commit -a”)&lt;/pre&gt;
可以看到提示信息“changed but not updated”，就是说git发现你有已经修改了但还未git add的内容。 如果git提示说“Changes to be committed”，那就是表明git发现了你已经git add但还未git commit的内容。 如果git提示说“Untracked files”，那么就是你增加了新文件或者在某个子目录下增加了新文件  &lt;strong&gt;添加修改&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;git add&lt;/pre&gt;
这句是要告诉git，我已经修改了文件，你（指git）去检查一下。当然，如果你新增加了一个文件，比如new.c，也需要在这里先执行git add new.c告诉git。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;提交修改&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;git commit -m &amp;ldquo;some comments for this update&amp;rdquo;&lt;/pre&gt;
&lt;strong&gt;查看日志&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;git log&lt;/pre&gt;
总体流程就是
&lt;ol&gt;
    &lt;li&gt;git add remote 添加远程仓库&lt;/li&gt;
    &lt;li&gt;git init 初始化项目&lt;/li&gt;
    &lt;li&gt;git add . 添加整个项目&lt;/li&gt;
    &lt;li&gt;git commit 提交整个项目&lt;/li&gt;
    &lt;li&gt;修改源文件&lt;/li&gt;
    &lt;li&gt;git diff 发现哪些文件被修改了&lt;/li&gt;
    &lt;li&gt;git status 查看状态&lt;/li&gt;
    &lt;li&gt;git add 将修改过的文件通知git&lt;/li&gt;
    &lt;li&gt;git commit 提交修改&lt;/li&gt;
    &lt;li&gt;git log 查看日志&lt;/li&gt;
&lt;/ol&gt;&lt;/p&gt;

&lt;p&gt;有一个快捷的方法git commit -a，这个命令可以直接提交所有修改，省去了你git add和git commit的工序，但是如果新建了一个目录，还是要进入那个目录git add .后再git commit，无法使用这个快捷方式。&lt;/p&gt;

&lt;p&gt;另外，对于commit中的描述，第一行一定要是少于50字的开发概括信息，而且第二行务必是空行，第三行开始才可以开始细致描述开发信息。这是因为很多版本服务系统中的email机制都会选取log中的第一行为邮件题目。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Git学习笔记(7) -- 独立开发者所用的命令(c)</title>
      <link>http://blog.prosight.me/blogs/297</link>
      <pubDate>2009-07-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;这次我们看一些实例&lt;/p&gt;

&lt;p&gt;Use a tarball as a starting point for a new repository.
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ tar zxf frotz.tar.gz
$ cd frotz
$ git init
$ git add . //添加所有文件到index
$ git commit -m &amp;ldquo;import of frotz source tree.&amp;rdquo;
$ git tag v2.43&lt;/pre&gt;
Create a topic branch and develop.
&lt;pre class=&#34;prettyprint linenums&#34;&gt;$ git checkout -b alsa-audio (1)
$ edit/compile/test
$ git checkout &amp;ndash; curses/ux_audio_oss.c (2)
$ git add curses/ux_audio_alsa.c (3)
$ edit/compile/test
$ git diff HEAD (4)
$ git commit -a -s (5)
$ edit/compile/test
$ git reset &amp;ndash;soft HEAD^ (6)
$ edit/compile/test
$ git diff ORIG_HEAD (7)
$ git commit -a -c ORIG_HEAD (8)
$ git checkout master (9)
$ git merge alsa-audio (10)
$ git log &amp;ndash;since=&amp;lsquo;3 days ago&amp;rsquo; (11)
$ git log v2.43.. curses/ (12)&lt;/pre&gt;
&lt;ol&gt;
    &lt;li&gt;create a new topic branch.&lt;/li&gt;
    &lt;li&gt;revert your botched changes in curses/ux_audio_oss.c.&lt;/li&gt;
    &lt;li&gt;you need to tell git if you added a new file; removal and modification will be caught if you do git commit -a later.&lt;/li&gt;
    &lt;li&gt;to see what changes you are committing.&lt;/li&gt;
    &lt;li&gt;commit everything as you have tested, with your sign-off.&lt;/li&gt;
    &lt;li&gt;take the last commit back, keeping what is in the working tree.&lt;/li&gt;
    &lt;li&gt;look at the changes since the premature commit we took back.&lt;/li&gt;
    &lt;li&gt;redo the commit undone in the previous step, using the message you originally wrote.&lt;/li&gt;
    &lt;li&gt;switch to the master branch.&lt;/li&gt;
    &lt;li&gt;merge a topic branch into your master branch.&lt;/li&gt;
    &lt;li&gt;review commit logs; other forms to limit output can be combined and include &amp;ndash;max-count=10 (show 10 commits), &amp;ndash;until=2005-12-10, etc.&lt;/li&gt;
    &lt;li&gt;view only the changes that touch what&amp;rsquo;s in curses/ directory, since v2.43 tag.&lt;/li&gt;
&lt;/ol&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Git学习笔记(6) -- 独立开发者所用的命令(b)</title>
      <link>http://blog.prosight.me/blogs/290</link>
      <pubDate>2009-07-22 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;git commit 将当前在index中变化的内容提交到仓库（repository）中
语法：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;git commit [-a | &amp;ndash;interactive] [-s] [-v] [-u] [&amp;ndash;amend] [(-c | -C) ] [-F  | -m ] [&amp;ndash;allow-empty] [&amp;ndash;no-verify] [-e] [&amp;ndash;author=] [&amp;ndash;cleanup=] [&amp;ndash;] [[-i | -o ]…]&lt;/pre&gt;
&lt;ol&gt;
    &lt;li&gt;使用git add命令可以持续的将变动或者新增的内容添加到index中。&lt;/li&gt;
    &lt;li&gt;使用git rm 可以将文件从woking tree和index中移除。&lt;/li&gt;
    &lt;li&gt;作为参数列在后面的文件，将忽略在index中的变化，而直接使用当前的内容作为提交内容。（例如你之前add过这个文件，但是在add后，又修改过且没有再次add）&lt;/li&gt;
    &lt;li&gt;使用-a参数就自动将所有变化的文件执行add操作（这些文件曾经都被add到index中），并将所有在working tree中移除的文件从Index中移除，之后再进行commit&lt;/li&gt;
&lt;/ol&gt;&lt;/p&gt;

&lt;p&gt;git-reset 重置当前HEAD到指定的状态
适合与你发现刚才作的一些操作是错误的，要Undo一些操作
语法：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
git reset [&amp;ndash;mixed | &amp;ndash;soft | &amp;ndash;hard | &amp;ndash;merge] [-q] [&lt;commit&gt;]
git reset [-q] [&lt;commit&gt;] [&amp;ndash;] &lt;paths&gt;…
&lt;/pre&gt;
&amp;ndash;soft,表示不变更working tree和index
&amp;ndash;hard，表示working tree和index一同变更&lt;/p&gt;

&lt;p&gt;例子：
Undo一个commit再Redo
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git commit &amp;hellip;
$ git reset &amp;ndash;soft HEAD^      回退到上一次commit，并不改变workingtree和index
编辑一些内容
$ git commit -a -c ORIG_HEAD  再次按照原来的HEAD的注释提交,-c表示使用原来的commit时候的注释
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;永久的回退
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git commit &amp;hellip;
$ git reset &amp;ndash;hard HEAD~3   //永久删掉HEAD，HEAD^和HEAD~2三个版本
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;git checkout 切换当前分支
git checkout &lt;branch&gt; 切换到&lt;branch&gt;分支
git checkout -b &lt;new branch&gt; 建立新分支并切换上去
git checkout -b &lt;new branch&gt; v2 从某一个start point开始创建新分支，并切换上去
git checkout v2.3 将当前HEAD从现有分支上解除，直接指向新的tag版本 1.5以后支持。&lt;/p&gt;

&lt;p&gt;例子：
切换分支到master，将Makefile文件回退两个版本，错误删除了hello.c，再从index中恢复
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ git checkout master             (1)
$ git checkout master~2 Makefile  (2)
$ rm -f hello.c
$ git checkout &amp;ndash; hello.c            (3)
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Gentoo下Nginx+thin构建rails环境</title>
      <link>http://blog.prosight.me/blogs/265</link>
      <pubDate>2009-07-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;本文前提是你已经配置好了ruby on rails&lt;/p&gt;

&lt;h3&gt;安装thin&lt;/h3&gt;

&lt;p&gt;thin是一个ruby的轻量级的web server
&lt;img class=&#34;alignnone&#34; title=&#34;thin&#34; src=&#34;http://chart.apis.google.com/chart?cht=bvg&amp;amp;chd=t:14.98,54.8723076923077,48.9184615384615,79.9276923076923|14.8692307692308,65.0615384615385,70.4446153846154,89.5553846153846|14.9476923076923,35.1123076923077,70.18,88.6769230769231&amp;amp;chbh=16&amp;amp;chs=350x150&amp;amp;chl=WEBrick|Mongrel|Evented%20M.|Thin&amp;amp;chco=000000,666666,cccccc&amp;amp;chdl=1%20c%20req.|10%20c%20req.|100%20c%20req.&#34; alt=&#34;&#34; width=&#34;350&#34; height=&#34;150&#34; /&gt;
可以看到thin在100个并发连接的时候，性能还是不错的。&lt;/p&gt;

&lt;p&gt;可以使用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;sudo gem install thin&lt;/pre&gt;
或者
&lt;pre class=&#34;prettyprint linenums&#34;&gt;emerage -av thin&lt;/pre&gt;
使用emerage的话，需要在/etc/portage/package.keywords中加入
&lt;pre class=&#34;prettyprint linenums&#34;&gt;www-servers/thin ~amd64
dev-ruby/eventmachine ~amd64
dev-ruby/rack ~amd64&lt;/pre&gt;
因为相关的包被gentoo的portage给mask了&lt;/p&gt;

&lt;h3&gt;创建thin集群rake脚本&lt;/h3&gt;

&lt;p&gt;进入你的rails应用目录，在lib/tasks下建立一个thin的任务，以.rake为后缀名，如thin.rake。这个是用来建立thin的集群的脚本
编辑内容如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;namespace :thin do
  namespace :cluster do
　desc &amp;lsquo;Start thin cluster&amp;rsquo;
    task :start =&amp;gt; :environment do
      &lt;code&gt;cd #{RAILS_ROOT}&lt;/code&gt;
      port_range = RAILS_ENV == &amp;lsquo;development&amp;rsquo; ? 3 : 8
      (ENV[&amp;lsquo;SIZE&amp;rsquo;] ? ENV[&amp;lsquo;SIZE&amp;rsquo;].to_i : 4).times do |i|
        Thread.new do
          port = ENV[&amp;lsquo;PORT&amp;rsquo;] ? ENV[&amp;lsquo;PORT&amp;rsquo;].to_i + i : (&amp;ldquo;#{port_range}%03d&amp;rdquo; % i)
          str  = &amp;ldquo;thin start -d -p#{port} -Ptmp/pids/thin-#{port}.pid&amp;rdquo;
          str += &amp;ldquo; -e#{RAILS_ENV}&amp;rdquo;
          puts str
          puts &amp;ldquo;Starting server on port #{port}&amp;hellip;&amp;rdquo;
          &lt;code&gt;#{str}&lt;/code&gt;
        end
      end
    end
desc &amp;lsquo;Stop all thin clusters&amp;rsquo;
    task :stop =&amp;gt; :environment do
      &lt;code&gt;cd #{RAILS_ROOT}&lt;/code&gt;
      Dir.new(&amp;ldquo;#{RAILS_ROOT}/tmp/pids&amp;rdquo;).each do |file|
        Thread.new do
          if file.starts_with?(&amp;ldquo;thin-&amp;rdquo;)
            str  = &amp;ldquo;thin stop -Ptmp/pids/#{file}&amp;rdquo;
            puts &amp;ldquo;Stopping server on port #{file[/d+/]}&amp;hellip;&amp;rdquo;
            &lt;code&gt;#{str}&lt;/code&gt;
          end
        end
      end
    end
  end
end&lt;/pre&gt;
之后就可以使用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;# rake thin:cluster:start RAILS_ENV=production SIZE=3 PORT=8000&lt;/p&gt;

&lt;h1&gt;rake thin:cluster:stop&lt;/pre&gt;&lt;/h1&gt;

&lt;p&gt;来启动和停止thin集群了。&lt;/p&gt;

&lt;h3&gt;编辑nginx的conf文件，加入rails虚拟主机&lt;/h3&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;
upstream thin {
    server 127.0.0.1:8000;
    server 127.0.0.1:8001;
    server 127.0.0.1:8002;
}&lt;/p&gt;

&lt;p&gt;server {
        listen   80;
        server_name  localhost;
        access_log  /var/log/nginx/localhost.access.log;
        root /var/www/test/public;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    location / {
            proxy_set_header  X-Real-IP  $remote_addr;
            proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header Host $http_host;
            proxy_redirect false;
            if (-f $request_filename/index.html) {
                    rewrite (.*) $1/index.html break;
            }
            if (-f $request_filename.html) {
                    rewrite (.*) $1.html break;
            }
             if (!-f $request_filename) {
                    proxy_pass http://thin;
                    break;
            }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;
重启nginx就可以运行rails应用了。&lt;/p&gt;

&lt;p&gt;参考：
&lt;a href=&#34;http://code.macournoyer.com/thin/&#34; target=&#34;_blank&#34;&gt;http://code.macournoyer.com/thin/&lt;/a&gt;
&lt;a href=&#34;http://glauche.de/2008/01/12/thin-nginx-with-rails/&#34; target=&#34;_blank&#34;&gt;http://glauche.de/&lt;sup&gt;2008&lt;/sup&gt;&amp;frasl;&lt;sub&gt;01&lt;/sub&gt;/12/thin-nginx-with-rails/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>使用gitosis来配置管理git服务器端</title>
      <link>http://blog.prosight.me/blogs/271</link>
      <pubDate>2009-07-21 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;1. 安装git&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
emerge -av dev-util/git
&lt;/pre&gt;
### 2.安装gitosis
git环境默认是可以直接使用的,但需要为每个成员开ssh权限帐号,且各个仓库之间的交叉权限管理很麻烦，所以需要使用gitosis, 它无需为每个开发人员开设ssh帐号，安全方便。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
emerge -av gitosis
&lt;/pre&gt;
如果提示这个包被mask了，需要编辑/etc/portage/package.keywords文件，在里面加入
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
dev-util/gitosis ~amd64
&lt;/pre&gt;
### 3.生成公钥
在客户端使用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ssh-keygen -t rsa
&lt;/pre&gt;
来生成ssh的key，注意你的主机名需要是全部英文字符，不能有下划线或者.之类的特殊字符，否则后面在服务端生成版本库的时候会报错。
### 4.上传公钥
从客户端把刚刚生成的公钥上传到服务器上。
&lt;pre class=&#34;prettyprint linenums&#34;&gt; 
scp ~/.ssh/id_rsa.pub USER@YOUR_SERVER:/tmp
&lt;/pre&gt;
### 5.在服务端生成管理库
&lt;pre class=&#34;prettyprint linenums&#34;&gt; 
sudo -H -u git gitosis-init &lt; /tmp/id_rsa.pub
&lt;/pre&gt;
成功的话，你将看到类似下面的提示：
&lt;pre class=&#34;prettyprint linenums&#34;&gt; 
Initialized empty Git repository in /var/spool/gitosis/repositories/gitosis-admin.git/
Reinitialized existing Git repository in /var/spool/gitosis/repositories/gitosis-admin.git/
&lt;/pre&gt;
设置post-update脚本权限
&lt;pre class=&#34;prettyprint linenums&#34;&gt; 
chmod 755 /var/spool/gitosis/repositories/gitosis-admin.git/hooks/post-update
&lt;/pre&gt;
至此，服务端配置已经完成。 

### 6.同步配置文件
gitosis本身就是一个git库，所以管理起来非常方便。下面在客户端同步gitosis管理库
&lt;pre class=&#34;prettyprint linenums&#34;&gt; 
git clone git@YOUR_SERVER:gitosis-admin.git
cd gitosis-admin
&lt;/pre&gt;
你将看到以下文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-rw-r--r--   1 garry  garry  104 Nov 13 05:43 gitosis.conf
drwxr-xr-x   3 garry  garry  102 Nov 13 05:43 keydir/
&lt;/pre&gt;
gitosis.conf是gitosis的配置文件，用于配置用户和权限
keydir/是所有组成员的公钥
我们可以在本地修改配置更改权限，然后push到服务端后，服务器端就立刻生效

### 7.创建新的repositories
打开gitosis.conf文件，你将看到
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[group gitosis-admin]
writable = gitosis-admin
members = elton@macbook
&lt;/pre&gt;
这个是管理组的权限，members中的用户名就是刚才上传的公钥里面的用户名。
在这个文件后面加入:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[group myteam]
members = elton@macbook
writable = free_monkey
&lt;/pre&gt;
这里你定义了一个叫myteam的组，授予elton@macbook这个用户写“free_monkey&#34;这个repo的权限
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
git commit -a -m &#34;Allow elton write access to free_monkey&#34;
git push
&lt;/pre&gt;
上面的操作就更新了服务端的权限。
下面就开始创建free_monkey的repo
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
mkdir free_monkey
cd free_monkey
git init
&lt;/pre&gt;
创建 .gitignore 文件，用于忽略某些不需要进行代码管理的内容，如rails的应用可能如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
.DS_Store
log/*.log
tmp/**/*
config/database.yml
db/*.sqlite3
&lt;/pre&gt;

&lt;p&gt;提交代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
git remote add origin git@YOUR_SERVER_HOSTNAME:free_monkey.git
git add .
git commit -a -m &amp;ldquo;initial import&amp;rdquo;&lt;/p&gt;

&lt;p&gt;git push origin master:refs/heads/master
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;接下来，可以增加成员的公钥到系统中了
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cd gitosis-admin
cp ~/alice.pub keydir/
cp ~/bob.pub keydir/
git add keydir/alice.pub keydir/bob.pub
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;修改gitosis.conf
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[group myteam]
- members = jdoe
+ members = jdoe alice bob
  writable = free_monkey
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;提交修改：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
git commit -a -m &amp;ldquo;Granted Alice and Bob commit rights to FreeMonkey&amp;rdquo;
git push
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;其它成员就可以获取代码了
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
git clone git@YOUR_SERVER:free_monkey.git
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;参考：
&lt;a href=&#34;http://scie.nti.st/2007/11/14/hosting-git-repositories-the-easy-and-secure-way&#34;&gt;Hosting Git repositories, The Easy (and Secure) Way&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Gentoo安装SNMP &amp; MRTG 本机监控</title>
      <link>http://blog.prosight.me/blogs/258</link>
      <pubDate>2009-07-20 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;必要组件：
&lt;ul&gt;
    &lt;li&gt;[net-analyzer/net-snmp]&lt;/li&gt;
    &lt;li&gt;[media-libs/gd]&lt;/li&gt;
    &lt;li&gt;[net-analyzer/mrtg]&lt;/li&gt;
    &lt;li&gt;[sys-process/vixie-cron&lt;span&gt;]&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;

&lt;h3&gt;0) 切换用户&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;/bin/su -&lt;/pre&gt;
### 1) 创建目录
&lt;pre class=&#34;prettyprint linenums&#34;&gt;/usr/bin/mkdir /etc/mrtg
/usr/bin/mkdir /etc/cron.mrtg
/usr/bin/mkdir /var/www/localhost/mrtg&lt;/pre&gt;
### 2) 创建snmpd.conf文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;vim /etc/snmp/snmpd.conf
com2sec local     127.0.0.1/32    public
com2sec local     10.10.10.0/24   public

group MyROGroup v1         local
group MyROGroup v2c        local
group MyROGroup usm        local

view all    included  .1                               80

access MyROGroup &#34;&#34;      any       noauth    exact  all    none   none

syslocation MyLocation
syscontact Me &lt;me@somewhere.org&gt; &lt;/pre&gt;
编辑 /etc/conf.d/snmpd 在SNMPD_FLAGS里面添加
&lt;pre class=&#34;prettyprint linenums&#34;&gt;-c /etc/snmp/snmpd.conf&lt;/pre&gt;
如：SNMPD_FLAGS=&#34;-c /etc/snmp/snmpd.conf&#34;
### 3) 创建守护进程
&lt;pre class=&#34;prettyprint linenums&#34;&gt;/etc/init.d/snmpd start
/sbin/rc-update add snmpd default&lt;/pre&gt;
### 4) 配置
Traffic:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;/usr/bin/cfgmaker  
--output=/etc/mrtg/traffic.cfg 
--ifdesc=ip 
--ifref=descr 
--global &#34;WorkDir: /var/www/localhost/mrtg&#34; 
--global &#34;Options[_]: bits,growright&#34; 
public@localhost&lt;/pre&gt;

&lt;p&gt;Cpu:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /etc/mrtg/cpu.cfg
WorkDir: /var/www/localhost/mrtg
LoadMIBs: /usr/share/snmp/mibs/UCD-SNMP-MIB.txt
Target[localhost.cpu]:ssCpuRawUser.0&amp;amp;ssCpuRawUser.0:public@localhost + ssCpuRawSystem.0&amp;amp;ssCpuRawSystem.0:public@localhost + ssCpuRawNice.0&amp;amp;ssCpuRawNice.0:public@localhost
RouterUptime[localhost.cpu]: public@localhost
MaxBytes[localhost.cpu]: 100
Title[localhost.cpu]: CPU Load
PageTop[localhost.cpu]: &lt;H1&gt;Active CPU Load %&lt;/H1&gt;
Unscaled[localhost.cpu]: ymwd
ShortLegend[localhost.cpu]: %
YLegend[localhost.cpu]: CPU Utilization
Legend1[localhost.cpu]: Active CPU in % (Load)
Legend2[localhost.cpu]:
Legend3[localhost.cpu]:
Legend4[localhost.cpu]:
LegendI[localhost.cpu]:  Active
LegendO[localhost.cpu]:
Options[localhost.cpu]: growright,nopercent
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Mem:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /etc/mrtg/mem.cfg
LoadMIBs: /usr/share/snmp/mibs/HOST-RESOURCES-MIB.txt
Target[localhost.mem]: .1.3.6.1.4.1.2021.4.11.0&amp;amp;.1.3.6.1.4.1.2021.4.11.0:public@localhost
PageTop[localhost.mem]: &lt;H1&gt;Free Memory &lt;/H1&gt;
WorkDir: /var/www/localhost/mrtg
Options[localhost.mem]: nopercent,growright,gauge,noinfo
Title[localhost.mem]: Free Memory
MaxBytes[localhost.mem]: 1000000
kMG[localhost.mem]: k,M,G,T,P,X
YLegend[localhost.mem]: bytes
ShortLegend[localhost.mem]: bytes
LegendI[localhost.mem]:  Free Memory:
LegendO[localhost.mem]:
Legend1[localhost.mem]: Free memory, not including swap, in bytes
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Swap:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /etc/mrtg/swap.cfg
LoadMIBs: /usr/share/snmp/mibs/UCD-SNMP-MIB.txt
Target[localhost.swap]: memAvailSwap.0&amp;amp;memAvailSwap.0:public@localhost
PageTop[localhost.swap]: &lt;H1&gt;Swap Memory&lt;/H1&gt;
WorkDir: /var/www/localhost/mrtg
Options[localhost.swap]: nopercent,growright,gauge,noinfo
Title[localhost.swap]: Free Memory
MaxBytes[localhost.swap]: 1000000
kMG[localhost.swap]: k,M,G,T,P,X
YLegend[localhost.swap]: bytes
ShortLegend[localhost.swap]: bytes
LegendI[localhost.swap]:  Free Memory:
LegendO[localhost.swap]:
Legend1[localhost.swap]: Swap memory avail, in bytes
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Ping:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /etc/mrtg/ping.cfg
WorkDir: /var/www/localhost/mrtg
Title[mithril.ping]: Round Trip Time
PageTop[mithril.ping]: &lt;H1&gt;Round Trip Time&lt;/H1&gt;
Target[mithril.ping]: &lt;code&gt;/etc/mrtg/ping.sh&lt;/code&gt;
MaxBytes[mithril.ping]: 2000
Options[mithril.ping]: growright,unknaszero,nopercent,gauge
LegendI[mithril.ping]: Pkt loss %
LegendO[mithril.ping]: Avg RTT
Legend1[mithril.ping]: Maximum Round Trip Time in ms
Legend2[mithril.ping]: Minimum Round Trip Time in ms
#Legend3[mithril.ping]: Maximal 5 Minute Maximum Round Trip Time in ms
#Legend4[mithril.ping]: Maximal 5 Minute Minimum Round Trip Time in ms
YLegend[mithril.ping]: RTT (ms)
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;5) 创建脚本&lt;/h3&gt;

&lt;p&gt;Traffic:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /etc/cron.mrtg/traffic.sh
#!/bin/sh
/usr/bin/mrtg /etc/mrtg/traffic.cfg
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Cpu:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /etc/cron.mrtg/cpu.sh
#!/bin/sh
/usr/bin/mrtg /etc/mrtg/cpu.cfg
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Mem:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /etc/cron.mrtg/mem.sh
#!/bin/sh
/usr/bin/mrtg /etc/mrtg/mem.cfg
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Swap:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /etc/cron.mrtg/swap.sh
#!/bin/sh
/usr/bin/mrtg /etc/mrtg/swap.cfg
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;Ping:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /etc/cron.mrtg/ping.sh
#!/bin/sh
/usr/bin/mrtg /etc/mrtg/ping.cfg
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;ping.sh
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
vim /etc/mrtg/ping.sh
#!/bin/sh
PING=&amp;ldquo;/bin/ping&amp;rdquo;&lt;/p&gt;

&lt;h1&gt;Google, for example&lt;/h1&gt;

&lt;p&gt;ADDR=&amp;ldquo;google.com&amp;rdquo;
DATA=&lt;code&gt;$PING -c10 -s500 $ADDR -q&lt;/code&gt;
LOSS=&lt;code&gt;echo $DATA | awk &#39;{print $18 }&#39; | tr -d %&lt;/code&gt;
echo $LOSS
if [ $LOSS = 100 ];
then
               echo 0
else
        echo $DATA | awk -F/ &amp;lsquo;{print $5 }&amp;rsquo;
fi
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;赋予脚本可执行权限
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/bin/chmod +x /etc/cron.mrtg/*.sh
/bin/chmod +x /etc/mrtg/ping.sh
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;下面的每个脚本执行3次，不必理会warning
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/etc/cron.mrtg/traffic.sh
/etc/cron.mrtg/cpu.sh
/etc/cron.mrtg/mem.sh
/etc/cron.mrtg/swap.sh
/etc/cron.mrtg/ping.sh
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;6) 创建MRTG首页&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/usr/bin/indexmaker --output=/var/www/localhost/mrtg/index.html 
--title=&#34;Power Under Control : )&#34; 
--sort=name 
--enumerate 
/etc/mrtg/traffic.cfg 
/etc/mrtg/cpu.cfg 
/etc/mrtg/mem.cfg 
/etc/mrtg/swap.cfg 
/etc/mrtg/ping.cfg 
&lt;/pre&gt;

&lt;h3&gt;7) 计划任务&lt;/h3&gt;

&lt;p&gt;每5分钟执行一次数据更新
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
usr/bin/crontab -e
*/5 * * * * /bin/run-parts /etc/cron.mrtg 1&amp;gt; /dev/null
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;现在就有一个html文件生成好了/var/www/localhost/www/index.html
将你的web服务器设置好，打开流量器就可以看到统计数据了。&lt;/p&gt;

&lt;p&gt;参考链接：&lt;a href=&#34;http://forums.gentoo.org/viewtopic-t-105862.html&#34; target=&#34;_blank&#34;&gt;http://forums.gentoo.org/viewtopic-t-105862.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Gentoo下安装Nginx+php</title>
      <link>http://blog.prosight.me/blogs/250</link>
      <pubDate>2009-07-19 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用nginx(engin x)和spawn-fcgi来共同支持php&lt;/p&gt;

&lt;h3&gt;安装nginx&lt;/h3&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;emerge -av nginx&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;安装spawn-fcgi&lt;/h3&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;emerge -av spawn-fcgi&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;启动spawn-fcgi&lt;/h3&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;spawn-fcgi -a 127.0.0.1 -p 9000 -f /usr/bin/php-cgi -C 10&lt;/pre&gt;
a 表示绑定的ip地址
p 表示端口号
f 表示fcgi的应用程序，在这里是制定php的cgi版本的程序
C 表示spawn的child的个数&lt;/p&gt;

&lt;p&gt;执行netstat检查spwan-fcgi是否正常启动，可以看到9000端口是否已经开始监听
&lt;pre class=&#34;prettyprint linenums&#34;&gt;netstat -tnpl&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;配置nginx&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;编辑nginx.conf文件&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;user nginx nginx;
worker_processes 8;
worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;&lt;/p&gt;

&lt;p&gt;error_log /var/log/nginx/error_log info;&lt;/p&gt;

&lt;p&gt;#Specifies the value for maximum file descriptors that can be opened by this process.
worker_rlimit_nofile 51200;&lt;/p&gt;

&lt;p&gt;events {
        worker_connections  8192;
        use epoll;
}&lt;/p&gt;

&lt;p&gt;http {
        include         /etc/nginx/mime.types;
        default_type    application/octet-stream;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    log_format main
            &#39;$remote_addr - $remote_user [$time_local] &#39;
            &#39;&amp;quot;$request&amp;quot; $status $bytes_sent &#39;
            &#39;&amp;quot;$http_referer&amp;quot; &amp;quot;$http_user_agent&amp;quot; &#39;
            &#39;&amp;quot;$gzip_ratio&amp;quot;&#39;;

    client_header_timeout   10m;
    client_body_timeout     10m;
    client_max_body_size 50m; #最大允许上传50M的附件
    send_timeout            10m;

    connection_pool_size            512;
    client_header_buffer_size       8k;
    large_client_header_buffers     4 4k;
    request_pool_size               1024k;

    gzip on;
    gzip_min_length 1k;
    gzip_buffers    4 8k;
    gzip_http_version  1.1;
    gzip_types   text/plain application/x-javascript text/css application/xml;

    output_buffers  1 1024k;
    postpone_output 1460;

    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;

    keepalive_timeout       75 20;
    ignore_invalid_headers  on;
    index index.html;

    include /data/www/vhosts/*.conf;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中，worker_processes表示worker进程的个数，一般跟CPU个数相同
worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000
表示每个CPU处理一个worker&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;虚拟主机配置&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;server {
        index           index.htm index.html index.php
        server_name     blog.domain.com;
        access_log      /var/log/nginx/domain.access_log main;
        error_log       /var/log/nginx/domain.error_log info;
        root            /data/www/domain/htdocs/blog;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    location / {
            if (-f $request_filename/index.html){
                    rewrite (.*) $1/index.html break;
            }

            if (-f $request_filename/index.php){
                    rewrite (.*) $1/index.php;
            }

            if (!-f $request_filename){
                    rewrite (.*) /index.php;
            }
    }

    location ~ .*.php$ {
            include /etc/nginx/fastcgi_params;
            fastcgi_index index.php;
            fastcgi_pass  127.0.0.1:9000;
            fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;        }

     location ~ .(htm|html|gif|jpg|jpeg|png|bmp|ico|css|js)$ {
            expires 30d;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/pre&gt;
上面的配置以wordpress的静态url为例
其中，location ~ .*.php$ 部分是配置php的fcgi
expires，是设置静态资源的缓存时间
rewrite部分是设置wordpress静态url时候需要用到的rewrite&lt;/p&gt;

&lt;h3&gt;Nginx日常维护&lt;/h3&gt;

&lt;p&gt;Nginx 支持下表中的信号：
信号名                      作用描述
TERM, INT                快速关闭程序，中止当前正在处理的请求
QUIT                        处理完当前请求后，关闭程序
HUP                         重新加载配置，并开启新的工作进程，关闭就的进程，此操作不会中断请求
USR1                       重新打开日志文件，用于切换日志，例如每天生成一个新的日志文件
USR2                       平滑升级可执行程序
WINCH                    从容关闭工作进程&lt;/p&gt;

&lt;p&gt;如要重新加载配置文件就使用如下命令
&lt;pre class=&#34;prettyprint linenums&#34;&gt;#kill -HUP &lt;pid&gt;&lt;/pre&gt;
pid是nginx的进称号，通过netstat -tnpl可以查到&lt;/p&gt;

&lt;h3&gt;Nginx 监控&lt;/h3&gt;

&lt;p&gt;通过在配置文件中加入：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;location ~ ^/status/ {
        stub_status on; #Nginx 状态监控配置
        access_log off;
     }&lt;/pre&gt;
就可以使用http://yourdomain.com/stauts监控nginx的状态。
可以看到类似这样的信息
&lt;pre class=&#34;prettyprint linenums&#34;&gt;Active connections: 70
server accepts handled requests
 14553819 14553819 19239266
Reading: 0 Writing: 3 Waiting: 67&lt;/pre&gt;
&lt;ul&gt;
    &lt;li&gt;active connections – 当前 Nginx 正处理的活动连接数.&lt;/li&gt;
    &lt;li&gt;server accepts handled requests &amp;ndash; 总共处理了 14553819 个连接 , 成功创建 14553819 次握手 ( 证明中间没有失败的 ), 总共处理了 19239266 个请求 ( 平均每次握手处理了 1.3 个数据请求 )&lt;/li&gt;
    &lt;li&gt;reading &amp;ndash; nginx 读取到客户端的 Header 信息数&lt;/li&gt;
    &lt;li&gt;writing &amp;ndash; nginx 返回给客户端的 Header 信息数。&lt;/li&gt;
    &lt;li&gt;waiting &amp;ndash; 开启 keep-alive 的情况下，这个值等于 active - (reading + writing)，意思就是 Nginx 已经处理完正在等候下一次请求指令的驻留连接。&lt;/li&gt;
&lt;/ul&gt;
参考：
&lt;a href=&#34;http://www.ibm.com/developerworks/cn/web/wa-lo-nginx/index.html&#34;&gt;http://www.ibm.com/developerworks/cn/web/wa-lo-nginx/index.html&lt;/a&gt;
&lt;a href=&#34;http://wiki.nginx.org/NginxChs&#34;&gt;http://wiki.nginx.org/NginxChs&lt;/a&gt;
&lt;a href=&#34;http://blog.chinaunix.net/u/12909/showart_1831422.html&#34;&gt;http://blog.chinaunix.net/u/12909/showart_1831422.html&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Gentoo下的ARP防御</title>
      <link>http://blog.prosight.me/blogs/243</link>
      <pubDate>2009-07-17 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;arp问题由来&lt;/h3&gt;

&lt;p&gt;arp是困扰很多人的问题， 利用arp协议的漏洞，别人可以很容易的在你的页面上挂上木马。简单的说，arp攻击就是利用arp自身的漏洞，欺骗你的机器访问虚假的网关，在那个虚假的网关上被植入木马代码的行为。 前两天Pett留言说他访问我的博客发现有病毒，虽然我没能重现他所反应的问题。 但是我想八九不离十应该是机房局域网中的arp攻击所致。&lt;/p&gt;

&lt;h3&gt;arp问题解决方案&lt;/h3&gt;

&lt;p&gt;解决arp问题目前比较常见的做法就是双向绑定你服务器的网卡和机房交换机的网卡。 跟机房联系过绑定网卡的事情，居然说要收费，NND基本的服务都要收费。 没办法，我先自己绑定机房交换机的网卡吧。 可以在一定程度避免收到arp的影响。
假设机房网关的ip是192.168.1.1
&lt;pre class=&#34;prettyprint linenums&#34;&gt;# arp
Address         HWtype  HWaddress           Flags Mask   Iface
192.168.1.1   ether   00:12:f2:09:17:20   C                 eth0&lt;/pre&gt;
可以看到，返回了机房网关的ip地址和mac地址。 C表示arp对这些信息进行了缓存。
如果发现可疑的设备可以使用arp -d来删除它。&lt;/p&gt;

&lt;h3&gt;绑定网关mac地址&lt;/h3&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;echo &amp;ldquo;192.168.1.1 00:12:f2:09:17:20&amp;rdquo;&amp;gt;/etc/macbind
arp -f /etc/macbind&lt;/pre&gt;
执行好上面的命令后，在使用arp命令查看的时候，你会发现如下信息：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;# arp
Address        HWtype  HWaddress           Flags Mask Iface
192.168.1.1  ether   00:12:f2:09:17:20   CM            eth0&lt;/pre&gt;
这回多了个M，表示已经静态化mac地址绑定了。
这样就完成了你的服务器到机房网关的单项mac绑定。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>jQuery控制iframe中对象的方法</title>
      <link>http://blog.prosight.me/blogs/240</link>
      <pubDate>2009-07-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;jQuery中的$()方法很容易获取到DOM中的元素。但是这个方法不适用于引用iframe中的元素。 如下面的html
a.htm
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;iframe id=&#34;frame&#34; src=&#34;http://www.prosight.me/b.htm&#34; frameborder=&#34;0&#34;&gt;&lt;/iframe&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;b.htm
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;div id=&#34;default&#34;&gt;this is b.htm&lt;/div&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如果要在a.htm中获得b.htm中的id为default的div，可以使用如下方法：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$(&amp;ldquo;#frame&amp;rdquo;).contents().find(&amp;ldquo;#default&amp;rdquo;)
&lt;/pre&gt;
来得到这个div的jQuery对象。&lt;/p&gt;

&lt;p&gt;特别需要注意一点，就是iframe中的src一定要使用绝对路径，否则jQuery是无法正确找到对应的元素的。 尤其在公网上。之前就因为这个问题，折腾了一晚没解决，换成绝对地址就好了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>lighttpd配置之流量监控(mod_rrdtool)</title>
      <link>http://blog.prosight.me/blogs/224</link>
      <pubDate>2009-07-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;lighttpd中带了一个监控模块，可以监控lighttpd服务器的流量。
1. 确保安装lighttpd的时候，带了rrdtool模块，如果没有，将rrdtool加到lighttpd的USE中，重新编译
2. 在/etc/lighttpd/lighttpd.conf中，激活mod_rrdtool模块,并添加以下代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
 rrdtool.binary  = &amp;ldquo;/usr/bin/rrdtool&amp;rdquo;
 rrdtool.db-name = var.statedir + &amp;ldquo;/lighttpd.rrd&amp;rdquo;
&lt;/pre&gt;
 rrdtool.binary是rrdtool的安装目录
 rrdtool.db-name是rrdtool需要用到的数据库，在第一次启动前，确保没有那个rrd文件。
3. 重启lighttpd，这样lighttpd的流量数据就可以实时的记录到rrd文件中了。
4. 图形化报表
    4a. 定义脚本
    &lt;pre class=&#34;prettyprint linenums&#34;&gt;
    #!/bin/sh&lt;/p&gt;

&lt;p&gt;RRDTOOL=/usr/bin/rrdtool
OUTDIR=/data/www/yourdomain.com/rrd/ #你的图片输出目录
INFILE=/var/lib/lighttpd/lighttpd.rrd    ＃你的rrd数据库文件位置
OUTPRE=lighttpd-traffic                        #图片文件的前缀
WIDTH=600
HEIGHT=350&lt;/p&gt;

&lt;p&gt;DISP=&amp;ldquo;-v bytes &amp;ndash;title TrafficWebserver
        DEF:binraw=$INFILE:InOctets:AVERAGE
        DEF:binmaxraw=$INFILE:InOctets:MAX
        DEF:binminraw=$INFILE:InOctets:MIN
        DEF:bout=$INFILE:OutOctets:AVERAGE
        DEF:boutmax=$INFILE:OutOctets:MAX
        DEF:boutmin=$INFILE:OutOctets:MIN
        CDEF:bin=binraw,-1,*
        CDEF:binmax=binmaxraw,-1,*
        CDEF:binmin=binminraw,-1,*
        CDEF:binminmax=binmaxraw,binminraw,-
        CDEF:boutminmax=boutmax,boutmin,-
        AREA:binmin#ffffff:
        STACK:binmax#f00000:
        LINE1:binmin#a0a0a0:
        LINE1:binmax#a0a0a0:
        LINE2:bin#efb71d:incoming
        GPRINT:bin:MIN:%.2lf
        GPRINT:bin:AVERAGE:%.2lf
        GPRINT:bin:MAX:%.2lf
        AREA:boutmin#ffffff:
        STACK:boutminmax#00f000:
        LINE1:boutmin#a0a0a0:
        LINE1:boutmax#a0a0a0:
        LINE2:bout#a0a735:outgoing
        GPRINT:bout:MIN:%.2lf
        GPRINT:bout:AVERAGE:%.2lf
        GPRINT:bout:MAX:%.2lf
        &amp;ldquo;
$RRDTOOL graph $OUTDIR/$OUTPRE-hour.png -a PNG &amp;ndash;start -14400 $DISP -w $WIDTH -h $HEIGHT
$RRDTOOL graph $OUTDIR/$OUTPRE-day.png -a PNG &amp;ndash;start -86400 $DISP -w $WIDTH -h $HEIGHT
$RRDTOOL graph $OUTDIR/$OUTPRE-month.png -a PNG &amp;ndash;start -2592000 $DISP -w $WIDTH -h $HEIGHT&lt;/p&gt;

&lt;p&gt;OUTPRE=lighttpd-requests&lt;/p&gt;

&lt;p&gt;DISP=&amp;ldquo;-v req &amp;ndash;title RequestsperSecond -u 1
        DEF:req=$INFILE:Requests:AVERAGE
        DEF:reqmax=$INFILE:Requests:MAX
        DEF:reqmin=$INFILE:Requests:MIN
        CDEF:reqminmax=reqmax,reqmin,-
        AREA:reqmin#ffffff:
        STACK:reqminmax#00f000:
        LINE1:reqmin#a0a0a0:
        LINE1:reqmax#a0a0a0:
        LINE2:req#00a735:requests&amp;rdquo;&lt;/p&gt;

&lt;p&gt;$RRDTOOL graph $OUTDIR/$OUTPRE-hour.png -a PNG &amp;ndash;start -14400 $DISP -w $WIDTH -h $HEIGHT
$RRDTOOL graph $OUTDIR/$OUTPRE-day.png -a PNG &amp;ndash;start -86400 $DISP -w $WIDTH -h $HEIGHT
$RRDTOOL graph $OUTDIR/$OUTPRE-month.png -a PNG &amp;ndash;start -2592000 $DISP -w $WIDTH -h $HEIGHT&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;/pre&amp;gt;
4b. 定义虚拟主机
修改/etc/lighttpd/lighttpd.conf
&amp;lt;pre class=&amp;quot;prettyprint linenums&amp;quot;&amp;gt;
$HTTP[&amp;quot;host&amp;quot;] == &amp;quot;www.yourdomain.com&amp;quot; {
    server.document-root =var.basedir +  &amp;quot;/yourdomain.com/rrd/&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
    &lt;/pre&gt;
    4c. 定义html文件 index.htm
    &lt;pre class=&#34;prettyprint linenums&#34;&gt;
    &amp;lt;!DOCTYPE html PUBLIC &amp;ldquo;-//W3C//DTD HTML 4.01 Transitional//EN&amp;rdquo;&amp;gt;
&lt;html&gt;
&lt;head&gt;
        &lt;title&gt;Lighttpd traffic &amp;amp; requests&lt;/title&gt;
        &lt;meta http-equiv=&#34;Content-Type&#34; content=&#34;text/html; charset=iso-8859-1&#34;&gt;
        &lt;meta http-equiv=&#34;content-style-type&#34; content=&#34;text/css&#34;&gt;
        &lt;style type=&#34;text/css&#34;&gt;
&amp;lt;!&amp;ndash;
        div { text-align:center; }
        img { width:693px; height:431px; }
&amp;ndash;&amp;gt;
        &lt;/style&gt;
&lt;/head&gt;&lt;/p&gt;

&lt;p&gt;&lt;body&gt;
    &lt;div&gt;
        ## Lighttpd Traffic
        &lt;img src=&#34;lighttpd-traffic-hour.png&#34;   alt=&#34;graph1&#34;&gt;&lt;br&gt;
        &lt;img src=&#34;lighttpd-traffic-day.png&#34;    alt=&#34;graph2&#34;&gt;&lt;br&gt;
        &lt;img src=&#34;lighttpd-traffic-month.png&#34;  alt=&#34;graph3&#34;&gt;&lt;br&gt;
    &lt;/div&gt;
    &lt;div&gt;
        ## Lighttpd Requests
        &lt;img src=&#34;lighttpd-requests-hour.png&#34;  alt=&#34;graph4&#34;&gt;&lt;br&gt;
        &lt;img src=&#34;lighttpd-requests-day.png&#34;   alt=&#34;graph5&#34;&gt;&lt;br&gt;
        &lt;img src=&#34;lighttpd-requests-month.png&#34; alt=&#34;graph6&#34;&gt;&lt;br&gt;
    &lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
    &lt;/pre&gt;
    4d. 访问www.yourdomain.com/index.htm就可以看到图片了
5. 加入到cron定时任务中
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;crontab -e&lt;/h1&gt;

&lt;p&gt;输入：
0,20,40 * * * * nice -n 10 /etc/lighttpd/rrdtool.sh &amp;gt;&amp;amp; /dev/null
&lt;/pre&gt;
这样每隔20分钟就会自动执行一下生成图片的脚本，来显示lighttpd的流量情况&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在wordpress上配置memcached</title>
      <link>http://blog.prosight.me/blogs/235</link>
      <pubDate>2009-07-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Memcached 是一种高性能的分布式内存对象缓存系统。在动态应用，Memcached 既能提高访问的速度，同时还减低了数据库的负载。&lt;/p&gt;

&lt;p&gt;如果想在wordpress上使用memcache，需要按照如下步骤来做(以gentoo为例)
1. 安装memcached
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
emerge -av net-misc/memcached
&lt;/pre&gt;
2. 安装php的memcached扩展
因为dev-php5/pecl-memcache被gentoo mask了，所以需要先修改/etc/portage/package.keywords,添加：
&lt;pre lang=&#34;bash&gt;
dev-php5/pecl-memcache ~amd64
&lt;/pre&gt;
然后在安装dev-php5/pecl-memcache
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
emerge -av dev-php5/pecl-memcache
&lt;/pre&gt;
3. 下载wordpress的memcached插件
&lt;a href=&#34;http://dev.wp-plugins.org/browser/memcached/trunk&#34;&gt;http://dev.wp-plugins.org/browser/memcached/trunk&lt;/a&gt;
可以通过 SVN 工具去获取，SVN 地址为：
&lt;a href=&#34;http://svn.wp-plugins.org/memcached/trunk/&#34;&gt;http://svn.wp-plugins.org/memcached/trunk/&lt;/a&gt;
4. 启动memcached
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
memcached -d -m 512 -u root -l 127.0.0.1 -p 11211 -c 1024 -P /tmp/memcached.pid
&lt;/pre&gt;
-d选项是启动一个守护进程，
-m是分配给Memcache使用的内存数量，单位是MB，我这里是512MB，
-u是运行Memcache的用户，我这里是root，
-l是监听的服务器IP地址，如果有多个地址的话，我这里指定了服务器的IP地址127.0.0.1，
-p是设置Memcache监听的端口，我这里设置了11211，最好是1024以上的端口，
-c选项是最大运行的并发连接数，默认是1024，
-P是设置保存Memcache的pid文件，我这里是保存在 /tmp/memcached.pid&lt;/p&gt;

&lt;p&gt;如果要结束Memcache进程，执行：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;kill &lt;code&gt;cat /tmp/memcached.pid&lt;/code&gt;&lt;/h1&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如果想查看memcache的状态，可以使用如下命令
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
memcached-tool 10.0.0.5:11211 display    # shows slabs
memcached-tool 10.0.0.5:11211            # same.  (default is display)
memcached-tool 10.0.0.5:11211 stats      # shows general stats
memcached-tool 10.0.0.5:11211 dump       # dumps keys and values
memcached-tool 10.0.0.5:11211 move 7 9   # takes 1MB slab from class #7
                                                                             #  to class #9.
&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;上传object-cache.php到wp-content目录后，就可以完成设置了。 看看是不是你的wordpress快了很多&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>lighttpd配置之用户验证(mod_auth)</title>
      <link>http://blog.prosight.me/blogs/229</link>
      <pubDate>2009-07-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候需要对某些web资源做权限验证。 在lighttpd中可以这样做。
1. 激活mod_auth模块，在/etc/lighttpd/lighttpd.conf中去掉mod_auth模块前面的＃
2. 下载apache相关模块
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;emerge -av app-admin/apache-tools&lt;/h1&gt;

&lt;p&gt;&lt;/pre&gt;
3. 生成密码文件
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/p&gt;

&lt;h1&gt;cd /var/lib/lighttpd/&lt;/h1&gt;

&lt;h1&gt;htdigest -c lighttpd.user.htdigest &amp;lsquo;some text&amp;rsquo; username&lt;/h1&gt;

&lt;p&gt;&lt;/pre&gt;
其中some text是在密码提示框的标题中要显示的内容，lighttpd.user.htdigest是密码文件的文件名
执行过htdigest后，输入两边这个用户的密码后，就可以生成lighttpd.user.htdigest这个密码文件了
4. 配置lighttpd.conf文件
添加
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
auth.debug                 = 0
auth.backend               = &amp;ldquo;htdigest&amp;rdquo;
auth.backend.htdigest.userfile = var.statedir + &amp;ldquo;/lighttpd.user.htdigest&amp;rdquo;
&lt;/pre&gt;
auth.debug 是调试级别，0表示不调试，1表示记录&amp;rsquo;auth-ok&amp;rsquo;验证成功的信息， 2表示所有详细的调试信息
在需要验证的虚机上添加以下内容
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
auth.require = ( &amp;ldquo;&amp;rdquo; =&amp;gt;
                         (
                                &amp;ldquo;method&amp;rdquo;  =&amp;gt; &amp;ldquo;digest&amp;rdquo;,
                                &amp;ldquo;realm&amp;rdquo;   =&amp;gt; &amp;ldquo;some text&amp;rdquo;,
                                &amp;ldquo;require&amp;rdquo; =&amp;gt; &amp;ldquo;user=username&amp;rdquo;
                         )
                        )
&lt;/pre&gt;
auth.require后的空引号表示虚机中所有路径都需要验证，如果只是部分需要验证，那么就指定具体路径
5. 重启lighttpd，使配置生效&lt;/p&gt;
</description>
    </item>
    <item>
      <title>lighttpd配置之代理、负载均衡(mod_proxy)</title>
      <link>http://blog.prosight.me/blogs/221</link>
      <pubDate>2009-07-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用proxy可以使lighttpd成为一个代理服务器。例如将java的请求全都转向给jboss来处理
mod_proxy有三个标签：
proxy.debug，0或者1. 表示是否启动调试模式。 1表示启动
proxy.balance，使用负载均衡的模式。可以使“hash”，“round-robin&amp;rdquo;,&amp;ldquo;fair&amp;rdquo;三种模式之一。
&amp;lsquo;round-robin&amp;rsquo; 交替轮训, &amp;lsquo;hash&amp;rsquo; 根据请求的url产生一个 hash值，来确保同样的请求的url都访问同样的主机
&amp;lsquo;fair&amp;rsquo; is the normal load-based, passive balancing.&lt;/p&gt;

&lt;p&gt;语法结构
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
 ( &lt;extension&gt; =&amp;gt;
      ( &lt;a href=&#34;&amp;quot;host&amp;quot; =&amp;gt; &amp;lt;string&amp;gt; ,
          &amp;quot;port&amp;quot; =&amp;gt; &amp;lt;integer&#34;&gt; &lt;name&gt; =&amp;gt; &lt;/a&gt;,
        ( &amp;ldquo;host&amp;rdquo; =&amp;gt; &lt;string&gt; ,
          &amp;ldquo;port&amp;rdquo; =&amp;gt; &lt;integer&gt; )
      ),
      &lt;extension&gt; =&amp;gt; &amp;hellip;
    )
&lt;/pre&gt;
    *  &lt;extension&gt;: 表示请求url的文件扩展名或者文件前缀 (如果以&amp;rdquo;/&amp;ldquo;开始); 可以是空 (&amp;rdquo;&amp;ldquo;) 表示所有的请求
    * &lt;name&gt;: 可选名称
    * &amp;ldquo;host&amp;rdquo;: 被代理的服务器的ip
    * &amp;ldquo;port&amp;rdquo;: 被代理服务器的端口，默认是80&lt;/p&gt;

&lt;p&gt;如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
proxy.server = ( &amp;ldquo;.jsp&amp;rdquo; =&amp;gt;
                       ( (
                           &amp;ldquo;host&amp;rdquo; =&amp;gt; &amp;ldquo;10.0.0.242&amp;rdquo;,
                           &amp;ldquo;port&amp;rdquo; =&amp;gt; 8080
                         ) )
                     )
&lt;/pre&gt;
再如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$HTTP[&amp;ldquo;host&amp;rdquo;] == &amp;ldquo;www.domain.me&amp;rdquo; {
        proxy.server  = ( &amp;ldquo;&amp;rdquo; =&amp;gt;
        ( (
                &amp;ldquo;host&amp;rdquo; =&amp;gt; &amp;ldquo;127.0.0.1&amp;rdquo;,
                &amp;ldquo;port&amp;rdquo;=&amp;gt;&amp;ldquo;8080&amp;rdquo;&lt;br /&gt;
        ) )
        )
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;负载均衡的例子，例如有8个squid缓存，需要用lighttpd做负载均衡
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
  $HTTP[&amp;ldquo;host&amp;rdquo;] == &amp;ldquo;www.example.org&amp;rdquo; {
    proxy.balance = &amp;ldquo;hash&amp;rdquo;
    proxy.server  = ( &amp;ldquo;&amp;rdquo; =&amp;gt; ( ( &amp;ldquo;host&amp;rdquo; =&amp;gt; &amp;ldquo;10.0.0.10&amp;rdquo; ),
                              ( &amp;ldquo;host&amp;rdquo; =&amp;gt; &amp;ldquo;10.0.0.11&amp;rdquo; ),
                              ( &amp;ldquo;host&amp;rdquo; =&amp;gt; &amp;ldquo;10.0.0.12&amp;rdquo; ),
                              ( &amp;ldquo;host&amp;rdquo; =&amp;gt; &amp;ldquo;10.0.0.13&amp;rdquo; ),
                              ( &amp;ldquo;host&amp;rdquo; =&amp;gt; &amp;ldquo;10.0.0.14&amp;rdquo; ),
                              ( &amp;ldquo;host&amp;rdquo; =&amp;gt; &amp;ldquo;10.0.0.15&amp;rdquo; ),
                              ( &amp;ldquo;host&amp;rdquo; =&amp;gt; &amp;ldquo;10.0.0.16&amp;rdquo; ),
                              ( &amp;ldquo;host&amp;rdquo; =&amp;gt; &amp;ldquo;10.0.0.17&amp;rdquo; ) ) )
  }
&lt;/pre&gt;
当一个服务器宕机后，它上面的请求将被转移给其他设备server&lt;/p&gt;
</description>
    </item>
    <item>
      <title>lighttpd配置之缓存静态文件(mod_expire)</title>
      <link>http://blog.prosight.me/blogs/214</link>
      <pubDate>2009-07-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;网站中经常有jpg，png，css等静态文件，而且一般也不太变化。可以通过lighttpd的mod_expire模块，让客户端缓存这些静态文件，不必每次都向服务器请求最新的数据。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$HTTP[&#34;url&#34;] =~ &#34;(.png|.css|.js|.jpg|.gif)$&#34; {
         expire.url = ( &#34;&#34; =&gt; &#34;access 2 months&#34; )
}
&lt;/pre&gt;

&lt;p&gt;在/etc/lighttpd/lighttpd.conf中，激活mod_expire模块，并添加上述代码。 这样png,css,js,jpg,gif等静态文件就会在客户端缓存2个月。可以有效的提高二次访问者的访问速度，降低服务器的流量压力&lt;/p&gt;
</description>
    </item>
    <item>
      <title>lighttpd配置之重定向(mod_redirect)</title>
      <link>http://blog.prosight.me/blogs/218</link>
      <pubDate>2009-07-12 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有时候需要将一个url重定向到另外一个url上。 如最简单的将不带www的域名重定向到www上，例如将domain.com重定向到www.domain.com上。&lt;/p&gt;

&lt;p&gt;这时候就可以使用mod_redirect模块。 如上面的例子可以在/etc/lighttpd/lighttpd.conf中使用下面的代码来解决：
1. 激活配置文件中的mod_redirect模块，去掉其前面的＃
2. 插入下面代码
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$HTTP[&amp;ldquo;host&amp;rdquo;] =~ &amp;ldquo;^([^.]+.[^.]+)$&amp;rdquo; {
  url.redirect = (
      &amp;ldquo;.*&amp;rdquo; =&amp;gt; &amp;ldquo;http://www.%1&amp;rdquo;
  )
}
&lt;/pre&gt;
其中，％1表示$HTTP[&amp;ldquo;host&amp;rdquo;] 中正则表达式中括号中匹配的内容。％1表示第一个匹配值，％2表示第二个匹配值。％0表示整个字符串&lt;/p&gt;

&lt;p&gt;再如，希望把www.prosight.me/blog/index.php/&lt;sup&gt;2009&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/archives/321这样的url跳转到blog.prosight.me/index.php/&lt;sup&gt;2009&lt;/sup&gt;&amp;frasl;&lt;sub&gt;03&lt;/sub&gt;/321这个url上的话，就使用如下配置：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$HTTP[&amp;ldquo;host&amp;rdquo;] == &amp;ldquo;www.prosight.me&amp;rdquo; {
  url.redirect = (
       &amp;ldquo;^/blog/index.php/([0-9]+/[0-9]+)/archives/([0-9]+)$&amp;rdquo;
       =&amp;gt; &amp;ldquo;http://blog.prosight.me/index.php/$1/$2&amp;rdquo;,
       &amp;ldquo;^/blog(/)?$&amp;rdquo; =&amp;gt; &amp;ldquo;http://blog.prosight.me&amp;rdquo;
  )
}
&lt;/pre&gt;
其中  $1表示在url.redirect里正则表达式中第一个括号匹配的内容，$2表示第二个匹配的内容，以此类推。&lt;/p&gt;

&lt;p&gt;url.redirect可以放置在任何$HTTP[&amp;ldquo;host&amp;rdquo;] 块中，与其他模块共同使用。例如与rewrite一同使用，或者跟server.document-root属性一起使用来共同配置一个虚拟主机。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>lighttpd配置之压缩文件(mod_compress)</title>
      <link>http://blog.prosight.me/blogs/212</link>
      <pubDate>2009-07-11 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在页面中使用gzip可以有效的减低页面的大小，加快网页的下载速度。在lighttpd中对php页面进行压缩，需要两个步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;编辑 lighttpd.conf&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;将 “mod_compress” 设为启用&lt;/p&gt;

&lt;p&gt;接著找到&lt;/p&gt;

&lt;h2&gt;compress module&lt;/h2&gt;

&lt;p&gt;在下面加入
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
compress.cache-dir         = “/var/tmp/lighttpd/cache/”
compress.filetype          = (”text/plain”, “text/html”, “text/css”, “text/javascript”)
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;做完上面的动作后，
基本上 .txt .html .css .js 的文件都会被Gzip压缩了。但php此时还没有压缩&lt;/p&gt;

&lt;p&gt;对于动态的php文件，还需要在php.ini中做相关设置，否则.php页面还是不使用压缩模式
2. 编辑 php.ini
修改
zlib.output_compression = On
zlib.output_handler = On&lt;/p&gt;

&lt;p&gt;重新启动Lighttpd。
这样php也压缩了&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Gentoo 网络配置</title>
      <link>http://blog.prosight.me/blogs/211</link>
      <pubDate>2009-07-09 12:00:00 +0800</pubDate>
      <description>&lt;h3&gt;1. 配置ip&lt;/h3&gt;

&lt;p&gt;/etc/conf.d/net
DHCP 动态获取
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
config_eth0=( &amp;ldquo;dhcp&amp;rdquo; )
&lt;/pre&gt;
固定IP
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
 config_eth0=( &amp;ldquo;192.168.0.2 netmask 255.255.255.0 brd 192.168.0.255&amp;rdquo; )
或者
 config_eth0=( &amp;ldquo;192.168.0.&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;24&lt;/sub&gt; brd 192.168.0.255&amp;rdquo; )
 routes_eth0=( &amp;ldquo;default via 192.168.0.1&amp;rdquo; )
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;2. DNS设置&lt;/h3&gt;

&lt;p&gt;/etc/resolv.conf
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
nameserver 202.96.209.5 202.96.209.133
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;3. 重启网卡&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/etc/init.d/net.eth0 start | stop | restart
&lt;/pre&gt;

&lt;h3&gt;4. 配置防火墙 iptables&lt;/h3&gt;

&lt;h1&gt;stop iptables services&lt;/h1&gt;

&lt;p&gt;/etc/init.d/iptables stop&lt;/p&gt;

&lt;h1&gt;disable all chains&lt;/h1&gt;

&lt;p&gt;iptables -F
iptables -t nat -F
iptables -t mangle -F&lt;/p&gt;

&lt;h1&gt;allow ssh&lt;/h1&gt;

&lt;p&gt;iptables -A INPUT -i eth0 -p tcp &amp;ndash;dport 22 -j ACCEPT
iptables -A INPUT -i eth0 -p tcp &amp;ndash;dport 80 -j ACCEPT&lt;/p&gt;

&lt;h1&gt;allow old connection and deny new connection&lt;/h1&gt;

&lt;p&gt;iptables -A INPUT -m state &amp;ndash;state ESTABLISHED,RELATED -j ACCEPT
iptables -A INPUT -i eth0 -m state &amp;ndash;state NEW,INVALID -j DROP&lt;/p&gt;

&lt;h1&gt;allow all localhost&lt;/h1&gt;

&lt;p&gt;iptables -A INPUT -i lo -j ACCEPT&lt;/p&gt;

&lt;h1&gt;define default policy&lt;/h1&gt;

&lt;p&gt;iptables -P FORWARD DROP
iptables -P INPUT DROP
iptables -P OUTPUT ACCEPT&lt;/p&gt;

&lt;h1&gt;save&lt;/h1&gt;

&lt;p&gt;/etc/init.d/iptables save
/etc/init.d/iptables restart&lt;/p&gt;

&lt;p&gt;#加入自动启动任务，使iptables自动启动
rc-update add iptables default&lt;/p&gt;

&lt;p&gt;如何删除一条规则？比如删除80端口，让外面无法访问。
iptables -D INPUT -i eth0 -p tcp &amp;ndash;dport 80 -j ACCEPT&lt;/p&gt;

&lt;p&gt;如何再添加？
iptables -I INPUT -i eth0 -p tcp &amp;ndash;dport 80 -j ACCEPT&lt;/p&gt;

&lt;p&gt;最后别忘记用
/etc/init.d/iptables save
/etc/init.d/iptables restart
这两个命令保存并重启&lt;/p&gt;
</description>
    </item>
    <item>
      <title>针对Intel Core i7优化安装Gentoo</title>
      <link>http://blog.prosight.me/blogs/198</link>
      <pubDate>2009-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;要让Core i7处理器在gentoo里工作得正常需要从3个方面来设置。下面我一一来说明。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CFlag&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Core i7的信息
vendor_id       : GenuineIntel
cpu family      : 6
model           : 26
model name      : Intel&amp;reg; Core&amp;trade; i7 CPU         920  @ 2.67GHz
/etc/make.conf内容
&lt;pre class=&#34;prettyprint linenums&#34;&gt;CHOST=&amp;ldquo;x86_64-pc-linux-gnu&amp;rdquo;
CFLAGS=&amp;ldquo;-march=core2 -msse4 -mcx16 -msahf -O2 -pipe&amp;rdquo;
CXXFLAGS=&amp;ldquo;${CFLAGS}&amp;rdquo;&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;2, Kernel Setup
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Processor type and features  &amp;mdash;&amp;gt;
    Subarchitecture Type ()  &amp;mdash;&amp;gt;
        (X) PC-compatible
    Processor family ()  &amp;mdash;&amp;gt;
        (X) Pentium M
    [ ] Generic x86 support
    [&lt;em&gt;] Supported processor vendors &amp;mdash;-&amp;gt;
        [&lt;/em&gt;]   Support Intel processors
&lt;/pre&gt;
填写你的CPU核数
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Processor type and features  &amp;mdash;&amp;gt;
    [&lt;em&gt;] Symmetric multi-processing support
    (8) Maximum number of CPUs (2-256)
    [ ] SMT (Hyperthreading) scheduler support
    [&lt;/em&gt;] Multi-core scheduler support
&lt;/pre&gt;
支持64位CPU
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Processor type and features  &amp;mdash;&amp;gt;
    &amp;ndash; Machine check support
    [&lt;em&gt;] Intel MCE features
Executable file formats / Emulations  &amp;mdash;&amp;gt;
    [&lt;/em&gt;] IA32 Emulation
&lt;/pre&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Hardware Sensors
增加硬件监控
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Device Drivers  &amp;mdash;&amp;gt;
Hardware Monitoring support  &amp;mdash;&amp;gt;
    &lt;m&gt; Hardware Monitoring support
    &lt;m&gt; Intel Core (2) Duo/Solo temperature sensor
&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>Gentoo emerge 使用方法</title>
      <link>http://blog.prosight.me/blogs/189</link>
      <pubDate>2009-07-08 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;使用emerge可以管理Portage中的软件甚至整个系统。&lt;/p&gt;

&lt;p&gt;当我们谈到（软件）包的时候，我们通常指的是Portage树为Gentoo用户提供的包的名称。Portage树是ebuilds文件的集合，这些文件包含了Portage管理工具维护软件（安装，搜索，查询， &amp;hellip;）时所需要的所有信息，并被默认的放置在/usr/portage目录中。&lt;/p&gt;

&lt;p&gt;每当您要求Portage对系统中的软件包执行一些操作的时候，它会以系统中的ebuilds文件作为基础。因此您最好定期更新系统Portage树中的ebuild文件，这样Portage才知道新加入了哪些软件，哪些软件发布了安全更新，等等。&lt;/p&gt;

&lt;h3&gt;更新Portage树&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;# emerge --sync&lt;/pre&gt;
### 更新系统
&lt;pre class=&#34;prettyprint linenums&#34;&gt;# emerge --update --deep --newuse world&lt;/pre&gt;
--update(-u)表示更新
--deep(-D)表示更新关联包
Portage会查找您已经安装的软件包是否有更新版本，但它只会核对那些您已经明确地安装过的软件包(也就是在/var/lib/portage/world文件中列出的包），并不会完整去的检查与这些软件产生依赖关系的包是否也需要更新。如果您想更新系统中的每个软件包，那就加上--deep参数
--newuse 如果USE变量的值变了，就要使用这个参数，通知系统USE参数有变化

### 移除依赖包
如果仅仅移除了一个包，而未将其依赖的包移除，使用emerge --depclean命令来移除依赖包。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
# emerge --update --deep --newuse world
# emerge --depclean
# revdep-rebuild
&lt;/pre&gt;
在使用emerge --depclean前，确保系统完全更新过。
revdep-rebuild工具由gentoolkit包提供；使用前别忘了首先emerge它：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
# emerge gentoolkit
&lt;/pre&gt;

&lt;h3&gt;升级系统完整步骤&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
   1. emerge --sync
   2. emerge -vauD --newuse world
   3. emerge –depclean
   4. revdep-rebuild
&lt;/pre&gt;

&lt;h3&gt;通过名称查找软件&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
# emerge --search softname
&lt;/pre&gt;

&lt;h3&gt;通过软件描述查找软件&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
# emerge --searchdesc pdf
&lt;/pre&gt;

&lt;h3&gt;安装软件&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
# emerge gnumeric
&lt;/pre&gt;

&lt;h3&gt;假装安装软件&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
# emerge --pretend gnumeric
或
# emerge -p gnumeric
&lt;/pre&gt;

&lt;h3&gt;移除软件&lt;/h3&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
# emerge --unmerge gnumeric
&lt;/pre&gt;

&lt;h3&gt;全面world更新的时候，不想更新某些包&lt;/h3&gt;

&lt;p&gt;将你不想更新的包的名字加入到/etc/portage/package.mask中。
如你不想升级最新的nginx则加入
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
www-servers/nginx
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;设置某些包的USE属性&lt;/h3&gt;

&lt;p&gt;如果你想针对某些包设置他们的USE属性，而不是改变全局USE属性，则修改/etc/portage/package.use文件，如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&amp;gt;=www-servers/nginx-0.7.6 random-index addition fastcgi flv imap pcre perl ssl status sub webdav zlib
&amp;gt;=dev-lang/ruby-1.8.7
dev-db/mysql innodb berkdb
dev-lang/php fpm berkdb bzip2 cli crypt gdbm iconv ipv6 ncurses nls pcre readline reflection session spl ssl unicode zlib curl exif gd json mysql pdo threads xml zip
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;使用最新的测试包&lt;/h3&gt;

&lt;p&gt;默认gentoo都是用稳定版的包，如果你想使用最新版本的软件，只要在/etc/portage/package.keywords文件中，对应的包后加入～就可以了。如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
www-servers/lighttpd ~amd64
www-servers/nginx ~amd64
dev-lang/php ~amd64
dev-db/mysql ~amd64
sys-devel/gcc ~amd64
dev-lang/ruby ~amd64
&lt;/pre&gt;
~amd64表明你更新的是64位版本的，如果是x86版本的，使用~x86就可以了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone Table View 教程(2) 创建一个简单表格</title>
      <link>http://blog.prosight.me/blogs/174</link>
      <pubDate>2009-07-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;上一节我们介绍了iPhone的table view，这节我们先做一个简单的表格例子。&lt;/p&gt;

&lt;p&gt;在Xcode中新建一个view based项目，命名为SimpleTable。&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_176&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;487&amp;rdquo; caption=&amp;ldquo;新建xcode项目&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/13.png&#34;&gt;&lt;img class=&#34;size-full wp-image-176 &#34; title=&#34;新建xcode项目&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/13.png&#34; alt=&#34;新建xcode项目&#34; width=&#34;487&#34; height=&#34;362&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;在SimpleTableViewController.h输入以下代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;#import&lt;/p&gt;

&lt;p&gt;@interface SimpleTableViewController : UIViewController  {
    IBOutlet UITableView *tblSimpleTable;
    NSArray *arryData;
}
@end&lt;/pre&gt;
定义一个table view IBOutlet变量和一个数组。&lt;/p&gt;

&lt;p&gt;打开SimpleTableViewController.xib文件，进入interface builder。
从Library拖入一个table view控件到主窗口中。&lt;/p&gt;

&lt;p&gt;选择File’s Owner&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_178&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;560&amp;rdquo; caption=&amp;ldquo;File‘s Owner&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/21.png&#34;&gt;&lt;img class=&#34;size-full wp-image-178 &#34; title=&#34;File‘s Owner&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/21.png&#34; alt=&#34;File‘s Owner&#34; width=&#34;560&#34; height=&#34;606&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;按cmd + 2 打开 ‘Connections Inspector’&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_181&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;440&amp;rdquo; caption=&amp;ldquo;关联表格&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/32.png&#34;&gt;&lt;img class=&#34;size-full wp-image-181  &#34; title=&#34;关联表格&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/32.png&#34; alt=&#34;关联表格&#34; width=&#34;440&#34; height=&#34;447&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;点击tblSimpleTable边上的小圆圈，拖拽到主屏幕上的table view上，将IBOutlet变量跟Interface Builder中的表格table view关联起来。&lt;/p&gt;

&lt;p&gt;在选择主屏幕中的table view，拖拽dataSource和delegate两个变量拖拽到File’s Owner上，指定File‘s Owner所对应的对象（即SimpleTableViewController）为tableview的datasource和delegate。&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_182&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;452&amp;rdquo; caption=&amp;ldquo;设置data source和delegate&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/41.png&#34;&gt;&lt;img class=&#34;size-full wp-image-182   &#34; title=&#34;设置data source和delegate&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/41.png&#34; alt=&#34;设置data source和delegate&#34; width=&#34;452&#34; height=&#34;339&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;打开SimpleTableViewController.m，编辑其中内容为：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;#import &amp;ldquo;SimpleTableViewController.h&amp;rdquo;&lt;/p&gt;

&lt;p&gt;@implementation SimpleTableViewController&lt;/p&gt;

&lt;p&gt;// Implement viewDidLoad to do additional setup after loading the view, typically from a nib.
- (void)viewDidLoad {
    arryData = [[NSArray alloc] initWithObjects:@&amp;ldquo;iPhone&amp;rdquo;,@&amp;ldquo;Android&amp;rdquo;,@&amp;ldquo;Plam Pre&amp;rdquo;,@&amp;ldquo;Windows Mobile&amp;rdquo;,nil];
    [super viewDidLoad];
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;(void)didReceiveMemoryWarning {
// Releases the view if it doesn&amp;rsquo;t have a superview.
[super didReceiveMemoryWarning];&lt;/p&gt;

&lt;p&gt;// Release any cached data, images, etc that aren&amp;rsquo;t in use.
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(void)viewDidUnload {
// Release any retained subviews of the main view.
// e.g. self.myOutlet = nil;
}&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;(void)dealloc {
[arryData release];
[super dealloc];
}&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;#pragma mark Table view methods&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView {
return 1;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// Customize the number of rows in the table view.
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {
    return [arryData count];
}&lt;/p&gt;

&lt;p&gt;// Customize the appearance of table view cells.
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;static NSString *CellIdentifier = @&amp;quot;Cell&amp;quot;;

UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
if (cell == nil) {
    cell = [[[UITableViewCell alloc] initWithFrame:CGRectZero reuseIdentifier:CellIdentifier] autorelease];
}

// Set up the cell...
cell.textLabel.text = [arryData objectAtIndex:indexPath.row];
return cell;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/p&gt;

&lt;p&gt;@end&lt;/pre&gt;
运行可以得到：&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_186&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;414&amp;rdquo; caption=&amp;ldquo;运行结果&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/6.png&#34;&gt;&lt;img class=&#34;size-full wp-image-186&#34; title=&#34;运行结果&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/6.png&#34; alt=&#34;运行结果&#34; width=&#34;414&#34; height=&#34;770&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone Table View 教程(1) 基础知识</title>
      <link>http://blog.prosight.me/blogs/163</link>
      <pubDate>2009-07-05 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Table View是iPhone最重要的用户UI之一，用来显示具有层级关系的数据结构。本教程将建立一个最基本的Table View，显示数组中的数据。&lt;/p&gt;

&lt;h3&gt;Table View的角色&lt;/h3&gt;

&lt;ul&gt;
    &lt;li&gt;让用户在层级化的数据中浏览&lt;/li&gt;
    &lt;li&gt;展示一个可选择列表选项&lt;/li&gt;
    &lt;li&gt;展示一个有序的项目列表&lt;/li&gt;
    &lt;li&gt;在不同的分组中显示详细信息和控件&lt;/li&gt;
&lt;/ul&gt;
Table view中的每一行称作一个cell，用来显示文字、图片或者其他内容。每个cell还可以有子视图。iPhone定义了三种默认的子视图

[caption id=&#34;attachment_165&#34; align=&#34;alignnone&#34; width=&#34;50&#34; caption=&#34;Disclosure indicator&#34;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/1.jpg&#34;&gt;&lt;img class=&#34;size-full wp-image-165 &#34; title=&#34;Disclosure indicator&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/1.jpg&#34; alt=&#34;Disclosure indicator&#34; width=&#34;50&#34; height=&#34;50&#34; /&gt;&lt;/a&gt;[/caption]

**展开指示器(Disclosure indicator)** -- UITableViewCellAccessoryDisclosureIndicator
&lt;p style=&#34;padding-left: 30px;&#34;&gt;用来以table view方式显示下一级数据&lt;/p&gt;


[caption id=&#34;attachment_166&#34; align=&#34;alignnone&#34; width=&#34;50&#34; caption=&#34;Detail disclosure button&#34;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/2.jpg&#34;&gt;&lt;img class=&#34;size-full wp-image-166 &#34; title=&#34;Detail disclosure button&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/2.jpg&#34; alt=&#34;Detail disclosure button&#34; width=&#34;50&#34; height=&#34;50&#34; /&gt;&lt;/a&gt;[/caption]

**详细信息指示器(Detail disclosure button)** --UITableViewCellAccessoryDetailDisclosureButton

用来显示一个详细信息视图（detail view）

[caption id=&#34;attachment_167&#34; align=&#34;alignnone&#34; width=&#34;50&#34; caption=&#34;Check mark&#34;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/3.jpg&#34;&gt;&lt;img class=&#34;size-full wp-image-167 &#34; title=&#34;Check mark&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/3.jpg&#34; alt=&#34;Check mark&#34; width=&#34;50&#34; height=&#34;50&#34; /&gt;&lt;/a&gt;[/caption]

**选择标记(Check mark)** -- UITableViewCellAccessoryCheckmark.

用来标记选择了哪一项。 可以是单选或者多选。
### Table View的样式
Table view有两种样式，一种是普通型，一种是分组类型。 分组类型中，每一个分组（section）都可以有自己的header和footer。
### Table View cell的样式
从iPhone SDK 3.0开始，可以定义每个cell的样式。UIKit定义了四种cell的样式。你也可以定义自己的样式，但是这四种预定义的样式可以满足绝大多数的需求。

**默认样式(UITableViewCellStyleDefault)**

[caption id=&#34;attachment_168&#34; align=&#34;alignnone&#34; width=&#34;321&#34; caption=&#34;Default table row style&#34;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/11.png&#34;&gt;&lt;img class=&#34;size-full wp-image-168&#34; title=&#34;Default table row style&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/11.png&#34; alt=&#34;Default table row style&#34; width=&#34;321&#34; height=&#34;482&#34; /&gt;&lt;/a&gt;[/caption]

显示主标题，可以允许有一个图片。

**子标题样式（UITableViewCellStyleSubtitle）**

[caption id=&#34;attachment_169&#34; align=&#34;alignnone&#34; width=&#34;322&#34; caption=&#34;UITableViewCellStyleSubtitle&#34;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/2.png&#34;&gt;&lt;img class=&#34;size-full wp-image-169&#34; title=&#34;UITableViewCellStyleSubtitle&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/2.png&#34; alt=&#34;UITableViewCellStyleSubtitle&#34; width=&#34;322&#34; height=&#34;478&#34; /&gt;&lt;/a&gt;[/caption]

一个主标题，一个灰色的副标题位于主标题下面，并可安放一个图片

**UITableViewCellStyleValue1样式**

** **

[caption id=&#34;attachment_170&#34; align=&#34;alignnone&#34; width=&#34;321&#34; caption=&#34;UITableViewCellStyleValue1&#34;]****&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/3.png&#34;&gt;&lt;img class=&#34;size-full wp-image-170&#34; title=&#34;UITableViewCellStyleValue1&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/3.png&#34; alt=&#34;UITableViewCellStyleValue1&#34; width=&#34;321&#34; height=&#34;479&#34; /&gt;&lt;/a&gt;****[/caption]

** **

主标题位于左侧，副标题以蓝色小字位于右侧，并右对齐。不允许有图片

**UITableViewCellStyleValue2样式**

** **

[caption id=&#34;attachment_171&#34; align=&#34;alignnone&#34; width=&#34;321&#34; caption=&#34;UITableViewCellStyleValue2&#34;]****&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/4.png&#34;&gt;&lt;img class=&#34;size-full wp-image-171&#34; title=&#34;UITableViewCellStyleValue2&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/4.png&#34; alt=&#34;UITableViewCellStyleValue2&#34; width=&#34;321&#34; height=&#34;480&#34; /&gt;&lt;/a&gt;****[/caption]

****主标题以蓝色显示位于左侧，并且是右对齐。超过宽度的文字以...省略，副标题以黑色字左对齐方式在主标题右侧显示。不能放置图片。iPhone的联系人程序中的列表就是使用这种布局。
### Table View
iPhone中的Table View都是UITableView的实例，用来定义表格的样式和行为，而UITableView是UIScrollView的子类。UIScrollView定义了超过屏幕大小的view的滚动行为，而UITableView则重新定义了滚动行为，使其只能垂直滚动。
### Data Source 和 Delegate
一个UITableView对象必须具有一个data source 和一个delegate。 根据MVC设计模式，data source负责连通应用程序的数据（即Model）和table view。 delegate则负责table view的外观和行为。 data source 和delegate往往是一个对象，而这个对象通常又是UITableViewController的子类。

data source 遵循 UITableViewDataSource 协议，delegate遵循 UITableViewDelegate 协议
&lt;ul&gt;
    &lt;li&gt;UITableViewDataSource 协议有一个可选方法，告诉table view有多少个section（默认是一个）
- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView。
还有一个必须方法，用来告诉table view每个section有多少行(row)
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
    &lt;li&gt;UITableViewDelegate 协议定义了一个必须方法，这个方法返回一个cell，使的table view在画某一行的时候显示。
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
    &lt;li&gt;UILocalizedIndexedCollation 是一个辅助类，是iPhone OS 3.0新引进的类，用来帮助data source组织数据，以便于在有序列表(indexed lists)中显示，当用户点击某一个项目的时候，可以正确显示对应的section。 UILocalizedIndexedCollation还可以本地化section的标题。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    <item>
      <title>访问youtube的方法</title>
      <link>http://blog.prosight.me/blogs/157</link>
      <pubDate>2009-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;youtube已经有段时间不能访问了，偶然间发现了一个可以访问这个网站的方法：&lt;/p&gt;

&lt;p&gt;只要添加两条记录到/etc/hosts文件中，就可以访问了，速度还可以&lt;/p&gt;

&lt;p&gt;203.208.39.104 www.youtube.com
203.208.33.100 gdata.youtube.com&lt;/p&gt;

&lt;p&gt;如果设好了，试试你是否可以播放下面的视频吧。
&lt;object width=&#34;480&#34; height=&#34;385&#34;&gt;&lt;param name=&#34;movie&#34; value=&#34;http://www.youtube.com/v/rS5o4v97Hqs&amp;hl=zh_CN&amp;fs=1&amp;rel=0&amp;color1=0x3a3a3a&amp;color2=0x999999&#34;&gt;&lt;/param&gt;&lt;param name=&#34;allowFullScreen&#34; value=&#34;true&#34;&gt;&lt;/param&gt;&lt;param name=&#34;allowscriptaccess&#34; value=&#34;always&#34;&gt;&lt;/param&gt;&lt;embed src=&#34;http://www.youtube.com/v/rS5o4v97Hqs&amp;hl=zh_CN&amp;fs=1&amp;rel=0&amp;color1=0x3a3a3a&amp;color2=0x999999&#34; type=&#34;application/x-shockwave-flash&#34; allowscriptaccess=&#34;always&#34; allowfullscreen=&#34;true&#34; width=&#34;480&#34; height=&#34;385&#34;&gt;&lt;/embed&gt;&lt;/object&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Google Android之Hello World</title>
      <link>http://blog.prosight.me/blogs/153</link>
      <pubDate>2009-07-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一直觉得Google是个伟大的公司，开发了无数有创意的web 2.0产品。其手机系统推出了很长时间了，一直也没有时间研究。 今天稍微看了一下它的文档，下载了SDK做了个示例。 感觉还是很简单的。 对于Java开发人员来说更是如此。&lt;/p&gt;

&lt;h3&gt;1. 先下载Android SDK&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;http://developer.android.com/sdk/1.5_r2/index.html&#34;&gt;http://developer.android.com/sdk/1.5_r2/index.html&lt;/a&gt;
根据你的操作系统，下载对应的sdk，目前支持Windows,mac和Linux三个系统
下载后解压那个zip文件，放在你想放置的位置就算安装完了。 如果你愿意，可以设置一下PATH变量。将sdk安装目录下的tools目录加入到PATH中。 这个目录中有开发Android所需要的常用命令。&lt;/p&gt;

&lt;h3&gt;2. 下载Eclipse的ADT插件&lt;/h3&gt;

&lt;p&gt;在Help &amp;gt; Software Updates&amp;hellip;.中，点击Available Software标签。 点击Add Site&amp;hellip;， 输入如下的地址：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;https://dl-ssl.google.com/android/eclipse/&lt;/pre&gt;
在随后的安装选项中，选择&amp;rdquo;Android DDMS&amp;rdquo; 和 &amp;ldquo;Android Development Tools&amp;rdquo; 下载好后，重启eclipse&lt;/p&gt;

&lt;p&gt;重启后，在Preferences中的Android标签中，指定之前你装好的sdk的位置，点击apply应用。这样开发环境就搭建完了，之后你就可以开始Android的开发之旅了。&lt;/p&gt;

&lt;h3&gt;3. 创建Android Virtual Device (AVD)&lt;/h3&gt;

&lt;p&gt;因为我们的开发都是在模拟器上进行的，所以需要先创建一个Android Virtual Device (AVD)，即Android的模拟器。用来调试程序
&lt;pre class=&#34;prettyprint linenums&#34;&gt;android create avd &amp;ndash;target 2 &amp;ndash;name my_avd&lt;/pre&gt;
&amp;ndash;target 指定你所需要创建的模拟器的Android系统的版本， 1表示创建1.1版本的，2表示创建最新的1.5版本的。
&amp;ndash;name 是指定这个虚拟器的名字&lt;/p&gt;

&lt;h3&gt;4. 创建Hello world程序&lt;/h3&gt;

&lt;p&gt;在你创建了AVD后，打开eclipse，选择File &amp;gt; New &amp;gt; Project，在向导页面中，选择Android Project
在随后的页面中，输入以下内容：
* Project name: HelloAndroid
* Application name: Hello, Android
* Package name: com.example.helloandroid (or your own private namespace)
* Create Activity: HelloAndroid
* Min SDK Version: 2
其中：
Project name 是eclipse中的项目名称
Application name 是将在你的Android手机系统中出现的你的应用的名字
Package name 是包名，跟java类似
Create Activity 是创建一个Activity的子类的名字。每个应用都有很多活动事件组成，但是每个窗口当前只有一个Activity
Min SDK Version 是SDK的版本， 2表示1.1版本，3表示1.5版本。 因为Android是向下兼容的， 所以1.1的应用可以运行在1.5的系统下。&lt;/p&gt;

&lt;p&gt;项目创建之后，打开HelloAndroid.java，将会看到下面的代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;package com.android.helloandroid;&lt;/p&gt;

&lt;p&gt;import android.app.Activity;
import android.os.Bundle;
import android.widget.TextView;&lt;/p&gt;

&lt;p&gt;public class HelloAndroid extends Activity {
   /** Called when the activity is first created. */
   @Override
   public void onCreate(Bundle savedInstanceState) {
       super.onCreate(savedInstanceState);
       TextView tv = new TextView(this);
       tv.setText(&amp;ldquo;Hello, Android&amp;rdquo;);
       setContentView(tv);
   }
}&lt;/pre&gt;
Android的用户界面是由很多&lt;a href=&#34;http://developer.android.com/reference/android/view/View.html&#34;&gt;View&lt;/a&gt;组成的，一个&lt;a href=&#34;http://developer.android.com/reference/android/view/View.html&#34;&gt;View&lt;/a&gt;可以是按钮，图片或者是一个文本框。这些界面元素都是View的一个子类，像&lt;a href=&#34;http://developer.android.com/reference/android/widget/TextView.html&#34;&gt;TextView&lt;/a&gt;类就是负责文本框的显示&lt;/p&gt;

&lt;p&gt;在TextView的构造函数中，需要传递一个&lt;a href=&#34;http://developer.android.com/reference/android/content/Context.html&#34;&gt;Context&lt;/a&gt;实例作为参数。 Context是一个句柄，它提供了解决资源，访问数据库以及参数选择等类似这样的服务。而Activity是Context的子类，所以我们可以传递一个this（即当前HelloAndroid这个Activity子类的示例）给TextView，当作它的构造函数的参数。&lt;/p&gt;

&lt;p&gt;setText(CharSequence)方法设置这个文本框的内容。&lt;/p&gt;

&lt;p&gt;setContentView() ，将TextView的实例传给它后，就可以在这个Activity的界面中显示它。&lt;/p&gt;

&lt;p&gt;如果一切顺利，你将看到&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_154&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;409&amp;rdquo; caption=&amp;ldquo;Hello Android&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/1.png&#34;&gt;&lt;img class=&#34;size-full wp-image-154&#34; title=&#34;Hello Android&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/07/1.png&#34; alt=&#34;Hello Android&#34; width=&#34;409&#34; height=&#34;728&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;恭喜你了，到目前为止，你应该已经成功的运行了第一个Android程序了&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Gentoo的编译参数</title>
      <link>http://blog.prosight.me/blogs/149</link>
      <pubDate>2009-07-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Gentoo一个最大的好处就在于其文档相当的全面，今天在maillist上看到有人提到这篇&lt;a href=&#34;http://www.gentoo.org/doc/en/gcc-optimization.xml&#34;&gt;Compilation Optimization Guide&lt;/a&gt;，读过之后对gentoo系统的认识又深入了一点，记几点心得。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;CFLAGS 是为编译C语言编写的代码所设置的环境变量， CXXFLAGS 是为编译C++代码所设置的环境变量。&lt;/li&gt;
&lt;li&gt;-march 参数告诉编译器为指定的cpu架构做优化，只有当没有合适的 -march 参数时，才会用到 -mcpu 和 -mtune，因为后二者都不是为指定的cpu优化的，更generic一些，其中 -mtune 比 -mcpu 更generic。&lt;/li&gt;
&lt;li&gt;-O2 是推荐的参数， -O3 并不适合 GCC4.x。 -Os 算是 -O2 的加强版，但是只用于硬盘或者cpu cache非常小的情况。 -O 参数的最高级别就是3,原文甚至给出了gcc的源码来证明，即使设成 -O9 也没有效果。&lt;/li&gt;
&lt;li&gt;-pipe 参数会加快编译速度。&lt;/li&gt;
&lt;li&gt;-fomit-frame-pointer 会减小编译出来的代码，但是有一定的风险，会是调试程序变得困难，特别是调试java程序。&lt;/li&gt;
&lt;li&gt;其余参数都可以忽略不计，只要设置好上面的参数，就是最安全的。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
CFLAGS=&amp;ldquo;-march=core2 -O2 -pipe -fomit-frame-pointer&amp;rdquo;
CHOST=&amp;ldquo;i686-pc-linux-gnu&amp;rdquo;
CXXFLAGS=&amp;ldquo;${CFLAGS}&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>安装支持ext4文件系统的Gentoo</title>
      <link>http://blog.prosight.me/blogs/151</link>
      <pubDate>2009-07-02 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;ext4出来了，但是gentoo官方文档并没有具体介绍如何安装带ext4支持的gentoo。 昨天试了一下，记录下来：&lt;/p&gt;

&lt;h3&gt;1. 事前准备&lt;/h3&gt;

&lt;p&gt;1a. 设置root密码&lt;/p&gt;

&lt;h1&gt;passwd&lt;/h1&gt;

&lt;p&gt;New password: （输入新密码）
Re-enter password: （再次输入密码）&lt;/p&gt;

&lt;p&gt;1b. 启动ssh
/etc/init.d/sshd start&lt;/p&gt;

&lt;p&gt;1c. 网络准备
如果启动的时候，发现没有eth0网卡，可能是没有获得到ip地址，而不是网卡没有找到。&lt;/p&gt;

&lt;p&gt;输入&lt;/p&gt;

&lt;h1&gt;dhcpcd eth0&lt;/h1&gt;

&lt;p&gt;重新获得ip地址就可以看到网卡找到了&lt;/p&gt;

&lt;h3&gt;2. 预备磁盘&lt;/h3&gt;

&lt;p&gt;2a. fdisk分区&lt;/p&gt;

&lt;h1&gt;fdisk /dev/sda&lt;/h1&gt;

&lt;p&gt;常用命令：p 显示当前分区， n 创建新分区&lt;/p&gt;

&lt;p&gt;创建boot分区
n创建分区
p选择主分区类型
从第一个柱面开始
＋32M 设定boot分区大小为32M
a 建立启动标记
1 选择第一个分区即boot分区为启动分区&lt;/p&gt;

&lt;p&gt;如果你再次按p键，你就会注意到，在“Boot”那一列有个*&lt;/p&gt;

&lt;p&gt;我们需要把这个分区设置成可启动的。键入a来给分区添加启动标志，然后键入1。如果你再次按p键，你就会注意到，在“Boot”那一列有个*&lt;/p&gt;

&lt;p&gt;创建交换分区
方式跟创建boot分区一样
t 更改分区类型为swap， 输入82&lt;/p&gt;

&lt;p&gt;保存分区布局
键入w来保存分区布局并退出fdisk。&lt;/p&gt;

&lt;p&gt;分区的例子
   Device Boot      Start         End      Blocks   Id  System
/dev/sda1   *           1           5       40131   83  Linux
/dev/sda2               6        6533    52436160   83  Linux
/dev/sda3            6534        8101    12594960   82  Linux swap / Solaris
/dev/sda4            8102       38913   247497390    5  Extended
/dev/sda5            8102       14629    52436128+  83  Linux
/dev/sda6           14630       38913   195061198+  83  Linux&lt;/p&gt;

&lt;p&gt;sda1 /boot 32M
sda2 / 50G
sda3 swap 12G
sda5 /usr 50G
sda6 /data 184G&lt;/p&gt;

&lt;p&gt;2b. 创建文件系统
格式化分区&lt;/p&gt;

&lt;p&gt;将sda1格式化为ext3，其余格式化为ext4&lt;/p&gt;

&lt;h1&gt;mke2fs -j /dev/sda1&lt;/h1&gt;

&lt;h1&gt;mkfs.ext4 /dev/sda2&lt;/h1&gt;

&lt;h1&gt;mkfs.ext4 /dev/sda5&lt;/h1&gt;

&lt;h1&gt;mkfs.ext4 /dev/sda6&lt;/h1&gt;

&lt;p&gt;激活交换分区
创建交换分区标志&lt;/p&gt;

&lt;h1&gt;mkswap /dev/sda3&lt;/h1&gt;

&lt;p&gt;激活交换分区&lt;/p&gt;

&lt;h1&gt;swapon /dev/sda3&lt;/h1&gt;

&lt;p&gt;2c.挂载&lt;/p&gt;

&lt;h1&gt;mount /dev/sda2 /mnt/gentoo&lt;/h1&gt;

&lt;h1&gt;mkdir /mnt/gentoo/boot&lt;/h1&gt;

&lt;h1&gt;mount /dev/sda1 /mnt/gentoo/boot&lt;/h1&gt;

&lt;p&gt;如果独立创建/usr分区（emerage 的下载的文件都保存在/usr/src下，所以建议独立分区），则执行&lt;/p&gt;

&lt;h1&gt;mkdir /mnt/gentoo/usr&lt;/h1&gt;

&lt;h1&gt;mount /dev/sda5 /mnt/gentoo/usr&lt;/h1&gt;

&lt;h3&gt;3.安装Gentoo安装文件&lt;/h3&gt;

&lt;p&gt;3a.安装一个Stage Tarball
解开stage&lt;/p&gt;

&lt;h1&gt;cd mnt/gentoo&lt;/h1&gt;

&lt;h1&gt;tar xvjpf stage3-*.tar.bz2&lt;/h1&gt;

&lt;p&gt;p表示保留权限&lt;/p&gt;

&lt;p&gt;3b. 安装Portage
从网上下载和安装Portage快照&lt;/p&gt;

&lt;h1&gt;cd /mnt/gentoo&lt;/h1&gt;

&lt;h1&gt;links &lt;a href=&#34;http://www.gentoo.org/main/en/mirrors.xml&#34;&gt;http://www.gentoo.org/main/en/mirrors.xml&lt;/a&gt;&lt;/h1&gt;

&lt;p&gt;选择一个离你最近的镜像，打开snapshots/目录。然后选择最新的Portage快照（portage-latest.tar.bz2）并按D来下载它。
现在按Q来退出浏览器。你现在已经有一个Portage快照保存在/mnt/gentoo里了。&lt;/p&gt;

&lt;p&gt;校验Portage快照的完整性&lt;/p&gt;

&lt;h1&gt;md5sum -c portage-latest.tar.bz2.md5sum&lt;/h1&gt;

&lt;p&gt;portage-latest.tar.bz2: OK&lt;/p&gt;

&lt;p&gt;解开Portage快照&lt;/p&gt;

&lt;h1&gt;tar xvjf /mnt/gentoo/portage-latest.tar.bz2 -C /mnt/gentoo/usr&lt;/h1&gt;

&lt;p&gt;3c.配置编译选项&lt;/p&gt;

&lt;h1&gt;nano -w /mnt/gentoo/etc/make.conf&lt;/h1&gt;

&lt;p&gt;CHOST 不需要更改
其他的根据你的机器的配置来，如：
CFLAGS=&amp;ldquo;-march=core2 -mfpmath=sse,387 -O2 -pipe -fomit-frame-pointer -mmmx -msse -msse2 -msse3&amp;rdquo;
CXXFLAGS=&amp;ldquo;${CFLAGS}&amp;rdquo;
LDFLAGS=&amp;ldquo;-Wl,-O2&amp;rdquo;&lt;/p&gt;

&lt;p&gt;－march和mtune具体参数的含义参见：http://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options&lt;/p&gt;

&lt;h3&gt;4. 安装Gentoo基本系统&lt;/h3&gt;

&lt;p&gt;4a.chroot
选择境像站点&lt;/p&gt;

&lt;h1&gt;mirrorselect -i -o &amp;gt;&amp;gt; /mnt/gentoo/etc/make.conf&lt;/h1&gt;

&lt;p&gt;拷贝DNS信息&lt;/p&gt;

&lt;h1&gt;cp -L /etc/resolv.conf /mnt/gentoo/etc/&lt;/h1&gt;

&lt;p&gt;挂载/proc和/dev文件系统&lt;/p&gt;

&lt;h1&gt;mount -t proc none /mnt/gentoo/proc&lt;/h1&gt;

&lt;h1&gt;mount -o bind /dev /mnt/gentoo/dev&lt;/h1&gt;

&lt;p&gt;进入新的系统环境&lt;/p&gt;

&lt;h1&gt;chroot /mnt/gentoo /bin/bash&lt;/h1&gt;

&lt;h1&gt;env-update&lt;/h1&gt;

&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Regenerating /etc/ld.so.cache&amp;hellip;&lt;/p&gt;

&lt;h1&gt;source /etc/profile&lt;/h1&gt;

&lt;h1&gt;export PS1=&amp;ldquo;(chroot) $PS1&amp;rdquo;&lt;/h1&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;p&gt;4b. 配置Portage
更新Portage树&lt;/p&gt;

&lt;h1&gt;emerge &amp;ndash;sync&lt;/h1&gt;

&lt;p&gt;配置USE变量
nano -w /etc/make.conf&lt;/p&gt;

&lt;p&gt;配置Locales
nano -w /etc/locale.gen
添加zh_CN.UTF-8 UTF-8&lt;/p&gt;

&lt;p&gt;运行
＃locale-gen
生成local.gen文件&lt;/p&gt;

&lt;h3&gt;5. 配置内核&lt;/h3&gt;

&lt;p&gt;5.a. 时区&lt;/p&gt;

&lt;p&gt;cp /usr/share/zoneinfo/PRC /etc/localtime
设置PRC为当前时区&lt;/p&gt;

&lt;p&gt;5.b. 安装源码
emerge gentoo-sources
gentoo-sources 为一般用途，只打了一般的安全补丁
hardened-sources 服务器用途， 安全性和稳定性有所提高&lt;/p&gt;

&lt;p&gt;5.c. 手动配置内核
安装工具
emerge pciutils
用lspci检查当前系统配置&lt;/p&gt;

&lt;p&gt;配置内核&lt;/p&gt;

&lt;h1&gt;cd /usr/src/linux&lt;/h1&gt;

&lt;h1&gt;make menuconfig&lt;/h1&gt;

&lt;p&gt;根据你的硬件和你的需要选择对应的选项，主要就是网卡和文件系统两方面
因为要支持ext4，特别注意file system中有关ext4的设置。把相关内容都选上&lt;/p&gt;

&lt;p&gt;编译内核
之后，使用make &amp;amp;&amp;amp; make modules_install来编译内核&lt;/p&gt;

&lt;p&gt;安装内核
编译后，执行下面命令来安装内核
cp arch/x86_64/boot/bzImage /boot/kernel-2.6.29-gentoo-r5
其中kernel-2.6.28-gentoo-r9根据你使用的内核和版本来定。 在/usr/src里面可以看到你之前下载的linux内核源码，可以查看到版本号&lt;/p&gt;

&lt;h3&gt;6. 配置系统&lt;/h3&gt;

&lt;p&gt;6.a. 文件系统信息
创建/etc/fstab
/etc/fstab使用一种特殊语法格式。每行都包含六个字段。这些字段之间由空白键（空格键，tab键，或者两者混合使用）分隔。每个字段都有自己的含意：
    •   第一个字段是对分区的描述，也就是设备文件的路径
    •   第二个字段是分区挂载点，也就是分区应该挂载到的地方
    •   第三个字段给出分区所用的文件系统
    •   第四个字段给出的是挂载分区时mount命令所用的挂载选项。由于每个文件系统都有自己的挂载选项，我们建议你阅读mount手册（man mount）以获得所有挂载选项的列表。多个挂载选项之间是用逗号分隔的。
    •   第五个字段是给dump使用的，用以决定这个分区是否需要dump。一般情况下，你可以把该字段设为0（零）。
    •   第六个字段是给fsck使用的，用以决定系统非正常关机之后文件系统的检查顺序。根文件系统应该为1，而其它的应该为2（如果不需要文件系统自检的话可以设为0）&lt;/p&gt;

&lt;p&gt;另外一个使用了ext4的例子
/dev/sda1       /boot       ext3        noauto,noatime  1 2
/dev/sda2       /           ext4        noatime         0 1
/dev/sda3       none        swap    sw              0 0
/dev/sda5       /usr            ext4        noatime         0 2
/dev/sda6       /data       ext4        noatime         0 2
/dev/cdrom      /mnt/cdrom  auto        noauto,ro       0 0&lt;/p&gt;

&lt;p&gt;auto选项可以使mount猜测文件系统（推荐对于可移动设备采用这个选项，因为它们可能采用很多不同的文件系统），而user选项使得非root用户可以挂载光驱。
为了提高性能，大部分用户会添加noatime挂载选项。由于不记录该分区中文件的访问时间（一般来说你并不需要知道它），这个选项能够提高系统速度。&lt;/p&gt;

&lt;p&gt;6.b. 网络信息
设定主机名&lt;/p&gt;

&lt;h1&gt;nano -w /etc/conf.d/hostname&lt;/h1&gt;

&lt;p&gt;配置你的网络&lt;/p&gt;

&lt;h1&gt;nano -w /etc/conf.d/net&lt;/h1&gt;

&lt;p&gt;为了输入你自己的IP地址，子网掩码和网关，你需要设置config_eth0和routes_eth0：&lt;/p&gt;

&lt;p&gt;手动为eth0设置IP信息
config_eth0=( &amp;ldquo;192.168.0.2 netmask 255.255.255.0 brd 192.168.0.255&amp;rdquo; )
routes_eth0=( &amp;ldquo;default via 192.168.0.1&amp;rdquo; )&lt;/p&gt;

&lt;p&gt;如果你使用DHCP，请定义一下config_eth0：
config_eth0=( &amp;ldquo;dhcp&amp;rdquo; )&lt;/p&gt;

&lt;p&gt;在启动时自动启用网络&lt;/p&gt;

&lt;h1&gt;rc-update add net.eth0 default&lt;/h1&gt;

&lt;p&gt;6.c. 系统信息
设置root密码&lt;/p&gt;

&lt;h1&gt;passwd&lt;/h1&gt;

&lt;p&gt;修改系统信息&lt;/p&gt;

&lt;h1&gt;nano -w /etc/rc.conf&lt;/h1&gt;

&lt;p&gt;比如把默认的编辑器改为vi&lt;/p&gt;

&lt;p&gt;设置键盘布局&lt;/p&gt;

&lt;h1&gt;nano -w /etc/conf.d/keymaps&lt;/h1&gt;

&lt;p&gt;设置时钟选项&lt;/p&gt;

&lt;h1&gt;nano -w /etc/conf.d/clock&lt;/h1&gt;

&lt;p&gt;如果你机器上的钟不用UTC，你需要在文件钟加上CLOCK=&amp;ldquo;local&amp;rdquo;。否则，你的时钟就有可能出现偏差。&lt;/p&gt;

&lt;h3&gt;7. 安装必要的系统工具&lt;/h3&gt;

&lt;p&gt;7.a. 系统日志工具&lt;/p&gt;

&lt;h1&gt;emerge syslog-ng&lt;/h1&gt;

&lt;h1&gt;emerge logrotate&lt;/h1&gt;

&lt;h1&gt;rc-update add syslog-ng default&lt;/h1&gt;

&lt;p&gt;7.b. Cron守护进程&lt;/p&gt;

&lt;h1&gt;emerge vixie-cron&lt;/h1&gt;

&lt;h1&gt;rc-update add vixie-cron default&lt;/h1&gt;

&lt;p&gt;7.c. 文件索引&lt;/p&gt;

&lt;h1&gt;emerge slocate&lt;/h1&gt;

&lt;p&gt;7.e. 网络工具
安装一个DHCP客户端&lt;/p&gt;

&lt;h1&gt;emerge dhcpcd&lt;/h1&gt;

&lt;h3&gt;8. 配置引导程序&lt;/h3&gt;

&lt;p&gt;8a. 使用GRUB
安装GRUB&lt;/p&gt;

&lt;h1&gt;emerge grub&lt;/h1&gt;

&lt;p&gt;尽管现在已经安装完GRUB，我们仍需要为其写一个配置文件，并将其安置到硬盘的主引导记录中，使它能自动引导您新创建的内核。您可以使用nano（或其他可用的编辑器）来创建配置文件/boot/grub/grub.conf：&lt;/p&gt;

&lt;h1&gt;nano -w /boot/grub/grub.conf&lt;/h1&gt;

&lt;p&gt;例如&lt;/p&gt;

&lt;h1&gt;默认选择哪个列表来引导。0表示第一个， 1表示第二个，以此类推。&lt;/h1&gt;

&lt;p&gt;default 0&lt;/p&gt;

&lt;h1&gt;引导默认列表前等待多少秒&lt;/h1&gt;

&lt;p&gt;timeout 30&lt;/p&gt;

&lt;h1&gt;使用漂亮、“臃肿”的spalsh图像来增加一点趣味:)&lt;/h1&gt;

&lt;h1&gt;如果您没有安装显卡，请将这行注释掉&lt;/h1&gt;

&lt;p&gt;splashimage=(hd0,0)/boot/grub/splash.xpm.gz&lt;/p&gt;

&lt;p&gt;title Gentoo Linux 2.6.29-r5&lt;/p&gt;

&lt;h1&gt;内核镜像（或者操作系统）所在分区&lt;/h1&gt;

&lt;p&gt;root (hd0,0)
kernel /boot/kernel-2.6.29-gentoo-r5 root=/dev/sda2&lt;/p&gt;

&lt;p&gt;＃ 如果使用ext4格式的分区，需要使用下面的参数
kernel /boot/kernel-2.6.29-gentoo-r5 root=/dev/sda2 rootfs=ext4&lt;/p&gt;

&lt;p&gt;title Gentoo Linux 2.6.29-r5 (rescue)&lt;/p&gt;

&lt;h1&gt;内核镜像（或者操作系统）所在分区&lt;/h1&gt;

&lt;p&gt;root (hd0,0)
kernel /boot/kernel-2.6.29-gentoo-r5 root=/dev/sda2 init=/bin/bb&lt;/p&gt;

&lt;h1&gt;接下来的四行只有在您与Windows系统进行双启动的情况下才需要。&lt;/h1&gt;

&lt;h1&gt;本例中，windows系统位于/dev/sda6。&lt;/h1&gt;

&lt;p&gt;title Windows XP
rootnoverify (hd0,5)
makeactive
chainloader +1&lt;/p&gt;

&lt;p&gt;使用grub-install安装GRUB&lt;/p&gt;

&lt;p&gt;为了安装GRUB，您将需要执行grub-install命令。尽管如此，当我们处于chroot的环境时，grub-install并不能正常的工作。我们还需要创建一个/etc/mtab，在里面列出所有已加载的文件系统。幸运的是，有一个简单的方法来完成这个任务——将/proc/mounts拷贝成/etc/mtab，如果您没有创建一个独立的boot分区，请排除rootfs行。下面的命令在两种情况下都可以正常工作：&lt;/p&gt;

&lt;h1&gt;grep -v rootfs /proc/mounts &amp;gt; /etc/mtab&lt;/h1&gt;

&lt;p&gt;现在我们就可以用grub-install来安装GRUB了：&lt;/p&gt;

&lt;h1&gt;grub-install &amp;ndash;no-floppy /dev/sda&lt;/h1&gt;

&lt;p&gt;将ssh加入到启动进程
rc-update add sshd default&lt;/p&gt;

&lt;p&gt;8b. 重启系统&lt;/p&gt;

&lt;h1&gt;exit&lt;/h1&gt;

&lt;p&gt;cdimage ~# cd
cdimage ~# umount /mnt/gentoo/boot /mnt/gentoo/dev /mnt/gentoo/proc /mnt/gentoo
cdimage ~# reboot&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Cocoa内存管理的简单规则[翻译]</title>
      <link>http://blog.prosight.me/blogs/133</link>
      <pubDate>2009-06-25 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;&lt;blockquote&gt;看了一篇mmalcolm crawford写的文章，觉得不错， &lt;a href=&#34;http://www.stepwise.com/Articles/Technical/2001-03-11.01.html&#34; target=&#34;_blank&#34;&gt;原文在此&lt;/a&gt;。比较清楚的讲解了Cocoa的内存管理。 对于Mac和iPhone的开发有很大帮助。 特翻译并略做修改以方便理解，希望与大家共勉&lt;/blockquote&gt;
对于一个新的Cocoa开发者来说，刚接触到内存管理的时候，一定很困惑。 下面给出了一些简单的规则，可以让你舒服些。如果你没有很好的使用这些规则的话，通常会带来内存泄露的问题或者运行时的异常。&lt;/p&gt;

&lt;p&gt;Cocoa过去没有垃圾回收机制，iPhone现在也没有。所以你必须自己来通过-retain, -release and -autorelease这些命令使用引用计数（reference counting）技术来管理内存。
&lt;table border=&#34;0&#34; cellspacing=&#34;0&#34;&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;th style=&#34;width: 100px;&#34;&gt;方法&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-retain&lt;/td&gt;
&lt;td&gt;给一个对象的引用计数加1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-release&lt;/td&gt;
&lt;td&gt;给一个对象的引用计数减1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-autorelease&lt;/td&gt;
&lt;td&gt;在将来的某些时候将一个对象的引用计数减1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-alloc&lt;/td&gt;
&lt;td&gt;分配一块内存给对象，引用计数器将设为1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-copy&lt;/td&gt;
&lt;td&gt;拷贝一个对象，将返回引用计数为1的一个对象&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;&lt;/p&gt;

&lt;h3&gt;引用计数规则&lt;/h3&gt;

&lt;ol&gt;
    &lt;li&gt;\u000a```在你的方法中使用了-copy\u000a```, \u000a```-alloc\u000a``` 和 \u000a```-retain来申请内存，就要对应的使用\u000a```\u000a```-release\u000a``` 和 \u000a```-autorelease来释放内存；\u000a```&lt;/li&gt;
    &lt;li&gt;当对象使用便捷方法创建的时候（如：NSString类的 &lt;tt&gt;stringWithString方法），则这个对象将被视为已经使用了&lt;/tt&gt;\u000a```autorelease，在将来某时自动释放内存；\u000a```&lt;/li&gt;
    &lt;li&gt;如果你定义了实例变量，则在你的类中实现\u000a```-dealloc这个方法来释放他们。\u000a```&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;例子：&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt; -alloc / -release &lt;/em&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)printHello
{
    NSString *string;
    string = [[NSString alloc] initWithString:@&amp;ldquo;Hello&amp;rdquo;];
    NSLog(string);
    // 我们使用alloc来创建了一个string 所以要release它
    [string release];
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;便捷构造方法&lt;/em&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)printHello
{
    NSString *string;
    string = [NSString stringWithFormat:@&amp;ldquo;Hello&amp;rdquo;];
    NSLog(string);
    // 我们构建这个string的时候，使用了便捷构造方法( convenience constructor )
    // 所以我们认为它是 autoreleased的
}
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;永远使用accessor方法&lt;/h3&gt;

&lt;p&gt;有时候你会觉得使用accessor方法会比较教条和无聊，但是使用他们会降低内存泄露的机会。&lt;/p&gt;

&lt;p&gt;如果对于实例变量你也使用 -retain 和-release 来管理内存的话，那就错了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;例子&lt;/strong&gt;
在接口中定义了一个实例变量
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
@interface Counter : NSObject
{
    NSNumber *count;
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在实现中加入accessor方法
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (NSNumber *)count
{
    return count;
    // 不需要retain或者release
    // 我们只是返回这个变量的值
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;(void)setCount:(NSNumber *)newCount
{&lt;/p&gt;

&lt;p&gt;// 如果每个人都使用上述同样的内存管理规则
// 我们就得认为newCount是autoreleased的。
// 因为我们想使用这个变量，所以我们必须retain它
// 避免它被释放掉。
[newCount retain];&lt;/p&gt;

&lt;p&gt;// 因为我们只想在这个方法中改变这个类中的count值
// 所以要通过这个方法，先释放掉之前的内存
// 在Objective-C中[nil release]也是被允许的
// 我们必须将次调用放在 [newCount retain] 的后面
// 因为如果当count和newCount都指向同一个对象的时候
// 我们会错误的释放它
[count release];&lt;/p&gt;

&lt;p&gt;// 关联新的引用
count = newCount;
}
&lt;/pre&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因为我们的类有实例变量，所以需要实现-dealloc方法来释放内存。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)dealloc
{
    [self setCount:nil];
    [super dealloc];
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;假设我们需要一个重置count的值的方法，我们有两个选择&lt;/p&gt;

&lt;p&gt;&lt;em&gt;便捷构造方法convenience constructor&lt;/em&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)reset
{
    NSNumber *zero = [NSNumber numberWithInt:0];
    [self setCount:zero];
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;使用-alloc方法&lt;/em&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)reset
{
    NSNumber *zero = [[NSNumber alloc] initWithInt:0];
    [self setCount:zero];
    [zero release];
}
&lt;/pre&gt;&lt;/p&gt;

&lt;h3&gt;常见错误&lt;/h3&gt;

&lt;p&gt;下面的问题在一些简单的环境下可能会正常工作，但是避开使用accessor方法，在某些时候几乎可以肯定会带来内存泄露的问题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;没有使用accessor方法&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)reset
{
    NSNumber *zero = [[NSNumber alloc] initWithInt:0];
    [count release]
    count = zero;
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;变量没有释放&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)reset
{
    NSNumber *zero = [[NSNumber alloc] initWithInt:0];
    [self setCount:zero];
}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;当使用alloc创建一个新对象的时候，retain count是1，如果我们没有在这个方法中使用－release方法，这个number对象将永远不能被释放，将会造成内存泄露。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;已经释放内存的变量再次调用release&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
- (void)reset
{
    NSNumber *zero = [NSNumber numberWithInt:0];
    [self setCount:zero];
    [zero release];
}
&lt;/pre&gt;
这将导致当你第一次访问count的时候发生错误。 便捷构造方法将返回一个autoreleased对象，所以你不必使用release。 在使用autoreleased后这样做，将减少count的计数到0，这个对象将被释放。当你之后视图访问count的时候，你将向一个自由对象（free object）发送调用消息（message），通常你将得到一个SIGBUS 10的错误。&lt;/p&gt;

&lt;h3&gt;经常让人混淆迷惑的问题 － 数组和其他集合类&lt;/h3&gt;

&lt;p&gt;当一个对象被添加到一个array, dictionary, 或者 set等这样的集合类型中的时候，集合会retain它。 对应的，当集合类被release的时候，它会发送对应的release消息给包含在其中的对象。 因此，如果你想建立一个包含一堆number的数组，你可以像下面示例中的几个方法来做&lt;/p&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSMutableArray *array;
    int i;
    // &amp;hellip;
    for (i = 0; i &amp;lt; 10; i++)
    {
        NSNumber *n = [NSNumber numberWithInt: i];
        [array addObject: n];
    }
&lt;/pre&gt;
在这种情况下， 我们不需要retain这些number，因为array将替我们这么做。&lt;/p&gt;

&lt;p&gt;&lt;pre class=&#34;prettyprint linenums&#34;&gt;
NSMutableArray *array;
    int i;
    // &amp;hellip;
    for (i = 0; i &amp;lt; 10; i++)
    {
        NSNumber *n = [[NSNumber alloc] initWithInt: i];
        [array addObject: n];
        [n release];
    }
&lt;/pre&gt;
在这个例子中，因为你使用了-alloc去建立了一个number，所以你必须显式的-release它，以保证retain count的平衡。因为将number加入数组的时候，已经retain它了，所以数组中的number变量不会被release&lt;/p&gt;
</description>
    </item>
    <item>
      <title>XCode 常用快捷键</title>
      <link>http://blog.prosight.me/blogs/146</link>
      <pubDate>2009-06-25 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
    &lt;li&gt; Alt-⌘-Up 在 .m 文件和 .h 文件间切换&lt;/li&gt;
    &lt;li&gt;⌘-Shift-D, When you want to open a file or a symbol definition that’s in your project or in a framework.&lt;/li&gt;
    &lt;li&gt;⌘-Shift-E 全屏展开编辑器窗口&lt;/li&gt;
    &lt;li&gt;Alt-⌘-Left / Alt-⌘-Right, 在打开的文件间切换&lt;/li&gt;
    &lt;li&gt;Tab 接受当前的自动完成&lt;/li&gt;
    &lt;li&gt;Escape 展开一个所有可能的自动完成列表 (例如在点后按Esc键，就会展开一个自动完成列表).&lt;/li&gt;
    &lt;li&gt;Control-, 显式可能的自动完成列表, Control-. 插入最有可能的自动完成,  Control-/ 和 Shift-Control-/ 在每个自动完成输入框间切换.&lt;/li&gt;
    &lt;li&gt;⌘-double click on a symbol 查看这个类型的定义.&lt;/li&gt;
    &lt;li&gt;Option-double click on a symbol 查找选中内容的API文档.&lt;/li&gt;
    &lt;li&gt;Cmd-/ 自动加入 “//” 注释.&lt;/li&gt;
    &lt;li&gt;Ctrl+Left/Right Arrow 在单词间切换&lt;/li&gt;
    &lt;li&gt;右键点击一个变量名，然后选择edit all in scope 则可以在这个文档中批量的修改这个变量名.&lt;/li&gt;
    &lt;li&gt;⌘-[ and ⌘-] 增加或者减少缩进&lt;/li&gt;
    &lt;li&gt;双击中括号或者大括号，可以显示跟它对应的那个括号&lt;/li&gt;
    &lt;li&gt;Control-Shift-R 切换到控制台&lt;/li&gt;
    &lt;li&gt;Control-Alt-⌘-R 清除日志&lt;/li&gt;
    &lt;li&gt;Control-⌘ Left/Right 展开或者收起函数&lt;/li&gt;
    &lt;li&gt;Shift-⌘-C, 显示class browser&lt;/li&gt;
    &lt;li&gt;⌘-=, 跳转到下一个错误.&lt;/li&gt;
    &lt;li&gt;⌘-Shift-F显示查找输入框.&lt;/li&gt;
    &lt;li&gt;⌘-Shift-B显示build窗口&lt;/li&gt;
    &lt;li&gt;⌘-Shift-Y显示debug窗口.&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>给iPhone程序创建Splash欢迎界面</title>
      <link>http://blog.prosight.me/blogs/118</link>
      <pubDate>2009-06-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;看到很多iPhone的程序都有一个欢迎页面，看到网上有篇文章，参考结合自己的实际做了一个例子。&lt;/p&gt;

&lt;h3&gt;官方SDK最简单的方法&lt;/h3&gt;

&lt;p&gt;最简单的方法就是做一个全屏的欢迎页的图片，把它命名为Default.png，然后放在Xcode工程的Resource里面。 执行就可以看到你的这个默认图像在程序完全加载之前显示在屏幕上。&lt;/p&gt;

&lt;p&gt;但是这个方法有个问题，如果你的程序很快载入了，这个图片会立刻消失，导致还没有看清楚图片上的内容。 而且有些内容虽然程序已经载入了，但是有些程序需要的资源是要从服务器上加载的，所以直接进入程序，用户还是无法使用这个应用。&lt;/p&gt;

&lt;h3&gt;自定义model view方法&lt;/h3&gt;

&lt;p&gt;这个方法的大体思路就是创建一个model view，在程序载入完成后调用这个model view，显示其中的图片。当你的资源载入完成后，再完全移除这个model view。 具体方法为：
&lt;ol&gt;&lt;/p&gt;

&lt;p&gt;&lt;li&gt;随便建立一个iPhone的工程，例如叫Splash。&lt;/li&gt;
&lt;li&gt;在SplashAppDelegate.m中，在applicationDidFinishLaunching方法的最后加入:&lt;/li&gt;&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
[viewController showSplash];
&lt;/pre&gt;
以在加载程序完成后，显示欢迎页

&lt;li&gt;在SplashViewController.h加入以下属性和方法&lt;/li&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &lt;uikit/UIKit.h&gt;

@interface SplashViewController : UIViewController {
    IBOutlet UIView *modelView;

}

- (void) showSplash;
- (void) hideSplash;

@end
&lt;/pre&gt;
其中*modelView就是我们要用到的model view，用来显示splash图片的。 另外两个方法是控制显示和隐藏这个splash的

&lt;li&gt;在SplashController.m加入上面定义的两个方法的实现&lt;/li&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
-(void)showSplash
{
    UIViewController *modalViewController = [[UIViewController alloc] init];

    modalViewController.view = modelView;

    [self presentModalViewController:modalViewController animated:NO];

    [self performSelector:@selector(hideSplash) withObject:nil afterDelay:2.0];

}

//hide splash screen

- (void)hideSplash{

    [[self modalViewController] dismissModalViewControllerAnimated:YES];

}
&lt;/pre&gt;

&lt;p&gt;&lt;br /&gt;
&lt;li&gt;创建视图&lt;/li&gt;
在Interface builder中给SplashView添加一个view视图，在工具栏里面拖拽一个view视图到Splash VIew中
[caption id=&amp;ldquo;attachment_120&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;272&amp;rdquo; caption=&amp;ldquo;view视图&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/15.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/15.png&#34; alt=&#34;view视图&#34; title=&#34;view视图&#34; width=&#34;272&#34; height=&#34;60&#34; class=&#34;size-full wp-image-120&#34; /&gt;&lt;/a&gt;[/caption]
[caption id=&amp;ldquo;attachment_121&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;225&amp;rdquo; caption=&amp;ldquo;添加view视图&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/21.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/21.png&#34; alt=&#34;添加view视图&#34; title=&#34;添加view视图&#34; width=&#34;225&#34; height=&#34;95&#34; class=&#34;size-full wp-image-121&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;链接File&amp;rsquo;s Owner中的modelview到新建的view上
[caption id=&amp;ldquo;attachment_122&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;281&amp;rdquo; caption=&amp;ldquo;链接modelview到新建的view上&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/32.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/32.png&#34; alt=&#34;链接modelview到新建的view上&#34; title=&#34;链接modelview到新建的view上&#34; width=&#34;281&#34; height=&#34;57&#34; class=&#34;size-full wp-image-122&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;li&gt;添加imageView到新建的view上&lt;/li&gt;
拖拽一个imageview到刚建立的view中
[caption id=&amp;ldquo;attachment_123&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;272&amp;rdquo; caption=&amp;ldquo;添加imageview&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/42.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/42.png&#34; alt=&#34;添加imageview&#34; title=&#34;添加imageview&#34; width=&#34;272&#34; height=&#34;55&#34; class=&#34;size-full wp-image-123&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;选中这个imageview，修改其中的image属性为你指定的图片，我这里选择了之前导入的Default.png
[caption id=&amp;ldquo;attachment_124&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;285&amp;rdquo; caption=&amp;ldquo;指定图片&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/5.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/5.png&#34; alt=&#34;指定图片&#34; title=&#34;指定图片&#34; width=&#34;285&#34; height=&#34;201&#34; class=&#34;size-full wp-image-124&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;&lt;/ol&gt;&lt;/p&gt;

&lt;p&gt;之后你就可以运行了，应该是2秒后，splash图片自动消失。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>MySQL 编译参数优化</title>
      <link>http://blog.prosight.me/blogs/112</link>
      <pubDate>2009-06-23 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;适当的调整MySQL的编译参数，可以极大的提升MySQL的性能，官方文档说可以提升10-30％的性能。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;-static  13%
&amp;ndash;with-client-ldflags=-all-static
&amp;ndash;with-mysqld-ldflags=-all-static
静态链接提高13%性能&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;-pgcc  1%
CFLAGS=&amp;ldquo;-O3 -mnocona -mstack-align-double&amp;rdquo; CXX=gcc
 CXXFLAGS=&amp;ldquo;-O3 -mnocona -mstack-align-double
 -felide-constructors -fno-exceptions -fno-rtti&amp;rdquo;
如果是Inter处理器，使用pgcc提高1%性能, 其中-m参数指定你cpu的类型，如果你是Intel Pentium4 支持64位的CPU就试用nocona这个参数，如果你是Intel Core2则使用core2这个参数。详细的cpu支持参数列表在&lt;a href=&#34;http://gcc.gnu.org/onlinedocs/gcc-4.4.0/gcc/i386-and-x86_002d64-Options.html#i386-and-x86_002d64-Options&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Unix Socket  7.5%
&amp;ndash;with-unix-socket-path=/usr/local/mysql/tmp/mysql.sock
使用unix套接字链接提高7.5%性能，所以在windows下mysql性能肯定不如unix下面&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&amp;ndash;enable-assembler
允许使用汇编模式(优化性能)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
CFLAGS=&#34;-O3 mnocona&#34; CXX=gcc CXXFLAGS=&#34;-O3 mnocona -felide-constructors 
         -fno-exceptions -fno-rtti -fomit-frame-pointer -ffixed-ebp&#34;
        ./configure 
           --prefix=/usr/local/mysql --enable-assembler 
           --with-mysqld-ldflags=-all-static
           --with-client-ldflags=-all-static
           --with-unix-socket-path=/usr/local/mysql/tmp/mysql.sock
           --with-charset=utf8
           --with-collation=utf8_general_ci
           --with-extra-charsets=all
&lt;/pre&gt;
</description>
    </item>
    <item>
      <title>通过U盘安装Gentoo minimal iso</title>
      <link>http://blog.prosight.me/blogs/110</link>
      <pubDate>2009-06-22 12:00:00 +0800</pubDate>
      <description>&lt;ol&gt;
&lt;li&gt;下载install-amd64-minimal-20090618.iso&lt;/li&gt;
&lt;li&gt;利用UltraISO来刻录镜像&lt;/li&gt;
&lt;li&gt;插入U盘&lt;/li&gt;
&lt;li&gt;用UltralISO打开iso文件&lt;/li&gt;
&lt;li&gt;选择启动 -&amp;gt; 写入硬盘镜像&lt;/li&gt;
&lt;li&gt;格式化U盘，再点写入&lt;/li&gt;
&lt;li&gt;在BIOS中选择从USB启动
之后就可以用U盘启动系统，进行安装了。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    <item>
      <title>CentOS环境中lighttpd+php+fastcgi+eAccelerator安装配置</title>
      <link>http://blog.prosight.me/blogs/97</link>
      <pubDate>2009-06-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Lighttpd 作为新一代的web server，以小巧（不到1M的大小）、快速而著称，因为服务器上安装了rails、java，并以lighttpd为前端代理服务器，不想再部署apache了，所以直接使用lighttpd来部署，顺便看一下性能如何。&lt;/p&gt;

&lt;p&gt;本文主要介绍在CentOS下，配置一套用lighttp作为web server的php环境&lt;/p&gt;

&lt;p&gt;· 安装Lighttpd
从http://www.lighttpd.net/download/下载源码
安装前先检查pcre是否安装，需要pcre和pcre-devel两个包。 用yum search pcre*检查，如果都是installed就是都安装了。否则安装缺少的包。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;yum install pcre-devel&lt;/p&gt;

&lt;p&gt;tar xzvf lighttpd-1.4.23.tar.gz
cd lighttpd-1.4.23
./configure &amp;ndash;prefix=/usr/local/lighttpd
 &lt;/pre&gt;
configure完毕以后，会给出一个激活的模块和没有激活模块的清单，可以检查一下，是否自己需要的模块都已经激活，在enable的模块中一定要有“mod_rewrite”这一项，否则重新检查pcre是否安装。然后编译安装：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;make &amp;amp;&amp;amp; make install &lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;编译后配置：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cp doc/sysconfig.lighttpd /etc/sysconfig/lighttpd
mkdir /etc/lighttpd
cp doc/lighttpd.conf /etc/lighttpd/lighttpd.conf
 &lt;/pre&gt;
如果你的Linux是RedHat/CentOS，那么：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cp doc/rc.lighttpd.redhat /etc/init.d/lighttpd
 &lt;/pre&gt;
如果你的Linux是SuSE，那么：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cp doc/rc.lighttpd /etc/init.d/lighttpd
 &lt;/pre&gt;
其他Linux发行版本可以自行参考该文件内容进行修改。然后修改/etc/init.d/lighttpd，把
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
lighttpd=&amp;ldquo;/usr/sbin/lighttpd&amp;rdquo;
 &lt;/pre&gt;
改为
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
lighttpd=&amp;ldquo;/usr/local/lighttpd/sbin/lighttpd&amp;rdquo;
  &lt;/pre&gt;
此脚本用来控制lighttpd的启动关闭和重起：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/etc/init.d/lighttpd start
/etc/init.d/lighttpd stop
/etc/init.d/lighttpd restart
 &lt;/pre&gt;
如果你希望服务器启动的时候就启动lighttpd，那么：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
chkconfig lighttpd on
&lt;/pre&gt;
这样lighttpd就安装好了，接下来需要配置lighttpd。&lt;/p&gt;

&lt;p&gt;配置Lighttpd&lt;/p&gt;

&lt;p&gt;修改/etc/lighttpd/lighttpd.conf
1）server.modules
取消需要用到模块的注释，mod_rewrite，mod_access，mod_fastcgi，mod_simple_vhost，mod_cgi，mod_compress，mod_accesslog是一般需要用到的。&lt;/p&gt;

&lt;p&gt;2）server.document-root, server.error-log，accesslog.filename需要指定相应的目录&lt;/p&gt;

&lt;p&gt;3）用什么权限来运行lighttpd
server.username            = &amp;ldquo;nobody&amp;rdquo;
server.groupname           = &amp;ldquo;nobody&amp;rdquo;
从安全角度来说，不建议用root权限运行web server，可以自行指定普通用户权限。&lt;/p&gt;

&lt;p&gt;4）静态文件压缩
compress.cache-dir         = &amp;ldquo;/tmp/lighttpd/cache/compress&amp;rdquo;
compress.filetype          = (&amp;ldquo;text/plain&amp;rdquo;, &amp;ldquo;text/html&amp;rdquo;,&amp;ldquo;text/javascript&amp;rdquo;,&amp;ldquo;text/css&amp;rdquo;)
可以指定某些静态资源类型使用压缩方式传输，节省带宽，对于大量AJAX应用来说，可以极大提高页面加载速度。&lt;/p&gt;

&lt;p&gt;5）配置ruby on rails&lt;/p&gt;

&lt;p&gt;最简单的配置如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$HTTP[&amp;ldquo;host&amp;rdquo;] == &amp;ldquo;www.xxx.com&amp;rdquo; {
 server.document-root = &amp;ldquo;/yourrails/public&amp;rdquo;
 server.error-handler-404 = &amp;ldquo;/dispatch.fcgi&amp;rdquo;
 fastcgi.server = (&amp;ldquo;.fcgi&amp;rdquo; =&amp;gt;
    (&amp;ldquo;localhost&amp;rdquo; =&amp;gt;
      (&amp;ldquo;min-procs&amp;rdquo; =&amp;gt; 10,
       &amp;ldquo;max-procs&amp;rdquo; =&amp;gt; 10,
       &amp;ldquo;socket&amp;rdquo; =&amp;gt; &amp;ldquo;/tmp/lighttpd/socket/rails.socket&amp;rdquo;,
       &amp;ldquo;bin-path&amp;rdquo; =&amp;gt; &amp;ldquo;/yourrails/public/dispatch.fcgi&amp;rdquo;,
       &amp;ldquo;bin-environment&amp;rdquo; =&amp;gt; (&amp;ldquo;RAILS_ENV&amp;rdquo; =&amp;gt; &amp;ldquo;production&amp;rdquo;)
      )
    )
 )
}
&lt;/pre&gt;
即由lighttpd启动10个FCGI进程，lighttpd和FCGI之间使用本机Unix Socket通信。&lt;/p&gt;

&lt;p&gt;如果想指定www.abc.com以及所有二级域名，则需要把第一行改为
$HTTP[”host”] =~ “(^|.)abc.com” {
…
}&lt;/p&gt;

&lt;p&gt;如果要设置代理，比如lighttpd和tomcat整合，tomcat放在lighttpd后面，则需要通过代理访问tomcat&lt;/p&gt;

&lt;p&gt;$HTTP[&amp;ldquo;host&amp;rdquo;] =~ &amp;ldquo;www.domain.cn&amp;rdquo; {
   proxy.server = ( &amp;ldquo;&amp;rdquo; =&amp;gt; ( &amp;ldquo;localhost&amp;rdquo; =&amp;gt; ( &amp;ldquo;host&amp;rdquo;=&amp;gt; &amp;ldquo;127.0.0.1&amp;rdquo;, &amp;ldquo;port&amp;rdquo;=&amp;gt; 8080 ) ) )
}&lt;/p&gt;

&lt;p&gt;则www.domain.cn为主机的网址都交给tomcat处理，tomcat的端口号为8080. 在tomcat的虚拟主机中，需要捕获www.domain.cn这个主机名，设置这个虚拟主机。这里的host都是跟tomcat里面的虚拟主机对应的。&lt;/p&gt;

&lt;p&gt;· 安装支持fastcgi的PHP
安装PHP所需的相关类库
curl
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://curl.cs.pu.edu.tw/download/curl-7.19.5.tar.bz2&#34;&gt;http://curl.cs.pu.edu.tw/download/curl-7.19.5.tar.bz2&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;tar xvjf curl-7.19.5.tar.bz2
cd curl-7.19.5
./configure &amp;ndash;prefix=/usr/local/curl
make
make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;gettext
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;ftp://ftp.ntu.edu.tw/pub/gnu/gnu/gettext/gettext-0.17.tar.gz&#34;&gt;ftp://ftp.ntu.edu.tw/pub/gnu/gnu/gettext/gettext-0.17.tar.gz&lt;/a&gt;
tar xvzf gettext-0.17.tar.gz
cd gettext-0.17
./configure &amp;ndash;prefix=/usr/local/gettext
make
make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;zlib
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://kent.dl.sourceforge.net/sourceforge/libpng/zlib-1.2.3.tar.gz&#34;&gt;http://kent.dl.sourceforge.net/sourceforge/libpng/zlib-1.2.3.tar.gz&lt;/a&gt;
tar xvzf zlib-1.2.3.tar.gz
cd zlib-1.2.3
./configure &amp;ndash;prefix=/usr/local/zlib
make &amp;amp;&amp;amp; make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;libpng
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://www.mirrorservice.org/sites/download.sourceforge.net/pub/sourceforge/l/li/libpng/libpng-1.2.9.tar.gz&#34;&gt;http://www.mirrorservice.org/sites/download.sourceforge.net/pub/sourceforge/l/li/libpng/libpng-1.2.9.tar.gz&lt;/a&gt;
tar xvzf libpng-1.2.9.tar.gz
cd libpng-1.2.9
./configure &amp;ndash;prefix=/usr/local/libpng
make &amp;amp;&amp;amp; make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;jpeg
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://www.ijg.org/files/jpegsrc.v6b.tar.gz&#34;&gt;http://www.ijg.org/files/jpegsrc.v6b.tar.gz&lt;/a&gt;
tar xvzf jpegsrc.v6b.tar.gz
cd jpeg-6b/
./configure &amp;ndash;prefix=/usr/local/jpeg6
make&lt;/p&gt;

&lt;p&gt;mkdir /usr/local/jpeg6/bin
mkdir -p /usr/local/jpeg6/bin
mkdir -p /usr/local/jpeg6/man/man1
mkdir -p /usr/local/jpeg6/lib
mkdir -p /usr/local/jpeg6/include
make install-lib
make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;freetype
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://download.savannah.gnu.org/releases/freetype/freetype-2.3.9.tar.gz&#34;&gt;http://download.savannah.gnu.org/releases/freetype/freetype-2.3.9.tar.gz&lt;/a&gt;
tar xvzf freetype-2.3.9.tar.gz
cd freetype-2.3.9
./configure &amp;ndash;prefix=/usr/local/freetype2
make
make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;gd
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://www.libgd.org/releases/gd-2.0.35.tar.gz&#34;&gt;http://www.libgd.org/releases/gd-2.0.35.tar.gz&lt;/a&gt;
tar xvzf gd-2.0.35.tar.gz
cd gd-2.0.35
./configure &amp;ndash;prefix=/usr/local/gd2 &amp;ndash;with-zlib=/usr/local/zlib/ &amp;ndash;with-png=/usr/local/libpng/ &amp;ndash;with-jpeg=/usr/local/jpeg6/ &amp;ndash;with-freetype=/usr/local/freetype2/
make
如果第一次make出错，试着再make一次，我就是这样，第二次就对了。
make install
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;PHP
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
tar xvzf php-5.2.10.tar.gz
cd php-5.2.10
./configure &amp;ndash;prefix=/usr/local/php &amp;ndash;with-mysql=/usr/local/mysql &amp;ndash;with-pdo-mysql=/usr/local/mysql &amp;ndash;with-jpeg-dir=/usr/local/jpeg6/ &amp;ndash;with-png-dir=/usr/local/libpng/ &amp;ndash;with-gd=/usr/local/gd2/ &amp;ndash;with-freetype-dir=/usr/local/freetype2/  &amp;ndash;with-zlib-dir=/usr/local/zlib &amp;ndash;with-curl=/usr/local/curl &amp;ndash;with-gettext=/usr/local/gettext &amp;ndash;enable-fastcgi &amp;ndash;enable-zend-multibyte &amp;ndash;with-config-file-path=/etc &amp;ndash;enable-discard-path &amp;ndash;enable-force-cgi-redirect
make
make install
cp php.ini-dist /etc/php.ini&lt;/p&gt;

&lt;p&gt;可以使用php -m查看你安装的模块
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;eAccelerator
eAccelerator是一个开源的PHP加速器
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
wget &lt;a href=&#34;http://bart.eaccelerator.net/source/0.9.5.3/eaccelerator-0.9.5.3.tar.bz2&#34;&gt;http://bart.eaccelerator.net/source/0.9.5.3/eaccelerator-0.9.5.3.tar.bz2&lt;/a&gt;
tar xjvf eaccelerator-0.9.5.3.tar.bz2
cd eaccelerator-0.9.5.3
export PHP_PREFIX=&amp;ldquo;/usr/local/php&amp;rdquo;
$PHP_PREFIX/bin/phpize
./configure &amp;ndash;enable-eaccelerator=shared &amp;ndash;with-php-config=$PHP_PREFIX/bin/php-config
make
make install
&lt;/pre&gt;
执行好后，会提示安装到的路径，下面会用到，如我的被安装到这里
/usr/local/php/lib/php/extensions/no-debug-non-zts-20060613
编辑php.ini中的内容
vim /etc/php.ini
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
cgi.fix_pathinfo = 1&lt;/p&gt;

&lt;p&gt;zend_extension=&amp;ldquo;/usr/local/php/lib/php/extensions/no-debug-non-zts-20060613/eaccelerator.so&amp;rdquo;
eaccelerator.shm_size=&amp;ldquo;16&amp;rdquo;
eaccelerator.cache_dir=&amp;ldquo;/tmp/eaccelerator&amp;rdquo;
eaccelerator.enable=&amp;ldquo;1&amp;rdquo;
eaccelerator.optimizer=&amp;ldquo;1&amp;rdquo;
eaccelerator.check_mtime=&amp;ldquo;1&amp;rdquo;
eaccelerator.debug=&amp;ldquo;0&amp;rdquo;
eaccelerator.filter=&amp;ldquo;&amp;rdquo;
eaccelerator.shm_max=&amp;ldquo;0&amp;rdquo;
eaccelerator.shm_ttl=&amp;ldquo;0&amp;rdquo;
eaccelerator.shm_prune_period=&amp;ldquo;0&amp;rdquo;
eaccelerator.shm_only=&amp;ldquo;0&amp;rdquo;
eaccelerator.compress=&amp;ldquo;1&amp;rdquo;
eaccelerator.compress_level=&amp;ldquo;9&amp;rdquo;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如果一切顺利，你可以通过下面命令来验证是否安装成功
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
$ php -v
PHP 5.2.10 (cli) (built: Jun 20 2009 23:32:09)
Copyright &amp;copy; 1997-2009 The PHP Group
Zend Engine v2.2.0, Copyright &amp;copy; 1998-2009 Zend Technologies
    with eAccelerator v0.9.5.3, Copyright &amp;copy; 2004-2006 eAccelerator, by eAccelerator
&lt;/pre&gt;
修改/etc/lighttpd/lighttpd.conf文件，添加下面的配置
vim /etc/lighttpd/lighttpd.conf
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
fastcgi.server             = ( &amp;ldquo;.php&amp;rdquo; =&amp;gt;
                               ( &amp;ldquo;localhost&amp;rdquo; =&amp;gt;
                                 (
                                   &amp;ldquo;socket&amp;rdquo; =&amp;gt; &amp;ldquo;/tmp/php-fastcgi.socket&amp;rdquo;,
                                   &amp;ldquo;bin-path&amp;rdquo; =&amp;gt; &amp;ldquo;/usr/local/php/bin/php-cgi&amp;rdquo;
                                 )
                               )
                            )
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;重启lighttpd
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
/etc/init.d/lighttpd restart
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;写一个php测试文件在lighttpd的网站目录里，测试php是否安装成功&lt;/p&gt;
</description>
    </item>
    <item>
      <title>iPhone SDK 3.0 MAPKit使用入门（1） 创建一个MKMapView实例</title>
      <link>http://blog.prosight.me/blogs/105</link>
      <pubDate>2009-06-21 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;iPhone OS 3.0发布了，MAPKit是其中新增的API，但是Apple并没有公布相应的guide，只有一个相关函数的API。 再网上参考了其他人的例子，试着照猫画虎的做了几个例子。&lt;/p&gt;

&lt;p&gt;MAPKit主要的类是MKMapView，它提供了一个嵌入式的地图接口，就像在自带的Maps程序里提供的那样。你可以使用这个类在你的程序中显示地图和操作地图&lt;/p&gt;

&lt;p&gt;当你初始化一个map view（MKMapView的实例）的时候，你需要指定一个region（MKCoordinateRegion类型）给这个地图。你可以通过指定map view实例的region属性来设置它的值。region定义了一个中央点和水平和垂直的距离，这个区域显示的大小和比例是根据一个span来调节的。&lt;/p&gt;

&lt;p&gt;span(MKCoordinateSpan)定义了指定中央点(point)的map能显示多少内容以及比例尺。 一个大的span的值，将可以展现更多的内容和更小的放大级别，反之则展现更细节的内容和更大的放大级别。&lt;/p&gt;

&lt;p&gt;你可以通过设置map view的scrollEnabled 和 zoomEnabled属性来设置是否允许滚动地图和放大缩小地图。&lt;/p&gt;

&lt;p&gt;我们先来看一个例子：
创建一个utility application应用程序，在MainViewController.h中引入MapKit/MapKit.h头文件，定义一个MKMapView实体变量
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &amp;ldquo;FlipsideViewController.h&amp;rdquo;
#import &lt;mapKit/MapKit.h&gt;&lt;/p&gt;

&lt;p&gt;@interface MainViewController : UIViewController &lt;flipsideViewControllerDelegate&gt; {
    MKMapView *mapView;
}&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(IBAction)showInfo;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;@end
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;在MainViewController.m中，
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
#import &amp;ldquo;MainViewController.h&amp;rdquo;
#import &amp;ldquo;MainView.h&amp;rdquo;&lt;/p&gt;

&lt;p&gt;@implementation MainViewController&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;(id)initWithNibName:(NSString *)nibNameOrNil bundle:(NSBundle *)nibBundleOrNil {
if (self = [super initWithNibName:nibNameOrNil bundle:nibBundleOrNil]) {
    // Custom initialization
}
return self;
}&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;// Implement viewDidLoad to do additional setup after loading the view, typically from a nib.
 - (void)viewDidLoad {
 [super viewDidLoad];
     mapView = [[MKMapView alloc] initWithFrame:self.view.bounds];
     mapView.showsUserLocation=TRUE;
     [self.view insertSubview:mapView atIndex:0];
 }&lt;/p&gt;

&lt;p&gt;&amp;hellip;
&lt;/pre&gt;
就是初始化了一个MKMapView实例，并将它显示在主视图上。
之后就可以执行了， 你可以看到一个标有你当前位置点的小程序。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Tomcat 启动gzip压缩输出页面大小及其他优化</title>
      <link>http://blog.prosight.me/blogs/91</link>
      <pubDate>2009-06-20 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在输出的页头中加入
&lt;pre class=&#34;prettyprint linenums&#34;&gt;Content-Encoding: gzip&lt;/pre&gt;
可以有效的减少页面的大小，一般可以减小1/3左右。
对于tomcat来说修改起来也很见到， 在tomcat下的conf/server.xml文件中，修改
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;connector port=&#34;8080&#34; maxHttpHeaderSize=&#34;8192&#34; useBodyEncodingForURI=&#34;true&#34;
                maxThreads=&#34;1000&#34; minSpareThreads=&#34;25&#34; maxSpareThreads=&#34;75&#34;
                enableLookups=&#34;false&#34; redirectPort=&#34;8443&#34; acceptCount=&#34;100&#34;
                compression=&#34;on&#34; compressionMinSize=&#34;2048&#34;
            compressableMimeType=&#34;text/html,text/xml,text/javascript,text/css,text/plain&#34;
                connectionTimeout=&#34;20000&#34; disableUploadTimeout=&#34;true&#34; URIEncoding=&#34;UTF-8&#34;/&gt;
&lt;/pre&gt;
就可以对html,xml,css,javascript和纯文本进行压缩。&lt;/p&gt;

&lt;p&gt;其中
&lt;ul&gt;
    &lt;li&gt; maxHttpHeaderSize：Http的Header的最大限制&lt;/li&gt;
    &lt;li&gt;maxThreads：Tomcat可创建的最大的线程数&lt;/li&gt;
    &lt;li&gt;minSpareThreads：初始化创建的线程数&lt;/li&gt;
    &lt;li&gt;maxSpareThreads：一旦创建的线程超过这个数，Tomcat就将关闭不再需要的Socket线程&lt;/li&gt;
    &lt;li&gt;enableLookups：使用允许DNS查询，通常情况下设置为false&lt;/li&gt;
    &lt;li&gt;acceptCount：当所有可以使用的处理请求的线程树都被使用时，可以放到请求队列中的请求数，超过这个数的请求将不予处理。其实，该属性与ServerSocket(int port,int backlog)中的backlog参数意义相同，具体可参考ServerSocket的JDK API&lt;/li&gt;
    &lt;li&gt;connectionTimeout：网络连接超时，单位毫秒。设置为0表示永不超时&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>XCode 引入其他的Framework</title>
      <link>http://blog.prosight.me/blogs/87</link>
      <pubDate>2009-06-19 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;当你开发iphone应用的时候，需要引用其他Framework的时候，需要按照以下步骤引入&lt;/p&gt;

&lt;p&gt;右键点击项目下的Frameworks，选择add-&amp;gt;exsiting frameworks&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_88&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;449&amp;rdquo; caption=&amp;ldquo;导入Framework&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/14.png&#34;&gt;&lt;img class=&#34;size-full wp-image-88&#34; title=&#34;导入Framework&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/14.png&#34; alt=&#34;导入Framework&#34; width=&#34;449&#34; height=&#34;178&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;然后选择/Developer/platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulatorx.x.sdk/system/Library/Frameworks,这下面就是所有的iphone可以利用的Framework了。选择你需要的导入就可以了&lt;/p&gt;
</description>
    </item>
    <item>
      <title>MySQL 5.1.35 安装Innodb报unknown variable innodb_data_home_dir错误</title>
      <link>http://blog.prosight.me/blogs/82</link>
      <pubDate>2009-06-18 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天在一台服务器上安装最新的Mysql 5.1.35，通过源代码安装。&lt;/p&gt;

&lt;p&gt;编译安装都很顺利，到执行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
bin/mysql_install_db &amp;ndash;user=mysql
&lt;/pre&gt;
就报了usr/local/mysql/libexec/mysqld: unknown variable &amp;lsquo;innodb_data_home_dir=/usr/local/mysql/var/&amp;lsquo;错误。
之前从来没有过，百思不得其解，Google了一下，发现原来是最新的MySQL默认不带innodb引擎。 于是重新编译，在configrue的时候，加上&amp;ndash;with-plugins=innobase这个参数&lt;/p&gt;

&lt;p&gt;之后可以进入数据库，执行
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
mysql&amp;gt;show plugin;&lt;/p&gt;

&lt;p&gt;+————+——–+—————-+————–+———+
| Name       | Status | Type           | Library      | License |
+————+——–+—————-+————–+———+
| binlog     | ACTIVE | STORAGE ENGINE | NULL         | GPL     |
| CSV        | ACTIVE | STORAGE ENGINE | NULL         | GPL     |
| MEMORY     | ACTIVE | STORAGE ENGINE | NULL         | GPL     |
| MyISAM     | ACTIVE | STORAGE ENGINE | NULL         | GPL     |
| MRG_MYISAM | ACTIVE | STORAGE ENGINE | NULL         | GPL     |
| SPHINX     | ACTIVE | STORAGE ENGINE | NULL         | GPL     |
| PBXT       | ACTIVE | STORAGE ENGINE | libpbxt.so   | GPL     |
| InnoDB     | ACTIVE | STORAGE ENGINE | ha_innodb.so | GPL     |
+————+——–+—————-+————–+———+
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;如果还没有，就执行一下
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
mysql&amp;gt;install plugin innodb soname &amp;lsquo;ha_innodb.so&amp;rsquo;;
&lt;/pre&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>EJB3入门（4）实体Bean</title>
      <link>http://blog.prosight.me/blogs/65</link>
      <pubDate>2009-06-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;实体Bean就是跟数据库中某个表对应的一个类。 类的每个实例对应数据库的一行记录。如果用过hibernate的人一定很熟悉这个概念。这个就是所谓的ORM模型。Jboss就是使用的Hibernate来实现的。&lt;/p&gt;

&lt;p&gt;假设数据库中有这样一个表
[caption id=&amp;ldquo;attachment_66&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;498&amp;rdquo; caption=&amp;ldquo;mysql 表结构&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/12.png&#34;&gt;&lt;img src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/12.png&#34; alt=&#34;mysql 表结构&#34; title=&#34;mysql 表结构&#34; width=&#34;498&#34; height=&#34;138&#34; class=&#34;size-full wp-image-66&#34; /&gt;&lt;/a&gt;[/caption]
我们来写一个EJB应用，来把用户的密码得到。&lt;/p&gt;

&lt;p&gt;先对Jboss做相关配置，便于读取数据库。
&lt;strong&gt;设置数据源&lt;/strong&gt;
拷贝jboss安装目录下docs/jca中的mysql-ds.xml到default/deploy目录中，对其中的参数进行修改
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&amp;gt;
&lt;datasources&gt;
  &lt;local-tx-datasource&gt;
    &lt;jndi-name&gt;ejb&lt;/jndi-name&gt;
    &lt;connection-url&gt;jdbc:mysql://localhost:3306/ejb&lt;/connection-url&gt;
    &lt;driver-class&gt;com.mysql.jdbc.Driver&lt;/driver-class&gt;
    &lt;user-name&gt;root&lt;/user-name&gt;
    &lt;password&gt;&lt;/password&gt;
    &lt;exception-sorter-class-name&gt;org.jboss.resource.adapter.jdbc.vendor.MySQLExceptionSorter&lt;/exception-sorter-class-name&gt;
    &lt;metadata&gt;
       &lt;type-mapping&gt;mySQL&lt;/type-mapping&gt;
    &lt;/metadata&gt;
  &lt;/local-tx-datasource&gt;
&lt;/datasources&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;再将mysql的驱动拷贝到default/lib中
在源代码目录下的META-INF中建立配置文件persistence.xml，以便ejb项目可以使用jboss的数据源
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&amp;gt;
&lt;persistence xmlns=&#34;http://java.sun.com/xml/ns/persistence&#34;
    xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34;
    xsi:schemaLocation=&#34;http://java.sun.com/xml/ns/persistence
    http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd&#34;
    version=&#34;1.0&#34;&gt;
    &lt;persistence-unit name=&#34;myentity&#34;&gt;
        &lt;jta-data-source&gt;java:/ejb&lt;/jta-data-source&gt;
        &lt;properties&gt;
            &lt;property name=&#34;hibernate.hbm2ddl.auto&#34; value=&#34;none&#34; /&gt;
            &lt;property name=&#34;hibernate.dialect&#34; value=&#34;org.hibernate.dialect.MySQL5Dialect&#34; /&gt;
        &lt;/properties&gt;
    &lt;/persistence-unit&gt;
&lt;/persistence&gt;
&lt;/pre&gt;
其中jta-data-source中java后面的值一定要跟jboss数据源的jndi-name一致&lt;/p&gt;

&lt;p&gt;下面就可以开始写一个与上面的表对应的实体Bean了
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
package me.prosight.entity;&lt;/p&gt;

&lt;p&gt;import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.Id;
import javax.persistence.Table;&lt;/p&gt;

&lt;p&gt;@Entity
@Table(name=&amp;ldquo;users&amp;rdquo;)
public class User {
    private int id;
    private String name;
    private String password;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Id
public int getId() {
    return id;
}
public void setId(int id) {
    this.id = id;
}

public String getName() {
    return name;
}
public void setName(String name) {
    this.name = name;
}

@Column(name = &amp;quot;password_md5&amp;quot;)
public String getPassword() {
    return password;
}
public void setPassword(String password) {
    this.password = password;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;@Entity 标记表明这是一个实体bean
@Table 标记声明数据库的表的名字，如果不声明，同类名
@Id 表明这个字段是主键
@Column 标记说明这个属性对应的数据库中的字段名，不声明则同属性名。&lt;/p&gt;

&lt;p&gt;我们需要建立一个无状态的session bean来调用实体bean
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
package me.prosight.service;&lt;/p&gt;

&lt;p&gt;import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;&lt;/p&gt;

&lt;p&gt;import me.prosight.entity.User;&lt;/p&gt;

&lt;p&gt;/**
 * Session Bean implementation class UserBean
 */
@Stateless
public class UserBean implements UserBeanRemote {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@PersistenceContext(unitName=&amp;quot;myentity&amp;quot;)
protected EntityManager em;

public String getPassword() {
    User user = em.find(User.class, 1);
    return user.getPassword();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;
其中PersistenceContext中的unitName一定要跟persistence.xml中的persistence-unit中的name一致&lt;/p&gt;

&lt;p&gt;最后，再写个测试类
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
package me.prosight.client;&lt;/p&gt;

&lt;p&gt;import javax.naming.InitialContext;
import javax.naming.NamingException;&lt;/p&gt;

&lt;p&gt;import me.prosight.service.UserBeanRemote;&lt;/p&gt;

&lt;p&gt;public class Client {
    public static void main(String[] args) throws NamingException {
        InitialContext ctx = new InitialContext();
        UserBeanRemote user = (UserBeanRemote)ctx.lookup(&amp;ldquo;UserBean/remote&amp;rdquo;);&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    System.out.println(user.getPassword());
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;
部署好ejb后，再使用这个类测试，应该就可以得到数据库中的数据了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Google MAP API 初步尝试</title>
      <link>http://blog.prosight.me/blogs/70</link>
      <pubDate>2009-06-17 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;今天看了一下午Google的API，发现还挺简单的。稍微懂点Javascript就可以了。
写了个小例子
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;script src=&#34;http://ditu.google.cn/maps?file=api&amp;amp;v=2&amp;amp;key=your_Google_API_key&amp;sensor=true&#34;
            type=&#34;text/javascript&#34;&gt;&lt;/script&gt;
    &lt;script type=&#34;text/javascript&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var map = null;
var geocoder = null;

function initialize() {
  if (GBrowserIsCompatible()) {
    map = new GMap2(document.getElementById(&amp;quot;map_canvas&amp;quot;));
    map.setCenter(new GLatLng(31.22, 121.48), 13);
    geocoder = new GClientGeocoder();

    showAddress(&amp;quot;上海市淮海中路300号&amp;quot;);
  }
}

function createMarker(point,msg) {
    var marker = new GMarker(point);
    var message = msg;
    GEvent.addListener(marker, &amp;quot;click&amp;quot;, function() {
        var myHtml = msg;
        map.openInfoWindowHtml(point, myHtml);
    });
    return marker;
}

function showAddress(address) {
  if (geocoder) {
    geocoder.getLatLng(
      address,
      function(point) {
        if (!point) {
          alert(&amp;quot;不能解析: &amp;quot; + address);
        } else {
          map.setCenter(point, 15);
          var marker = createMarker(point,address);
          map.addOverlay(marker);
        }
      }
    );
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;/script&gt;
&amp;hellip;
&lt;body onload=&#34;initialize()&#34; onunload=&#34;GUnload()&#34;&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;form action=&amp;quot;#&amp;quot; onsubmit=&amp;quot;showAddress(this.address.value); return false&amp;quot;&amp;gt;
  &amp;lt;p style=&amp;quot;margin:0&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; size=&amp;quot;38&amp;quot; name=&amp;quot;address&amp;quot; value=&amp;quot;上海市卢湾区&amp;quot; /&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Go!&amp;quot; /&amp;gt;
  &amp;lt;/p&amp;gt;
  &amp;lt;div id=&amp;quot;map_canvas&amp;quot; style=&amp;quot;width: 320px; height: 400px&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/form&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;
&lt;/pre&gt;
&lt;strong&gt;第一个script是来加载Google Map的库&lt;/strong&gt;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;script src=&#34;http://ditu.google.cn/maps?file=api&amp;v=2&amp;key=abcdefg&amp;sensor=true_or_false&#34;
        type=&#34;text/javascript&#34;&gt;
&lt;/script&gt;
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://ditu.google.cn/maps?file=api&amp;amp;v=2&amp;amp;key=abcdefg&#34;&gt;http://ditu.google.cn/maps?file=api&amp;amp;v=2&amp;amp;key=abcdefg&lt;/a&gt; 网址指向包含使用 Google 地图 API 所需所有符号和定义的 JavaScript 文件的位置。您的页面必须包含指向此网址的 script 标签，使用注册 API 时收到的密钥。在此示例中，该密钥显示为“abcdefg”。&lt;/p&gt;

&lt;p&gt;请注意，我们也传递 sensor 参数以指明此应用程序是否使用传感器来确定用户位置。在此示例中，我们将其设为变量“true_or_false”以强调您必须显式地将此值设置为 true 或 false。&lt;/p&gt;

&lt;h2&gt;设置地图 DOM 元素&lt;/h2&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;div id=&#34;map_canvas&#34; style=&#34;width: 320px; height: 400px&#34;&gt;&lt;/div&gt;
&lt;/pre&gt;
要让地图在网页上显示，必须为其留出一个位置。通常，我们通过创建名为 div 的元素并在浏览器的文档对象模型 (DOM) 中获取此元素的引用执行此操作。

在上述示例中，我们定义名为“map_canvas”的 div，并使用样式属性设置其尺寸。地图会自动使用容器尺寸调整自身的尺寸，除非使用构造函数中的 GMapOptions 显式地为地图指定尺寸。

## GMap2 - 基本对象
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
var map = new GMap2(document.getElementById(&#34;map_canvas&#34;));
&lt;/pre&gt;
GMap2 类是表示地图的 JavaScript 类。此类的对象在页面上定义单个地图。（可以创建此类的多个实例，每个对象将在页面上定义一个不同的地图。）我们使用 JavaScript new 操作符创建此类的一个新实例。

当创建新的地图实例时，在页面中指定一个 DOM 节点（通常是 div 元素）作为地图的容器。HTML 节点是 JavaScript document 对象的子对象，而且我们通过 document.getElementById() 方法获得该元素的引用。

## 初始化地图
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
map.setCenter(new GLatLng(31.22, 121.48), 13);
&lt;/pre&gt;
通过 GMap2 构造函数创建地图后，我们需要再做一件事：将其初始化。初始化通过地图的 setCenter() 方法完成。setCenter() 方法要求有 GLatLng 坐标和缩放级别，而且必须先发送此方法，然后再在地图上执行其他任何操作，包括设置地图本身的其他任何属性。

setCenter()的第二个参数表示放大级别，从0到20，0是最小，20是最大。

## 加载地图
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
&lt;body onload=&#34;initialize()&#34; onunload=&#34;GUnload()&#34;&gt;
&lt;/pre&gt;
当 HTML 页面显示时，文档对象模型 (DOM) 即会扩展，接收其他外部图像和脚本并将其合并到 document 对象中。为确保我们的地图仅放置在完全加载后的页面上，我们仅在 HTML 页面的 &lt;body&gt; 元素收到 onload 事件后才执行构造 GMap2 对象的函数。这样做可以避免出现不可预期的行为，并使我们可以对地图绘制的方式和时间进行更多控制。

onload 属性是事件处理程序的示例。Google 地图 API 还提供了大量事件可以用来“监听”状态变化。请参阅地图事件和事件监听器以了解更多信息。

GUnload() 函数是用来防止内存泄漏的实用工具函数。

## 地址解析
&lt;a href=&#34;http://code.google.com/intl/zh-CN/apis/maps/documentation/reference.html#GClientGeocoder&#34; target=&#34;_blank&#34;&gt;GClientGeocoder类&lt;/a&gt;用来解析地址到经纬度，需要先创建这个类的实例
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
geocoder = new GClientGeocoder();
&lt;/pre&gt;

&lt;p&gt;然后调用getLatLng(address:String, callback:function)方法来在地图上定位。&lt;/p&gt;

&lt;p&gt;getLatLng(address:String, callback:function) 向 Google 服务器发送请求，对指定的地址进行地址解析。如果地址已成功定位，则用 GLatLng 点调用用户指定的回调函数。否则，向回调函数提供一个 null 点。如果地址不明确，则仅向回调函数传递最匹配的点。&lt;/p&gt;

&lt;pre class=&#34;prettyprint linenums&#34;&gt;
geocoder.getLatLng(
          address,
          function(point) {
            if (!point) {
              alert(&#34;不能解析: &#34; + address);
            } else {
              map.setCenter(point, 15);
              var marker = createMarker(point,address);
              map.addOverlay(marker);
            }
          }
        );
&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://code.google.com/intl/zh-CN/apis/maps/documentation/reference.html#GMarker&#34; target=&#34;_blank&#34;&gt;GMarker类&lt;/a&gt;用来生成标记，就是地图中的那个红点，它可以有一个信息窗口，通过openInfoWindow方法来打开。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
var marker = new GMarker(point);
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;通过调用GMap2类的addOverlay(overlay:GOverlay) 方法，给地图添加一个叠加层，用来显示上面定义的标记。&lt;/p&gt;

&lt;p&gt;通过GEvent类的addListener方法，为标记添加鼠标点击事件的监听，当在标记上按下鼠标的时候，显示信息窗口。
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
GEvent.addListener(marker, &amp;ldquo;click&amp;rdquo;, function() {
            var myHtml = msg;
            map.openInfoWindowHtml(point, myHtml);
        });
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;可以在&lt;a href=&#34;http://www.prosight.me/map.htm&#34; target=&#34;_blank&#34;&gt;这里&lt;/a&gt;查看效果&lt;/p&gt;
</description>
    </item>
    <item>
      <title>EJB3入门（2）Stateful Session bean</title>
      <link>http://blog.prosight.me/blogs/51</link>
      <pubDate>2009-06-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;有了上节无状态session bean的基础，这回试着做一个有状态的session bean。 有状态的session bean语法上跟无状态session bean只有一个元标记的区别，把实现类里面的@Stateless替换成@Stateful就可以了。&lt;/p&gt;

&lt;p&gt;如果使用Stateful Sessionbean，客户端在使用同一个SessionBean对象实例时可以保存状态，也就是说，在多次引用该对象时实际上在服务端是使用的同一个Sessionbean的对象实例，而无状态sessionbean使用了不同的sessionbean对象实例，因此，是无法保存状态的。&lt;/p&gt;

&lt;p&gt;最直接的例子就是购物车，购物车是跟着用户来的，需要保持状态，否则人家挑好的东西都不见了。&lt;/p&gt;

&lt;p&gt;先写一个接口：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
package me.prosight;&lt;/p&gt;

&lt;p&gt;import java.util.List;
import javax.ejb.Remote;&lt;/p&gt;

&lt;p&gt;@Remote
public interface ShoppingCartRemote {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public void addProduct(String name);
public List&amp;lt;string&amp;gt; getAllProducts();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;再写一个实现类：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
package me.prosight;&lt;/p&gt;

&lt;p&gt;import java.util.ArrayList;
import java.util.List;&lt;/p&gt;

&lt;p&gt;import javax.ejb.Stateful;&lt;/p&gt;

&lt;p&gt;@Stateful
public class ShoppingCartBean implements ShoppingCartRemote {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;private List&amp;lt;string&amp;gt; shoppingCart = new ArrayList&amp;lt;string&amp;gt;();

@Override
public void addProduct(String name) {
    shoppingCart.add(name);

}

@Override
public List&amp;lt;string&amp;gt; getAllProducts() {
    return shoppingCart;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;&lt;/p&gt;

&lt;p&gt;最后再写一个测试类
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
package me.prosight;&lt;/p&gt;

&lt;p&gt;import java.util.List;&lt;/p&gt;

&lt;p&gt;import javax.naming.InitialContext;
import javax.naming.NamingException;&lt;/p&gt;

&lt;p&gt;public class Client {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws NamingException {
    InitialContext ctx = new InitialContext();
    ShoppingCartRemote cart = (ShoppingCartRemote) ctx.lookup(&amp;quot;ShoppingCartBean/remote&amp;quot;);
    cart.addProduct(&amp;quot;Apple&amp;quot;);
    cart.addProduct(&amp;quot;IBM&amp;quot;);
    cart.addProduct(&amp;quot;Dell&amp;quot;);

    List&amp;lt;string&amp;gt; products = cart.getAllProducts();
    for (String product : products)
    {
        System.out.println(product);
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}
&lt;/pre&gt;
在客户端调用时，需要将ShoppingCart接口复制到客户端，当然，@Remote可以去掉。别忘了引用JBoss安装目录中的client目录中的jar文件。客户端仍然使用了jndi.properties文件来配置相应的信息，该文件位于源代码目录下，内容如下;
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory
java.naming.provider.url=localhost
&lt;/pre&gt;
在执行上面的程序后，将输出如下的信息:
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Apple
IBM
Dell
&lt;/pre&gt;
要注意的是，需要使用同一个sessionbean对象实例（cart）才能保存状态。如果在web应用程序中，需要将cart对象保存在Session中，这样在同一个会话中的用户就可以使用该购物车对象了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>SSH的快捷方式</title>
      <link>http://blog.prosight.me/blogs/48</link>
      <pubDate>2009-06-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;平常我们在使用ssh的时候，经常需要以
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ssh [user]@[remote.server.com]
&lt;/pre&gt;
这样的形式来登录远程主机，每次输入用户名和主机的ip地址很麻烦。 后来发现可以在~/.ssh/config中进行配置
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
Host [the alias]
HostName [domain name or IP address]
User [the account to login as]
&lt;/pre&gt;
这样以后就可以使用alias这个昵称来登录。例如原来你使用ssh root@172.1.1.200来登录，你起了一个test的昵称，之后你就可以使用
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
ssh test
&lt;/pre&gt;
来登录了。 甚至scp都可以，如：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;
scp sometext.txt test
&lt;/pre&gt;
是不是较原来方便了很多。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>EJB3入门（3）本地接口</title>
      <link>http://blog.prosight.me/blogs/53</link>
      <pubDate>2009-06-16 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;之前用到的都是远程接口，顾名思义，远程接口就是提供不再同一个虚拟机中的两端程序来访问的。适合于分布式部署。但是有的时候客户端和服务端又在一个jvm中，比如在一个tomcat或者jboss的web容器中。这个时候就没有必要用远程接口了，毕竟浪费资源。可以改用local接口。&lt;/p&gt;

&lt;p&gt;如果你尝试将上一节中的remote直接替换成local，再执行客户端，你会发现如下错误：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;Could not find InvokerLocator URL at JNDI address &amp;ldquo;ShoppingCartBean/local&amp;rdquo;; looking up local Proxy from Remote JVM?&lt;/pre&gt;
这说明你试图通过远程的jvm来调用本地的端口，因为客户端执行的这个jvm与ejb容器的jvm是两个不同的虚拟机。所以本地接口调用会失败。&lt;/p&gt;

&lt;p&gt;在这里我们再建立一个web工程，创建web工程的时候，可以顺便创建一个EAR工程。&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_54&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;331&amp;rdquo; caption=&amp;ldquo;创建web工程&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/11.png&#34;&gt;&lt;img class=&#34;size-full wp-image-54&#34; title=&#34;创建web工程&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/11.png&#34; alt=&#34;创建web工程&#34; width=&#34;331&#34; height=&#34;122&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;然后在这个web工程中加入对之前shoppingcart项目的引用。注意，这里已经将shoppingcart项目中的接口改为local方式。&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_84&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;543&amp;rdquo; caption=&amp;ldquo;修改Build Path &amp;ldquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/13.png&#34;&gt;&lt;img class=&#34;size-full wp-image-84&#34; title=&#34;修改Build Path &#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/13.png&#34; alt=&#34;修改Build Path &#34; width=&#34;543&#34; height=&#34;56&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;在Java build path中，点击projects标签，点击add按钮，加入shoppingcart的项目&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_56&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;536&amp;rdquo; caption=&amp;ldquo;加入相关项目&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/31.png&#34;&gt;&lt;img class=&#34;size-full wp-image-56&#34; title=&#34;加入相关项目&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/31.png&#34; alt=&#34;加入相关项目&#34; width=&#34;536&#34; height=&#34;118&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;之后，在web项目中新建一个jsp页面，如index.jsp，代码如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;&lt;/pre&gt;
之后就可以将EAR项目导出到jboss的部署目录中了。&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_60&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;443&amp;rdquo; caption=&amp;ldquo;导出EAR&amp;rdquo;]&lt;a href=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/41.png&#34;&gt;&lt;img class=&#34;size-full wp-image-60&#34; title=&#34;导出EAR&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/41.png&#34; alt=&#34;导出EAR&#34; width=&#34;443&#34; height=&#34;74&#34; /&gt;&lt;/a&gt;[/caption]&lt;/p&gt;

&lt;p&gt;部署好以后，jboss的输出会提示：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;19:26:53,132 INFO  [TomcatDeployment] deploy, ctxPath=/EJBWeb&lt;/pre&gt;
之后就可以在浏览器中输入localhost:8080/EJBWeb来测试本地接口了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Mac OS X的日常维护</title>
      <link>http://blog.prosight.me/blogs/19</link>
      <pubDate>2009-06-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;Mac OS X如同其他操作系统一样，经常维护修理，你将不会常常遇到程序意外退出，程序打不开，甚至系统突然瘫痪的状况。下面是一些维护系统的基本方法，供各位参考：
1. 修理权限(Repair Disk Permmisions) 修理文件和文件夹的权限，是X系统最主要的一项非插入式系统维护作业之一。你可以启动磁盘工具在后台运行，还可以一边继续你的工作。修理权限，能确保系统安装器将档案安装在正确的位置，这样在调用这些档案的时候不致被系统拒绝打开。也防止你安装的部件该上锁而未锁，防止一些程序将不该写入的东西错误地写入一些档案里，导致程序或系统出错。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;修理磁盘(Reparing the Disk) 你如果一直使用一个档案系统已经损坏的硬盘，那在某日它将毫无预报就突然罢工，你的损失一定残不忍睹。要预防这种事情发生，就要用第一张系统安装光盘来启动系统，从安装菜单上打开磁盘工具，选择和运行修理磁盘。如果档案系统出现严重错误，你可能还需要反复运行数次修理磁盘。
为了确保你的数据安全，一定要经常备份你的重要数据，修理磁盘之前最好也备份一次。要想知道你的硬盘的健康状况，看看那个S.M.A.R.T.的状态就知道。如果要作为一项规则，最好是每星期检查一次S.M.A.R.T.的状态。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;强迫定期维护(Forcing Periodic Maintenance) 大家也许都知道，X系统在每天凌晨3点、4点或者5点的时候会定期维护，清除无用的日志和缓存文件，同时也备份一些UNIX的文件。不过如果你在这段时间里把系统关闭或让系统睡眠，那定期维护作业将无法运行。虽然不运行这样的维护并不会使你的系统出大问题，但是经常维护却让你的硬盘能藤出更多的空间。
如果你并不想在半夜的时候起床打开系统，可以在任何时候强迫系统进行维护。打开终端程序，分别输入：
sudo periodic daily
sudo periodic weekly
sudo periodic monthly
要等待每日维护的进程完成才开始每周维护，然后是每月维护。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;更新装订加固(Update Prebinding) 有时候因为一些不明的原因，在安装了一个巨集程序之后，你系统运行会变得慢如蜗牛爬行。这时候如果你强迫系统将所有程序的档案分类集中，确保同类档案之间能正确地联系在一起，系统才能恢复正常的运行。
只要打开终端，输入：
sudo update_prebinding -root / -force
然后按回车，输入密码，再按回车就可以了。当运行结束后，重新出现$的提示符，记得立即重新启动系统(Restart)。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;上述4个维护系统的方法，应该何时和多久做一次呢？
*如果你没有进行特别的程序安装，每月按以下顺序做一次： a. 修理权限； b. 修理磁盘； c. 强迫定期维护。
&lt;strong&gt;在运行程序挂机，意外断电或者系统强迫重启之后，立即做： a. 首先修理磁盘； b. 修理权限。
做完上两个修理之后，如果系统变慢： a. 强迫定期维护； b. 更新装订加固。
***安装大型的新程序，或者进行系统更新： 之前做： a. 修理权限； b. 修理硬盘。
之后做： 用最新的磁盘工具(指系统更新之后，如果有更新的磁盘工具)修理权限和档案系统。
**&lt;/strong&gt;关于整理硬盘破碎 X系统本身能够处理一般的文件破碎，系统自己会整理一些小于20MB的档案碎片，而且这些碎片是磁盘中最多的。况且，利用第三方工具软件来整理磁盘存在非常大的风险，数据会在整个磁盘上不停转移，使得硬盘非常疲劳并可能导致机械损坏。所以，如果没有必要的理由，不应该用第三方的工具程序去整理磁盘碎片。
*****关于用更新程序或系统的方法来解决故障 许多粉丝在升级系统或程序后，都反映某程序打不开了，或者意外退出了。应该检讨一下，是否已按照上面的方法做了。有些粉丝使用中遇到一些难题后，试图通过更新操作系统或程序，或者降级的方式来解决这些问题。然而，除非这些问题确实是由更新引起的(但是这并不多见)，更新或降级一个有问题的程序或系统将使情况更加糟糕。执行上面列出的4个维护修理系统的步骤，应能让你解决大多数可能遇到的问题。
系统的磁盘工具有全新的恢复功能，可以利用它来备份数据和抢救开机硬盘。尽管X系统是非常强劲的操作系统，稳定易用，但它仍然需要经常维护，以确保系统的平稳运行。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>在XCODE中替换__MyCompanyName__的名字</title>
      <link>http://blog.prosight.me/blogs/22</link>
      <pubDate>2009-06-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;在使用XCODE的时候，在注释中有一段公司版权的信息，但是始终是&lt;strong&gt;MyCompanyName&lt;/strong&gt;，而且也没找到相应的界面去更改。后来发现，可以通过在命令行使用如下命令，进行更改：&lt;/p&gt;

&lt;p&gt;defaults write com.apple.Xcode PBXCustomTemplateMacroDefinitions &amp;lsquo;{&amp;ldquo;ORGANIZATIONNAME&amp;rdquo;=&amp;ldquo;SomeOther Co.&amp;rdquo;;}&amp;rsquo;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>EJB3入门（1）Stateless Session bean</title>
      <link>http://blog.prosight.me/blogs/25</link>
      <pubDate>2009-06-13 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;一直想学EJB，今天有空开始学习。&lt;/p&gt;

&lt;p&gt;下载相关资源
JDK 1.6u14 &lt;a href=&#34;http://java.sun.com&#34;&gt;http://java.sun.com&lt;/a&gt;
eclipse 3.4 &lt;a href=&#34;http://www.eclipse.org&#34;&gt;http://www.eclipse.org&lt;/a&gt;
Jboss tools &lt;a href=&#34;http://jboss.org/tools&#34;&gt;http://jboss.org/tools&lt;/a&gt;
Jboss AS 5.1.0AS &lt;a href=&#34;http://www.jboss.org/jbossas&#34;&gt;http://www.jboss.org/jbossas&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;安装配置好后，我们开始写第一个EJB， 先写个无状态的Session Bean &amp;ndash; Hello world&lt;/p&gt;

&lt;p&gt;先定义接口
&lt;pre class=&#34;prettyprint linenums&#34;&gt;package me.prosight;
import javax.ejb.Remote;&lt;/p&gt;

&lt;p&gt;@Remote
public interface HelloRemote {
    public String sayHello(String name);&lt;/p&gt;

&lt;p&gt;}&lt;/pre&gt;
再定义实现
&lt;pre class=&#34;prettyprint linenums&#34;&gt;package me.prosight;&lt;/p&gt;

&lt;p&gt;import javax.ejb.Stateless;&lt;/p&gt;

&lt;p&gt;/**
 * Session Bean implementation class Hello
 */
@Stateless
public class HelloBean implements HelloRemote {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@Override
public String sayHello(String name) {
    return &amp;quot;Hello &amp;quot; + name;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/pre&gt;
启动Jboss服务器，将刚刚的EJB应用部署到jboss中。右键点击项目名称，然后选择Export&amp;ndash;&amp;gt;EJB/JAR file&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_32&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;446&amp;rdquo; caption=&amp;ldquo;EJB项目部署&amp;rdquo;]&lt;img class=&#34;size-full wp-image-32&#34; title=&#34;EJB项目部署&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/1.png&#34; alt=&#34;EJB项目部署&#34; width=&#34;446&#34; height=&#34;111&#34; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;将这个Jar包部署到/server/default/deploy中，一会jboss就会自动将这个应用部署到jboss的容器中，后面我们就可以使用这个ejb了。&lt;/p&gt;

&lt;p&gt;再写一个测试客户端
&lt;pre class=&#34;prettyprint linenums&#34;&gt;package me.prosight;&lt;/p&gt;

&lt;p&gt;import javax.naming.Context;
import javax.naming.InitialContext;
import javax.naming.NamingException;&lt;/p&gt;

&lt;p&gt;public class HelloClent {&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;public static void main(String[] args) throws NamingException {
    Context ctx = new InitialContext();
    HelloRemote hello = (HelloRemote) ctx.lookup(&amp;quot;HelloBean/remote&amp;quot;);
    String msg = hello.sayHello(&amp;quot;Elton&amp;quot;);
    System.out.println(msg);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;}&lt;/pre&gt;
客户端要注意两件事情
&lt;ol&gt;
    &lt;li&gt;确保正确设置了JNDI&lt;/li&gt;
    &lt;li&gt;在引用远程的EJB bean的时候，要使用对应的接口来引用而不是实现类。&lt;/li&gt;
&lt;/ol&gt;
JNDI是Java命名和目录接口，是用来标记EJB的bean位置的。 &lt;strong&gt;如果你的客户端和EJB不在一个JVM中运行，就需要配置JNDI。&lt;/strong&gt;当你部署好一个EJB的应用，会在控制台中显示出调用这个EJB的所有的JNDI名称，如：&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_40&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;362&amp;rdquo; caption=&amp;ldquo;JNDI&amp;rdquo;]&lt;img class=&#34;size-full wp-image-40&#34; title=&#34;JNDI&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/4.png&#34; alt=&#34;JNDI&#34; width=&#34;362&#34; height=&#34;42&#34; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;在InitialContext的lookup方法中就可以使用这个名称来引用相关的Bean了。&lt;/p&gt;

&lt;p&gt;配置JNDI有两个方法，一个就是在源文件目录中建立jndi.properties文件，我的这个文件内容如下：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;java.naming.factory.initial=org.jnp.interfaces.NamingContextFactory java.naming.factory.url.pkgs=org.jboss.naming:org.jnp.interfaces java.naming.provider.url=localhost:1099&lt;/pre&gt;
provide.url指定的是EJB容器的地址和端口，可以使用IP地址来指定你的EJB容器装在哪台服务器上。&lt;/p&gt;

&lt;p&gt;或者在程序中以编程的方式来指定，在new InitialContext()前，输入如下代码：
&lt;pre class=&#34;prettyprint linenums&#34;&gt;Properties props = new Properties();
props.setProperty(&amp;ldquo;java.naming.factory.initial&amp;rdquo;, &amp;ldquo;org.jnp.interfaces.NamingContextFactory&amp;rdquo;);
props.setProperty(&amp;ldquo;java.naming.factory.url.pkgs&amp;rdquo;, &amp;ldquo;org.jboss.naming&amp;rdquo;);
props.setProperty(&amp;ldquo;java.naming.provider.url&amp;rdquo;, &amp;ldquo;localhost:1099&amp;rdquo;);
InitialContext ctx = new InitialContext(props);&lt;/pre&gt;
运行这个程序，将会在控制台中看到：&lt;/p&gt;

&lt;p&gt;[caption id=&amp;ldquo;attachment_36&amp;rdquo; align=&amp;ldquo;alignnone&amp;rdquo; width=&amp;ldquo;257&amp;rdquo; caption=&amp;ldquo;程序输出&amp;rdquo;]&lt;img class=&#34;size-full wp-image-36&#34; title=&#34;程序输出&#34; src=&#34;http://blog.prosight.me/wp-content/uploads/2009/06/3.png&#34; alt=&#34;程序输出&#34; width=&#34;257&#34; height=&#34;102&#34; /&gt;[/caption]&lt;/p&gt;

&lt;p&gt;第一个EJB的Hello World就完成了。还很简单吧。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.prosight.me/blog/wp-content/uploads/2009/06/EJBTest.zip&#34;&gt;工程源代码&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Gentoo安装后安装网卡</title>
      <link>http://blog.prosight.me/blogs/14</link>
      <pubDate>2009-06-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;安装好Gentoo后，重启发现网卡找不到。&lt;/p&gt;

&lt;p&gt;后来发现原来是没有安装相应的网卡驱动。之前使用livecd的时候，是光盘自动安装的驱动，但是安装好系统后，重启过后就是读你在编译内核的时候选择的驱动了。&lt;/p&gt;

&lt;p&gt;没办法，只有重新编译内核，将&lt;/p&gt;

&lt;p&gt;Device Drivers  &amp;mdash;&amp;gt;
下的你所对应的网卡驱动选择上。重新编译后，再重启后就可以发现找到网卡了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Gentoo 启动SSH</title>
      <link>http://blog.prosight.me/blogs/17</link>
      <pubDate>2009-06-04 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;刚刚安装完Gentoo会发现什么服务也没有启动。&lt;/p&gt;

&lt;p&gt;通过&lt;/p&gt;

&lt;p&gt;/etc/init.d/sshd start&lt;/p&gt;

&lt;p&gt;可以启动ssh服务&lt;/p&gt;

&lt;p&gt;添加&lt;/p&gt;

&lt;p&gt;rc-update add sshd default&lt;/p&gt;

&lt;p&gt;后，重启就可以自动启动ssh了。&lt;/p&gt;
</description>
    </item>
    <item>
      <title>CentOS 5.3安装Nagios</title>
      <link>http://blog.prosight.me/blogs/10</link>
      <pubDate>2009-06-02 12:00:00 +0800</pubDate>
      <description>&lt;hr /&gt;

&lt;p&gt;安装软件&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;确保以下包都被安装&lt;/p&gt;

&lt;p&gt;yum install gcc
yum install glibc glibc-common
yum install gd gd-devel&lt;/p&gt;

&lt;p&gt;成为root用户
su -l&lt;/p&gt;

&lt;p&gt;创建Nagios用户
/usr/sbin/useradd -m nagios
passwd nagios&lt;/p&gt;

&lt;p&gt;创建Nagios用户组并把nagios用户和apache用户加入到这个组里&lt;/p&gt;

&lt;p&gt;/usr/sbin/groupadd nagcmd
/usr/sbin/usermod -a -G nagcmd nagios
/usr/sbin/usermod -a -G nagcmd apache&lt;/p&gt;

&lt;p&gt;创建下载目录
mkdir ~/downloads
cd ~/downloads&lt;/p&gt;

&lt;p&gt;下载文件
wget &lt;a href=&#34;http://osdn.dl.sourceforge.net/sourceforge/nagios/nagios-3.0.6.tar.gz&#34;&gt;http://osdn.dl.sourceforge.net/sourceforge/nagios/nagios-3.0.6.tar.gz&lt;/a&gt;
wget &lt;a href=&#34;http://osdn.dl.sourceforge.net/sourceforge/nagiosplug/nagios-plugins-1.4.11.tar.gz&#34;&gt;http://osdn.dl.sourceforge.net/sourceforge/nagiosplug/nagios-plugins-1.4.11.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;解压源文件
cd ~/downloads
tar xzf nagios-3.0.6.tar.gz
cd nagios-3.0.6&lt;/p&gt;

&lt;p&gt;运行配置脚本，指定用户组
./configure &amp;ndash;with-command-group=nagcmd &amp;ndash;with-httpd-conf=/usr/local/apache/conf&lt;/p&gt;

&lt;p&gt;编译
make all&lt;/p&gt;

&lt;p&gt;安装
make install
make install-init
make install-config
make install-commandmode&lt;/p&gt;

&lt;p&gt;一些配置可以在这里修改&lt;/p&gt;

&lt;p&gt;vi /usr/local/nagios/etc/objects/contacts.cfg&lt;/p&gt;

&lt;p&gt;安装Apache的web配置文件到Apache的配置目录.
make install-webconf&lt;/p&gt;

&lt;p&gt;创建web界面管理员
/usr/local/apache/bin/htpasswd -c /usr/local/nagios/etc/htpasswd.users nagiosadmin&lt;/p&gt;

&lt;p&gt;重启apache使配置生效
/usr/local/apache/bin/apachectl restart&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;安装插件&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;cd ~/downloads
tar xzf nagios-plugins-1.4.11.tar.gz
cd nagios-plugins-1.4.11&lt;/p&gt;

&lt;p&gt;配置编译
./configure &amp;ndash;with-nagios-user=nagios &amp;ndash;with-nagios-group=nagios
make
make install&lt;/p&gt;

&lt;p&gt;如果make的时候出现openssl的错误，需要在make的时候加上
make LDFLAGS+=-ldl（http://yahoon.blog.51cto.com/13184/43020）&lt;/p&gt;

&lt;p&gt;将Nagios加到系统启动列表中
chkconfig &amp;ndash;add nagios
chkconfig nagios on&lt;/p&gt;

&lt;p&gt;验证配置文件正确性
/usr/local/nagios/bin/nagios -v /usr/local/nagios/etc/nagios.cfg&lt;/p&gt;

&lt;p&gt;如果没有问题，就启动
service nagios start&lt;/p&gt;

&lt;p&gt;然后通过
&lt;a href=&#34;http://localhost/nagios就可以访问了&#34;&gt;http://localhost/nagios就可以访问了&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;安装NRPE&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;监控主机需要安装check_nrpe，被监控机器需要安装nrpe。他们需要通SSH连接，使用5666端口通信&lt;/p&gt;

&lt;p&gt;被监控机器安装&lt;/p&gt;

&lt;p&gt;创建帐号
/usr/sbin/useradd nagios
passwd nagios&lt;/p&gt;

&lt;p&gt;安装Nagios插件
wget &lt;a href=&#34;http://osdn.dl.sourceforge.net/sourceforge/nagiosplug/nagios-plugins-1.4.13.tar.gz&#34;&gt;http://osdn.dl.sourceforge.net/sourceforge/nagiosplug/nagios-plugins-1.4.13.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;tar xzf nagios-plugins-1.4.13.tar.gz
cd nagios-plugins-1.4.13&lt;/p&gt;

&lt;p&gt;./configure
make
make install&lt;/p&gt;

&lt;p&gt;yum install xinetd&lt;/p&gt;

&lt;p&gt;wget &lt;a href=&#34;http://osdn.dl.sourceforge.net/sourceforge/nagios/nrpe-2.12.tar.gz&#34;&gt;http://osdn.dl.sourceforge.net/sourceforge/nagios/nrpe-2.12.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;tar xzf nrpe-2.8.tar.gz
cd nrpe-2.8&lt;/p&gt;

&lt;p&gt;./configure
make all&lt;/p&gt;

&lt;p&gt;安装插件（为了测试），守候进程和示例配置文件
make install-plugin
make install-daemon
make install-daemon-config&lt;/p&gt;

&lt;p&gt;安装xinetd的NRPE服务
make install-xinetd&lt;/p&gt;

&lt;p&gt;编辑 /etc/xinetd.d/nrpe 文件在 only_from 后加入监控主机的ip.
only_from = 127.0.0.1 &amp;lt;nagios_ip_address&amp;gt;&lt;/p&gt;

&lt;p&gt;在/etc/services加入下面的条目&lt;/p&gt;

&lt;p&gt;nrpe         5666/tcp             # NRPE&lt;/p&gt;

&lt;p&gt;重启Xinetd&lt;/p&gt;

&lt;p&gt;service xinetd restart&lt;/p&gt;

&lt;p&gt;本地测试
netstat -at | grep nrpe
会显示
tcp             0             0 &lt;em&gt;:nrpe     *:&lt;/em&gt;     LISTEN
/usr/local/nagios/libexec/check_nrpe -H localhost
会显示nrpe的版本信息&lt;/p&gt;

&lt;p&gt;打开防火墙&lt;/p&gt;

&lt;p&gt;iptables -I RH-Firewall-1-INPUT -p tcp -m tcp –dport 5666 -j ACCEPT&lt;/p&gt;

&lt;p&gt;service iptables save&lt;/p&gt;

&lt;p&gt;监控主机安装&lt;/p&gt;

&lt;p&gt;安装 check_nrpe 插件&lt;/p&gt;

&lt;p&gt;wget &lt;a href=&#34;http://osdn.dl.sourceforge.net/sourceforge/nagios/nrpe-2.12.tar.gz&#34;&gt;http://osdn.dl.sourceforge.net/sourceforge/nagios/nrpe-2.12.tar.gz&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;tar xzf nrpe-2.12.tar.gz
cd nrpe-2.12&lt;/p&gt;

&lt;p&gt;./configure
make all&lt;/p&gt;

&lt;p&gt;make install-plugin&lt;/p&gt;

&lt;p&gt;测试NRPE守候进程
/usr/local/nagios/libexec/check_nrpe -H 192.168.0.1（被监控端的ip）
将会返回被监控端的nrpe版本信息&lt;/p&gt;
</description>
    </item>
    <item>
      <title>Mac 下基于ruby 1.9安装Rails</title>
      <link>http://blog.prosight.me/blogs/5</link>
      <pubDate>2009-05-24 12:00:00 +0800</pubDate>
      <description>&lt;p&gt;ruby 1.9.1出来了，今天用它安装了rails。 一次成功， 将过程记录下来，备忘。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;源码安装Ruby&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;tar xvzf ruby-1.9.1-p0.tar.gz
cd ruby-1.9.1&lt;/p&gt;

&lt;p&gt;./configure &amp;ndash;enable-shared &amp;ndash;enable-pthread CFLAGS=-D_XOPEN_SOURCE=1&lt;/p&gt;

&lt;p&gt;make
sudo make install&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;安装Ruby&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;sudo gem install rails&lt;/p&gt;

&lt;p&gt;升级gem
sudo gem update &amp;ndash;system&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;安装Ruby for sqlite3&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;sudo gem install sqlite3-ruby&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;源码安装MySQL&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;tar xvzf mysql-5.1.34.tar.gz
cd mysql-5.1.34.tar.gz&lt;/p&gt;

&lt;p&gt;CC=gcc CFLAGS=&amp;ldquo;-O3 -fno-omit-frame-pointer&amp;rdquo; CXX=gcc
CXXFLAGS=&amp;ldquo;-O3 -fno-omit-frame-pointer -felide-constructors
-fno-exceptions -fno-rtti&amp;rdquo;
./configure &amp;ndash;prefix=/usr/local/mysql
&amp;ndash;with-extra-charsets=complex &amp;ndash;enable-thread-safe-client
&amp;ndash;enable-local-infile &amp;ndash;disable-shared &amp;ndash;with-plugins=innobase&lt;/p&gt;

&lt;p&gt;make
sudo make install&lt;/p&gt;

&lt;p&gt;cd /usr/local/mysql
sudo ./bin/mysql_install_db &amp;ndash;user=mysql
sudo chown -R mysql ./var/
sudo chgrp -R mysql .&lt;/p&gt;

&lt;p&gt;cd /Library/LaunchDaemons
sudo vim com.mysql.mysqld.plist
输入&lt;/p&gt;

&lt;p&gt;&amp;lt;?xml version=&amp;ldquo;1.0&amp;rdquo; encoding=&amp;ldquo;UTF-8&amp;rdquo;?&amp;gt;
&amp;lt;!DOCTYPE plist PUBLIC &amp;ldquo;-//Apple//DTD PLIST 1.0//EN&amp;rdquo; &amp;ldquo;http://www.apple.com/DTDs/PropertyList-1.0.dtd&amp;rdquo;&amp;gt;
&amp;lt;plist version=&amp;ldquo;1.0&amp;rdquo;&amp;gt;
&amp;lt;dict&amp;gt;
&amp;lt;key&amp;gt;KeepAlive&amp;lt;/key&amp;gt;
&amp;lt;true/&amp;gt;
&amp;lt;key&amp;gt;Label&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;com.mysql.mysqld&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;Program&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;/usr/local/mysql/bin/mysqld_safe&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;RunAtLoad&amp;lt;/key&amp;gt;
&amp;lt;true/&amp;gt;
&amp;lt;key&amp;gt;UserName&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;mysql&amp;lt;/string&amp;gt;
&amp;lt;key&amp;gt;WorkingDirectory&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;/usr/local/mysql&amp;lt;/string&amp;gt;
&amp;lt;/dict&amp;gt;
&amp;lt;/plist&amp;gt;&lt;/p&gt;

&lt;p&gt;sudo chown root /Library/LaunchDaemons/com.mysql.mysqld.plist&lt;/p&gt;

&lt;p&gt;启动MySQL
sudo launchctl load -w /Library/LaunchDaemons/com.mysql.mysqld.plist&lt;/p&gt;

&lt;p&gt;手工停止MySQL
sudo launchctl unload -w /Library/LaunchDaemons/com.mysql.mysqld.plist&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;设置路径&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;mate ~/.bash_login
或者
mate ~/.profile&lt;/p&gt;

&lt;p&gt;添加：
export PATH=&amp;ldquo;/usr/local/bin:/usr/local/sbin:/usr/local/mysql/bin:$PATH&amp;rdquo;&lt;/p&gt;

&lt;p&gt;为了使其生效， 执行
. ~/.bash_login 或者 . ~/.profile&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;源码安装MySQL C Binding for Ruby&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;tar xvzf mysql-ruby-2.8.1
cd mysql-ruby-2.8.1
ruby extconf.rb &amp;ndash;with-mysql-config=/usr/local/mysql/bin/mysql_config -with-mysql-dir=/usr/local/mysql
make
sudo make install&lt;/p&gt;
</description>
    </item>
  </channel>
</rss>